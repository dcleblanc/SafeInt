[
  {
    "Id": "1345056",
    "ThreadId": "578321",
    "Html": "Hello,<br />\n<br />\nI was trying out the idea of replacing every int with SafeInt; however, there are some problems.<br />\n<br />\nIt seems that you cannot just write one to cout. That's quickly fixed:<br />\n<pre><code>template &lt;typename CharT, typename TraitsT, typename IntT, typename ErrT&gt;\ntypename std::basic_ostream&lt;CharT, TraitsT&gt; &amp; operator&lt;&lt;(typename std::basic_ostream&lt;CharT, TraitsT&gt; &amp;stream, const typename SafeInt&lt;IntT, ErrT&gt; &amp;val) {\n    return stream &lt;&lt; static_cast&lt;IntT&gt;(val);\n}</code></pre>\n\nSometimes it's more convenient to use boost::format. However, I can't seem to get this work:<br />\n<pre><code>#include &lt;iostream&gt;\n#include &lt;boost/format.hpp&gt;\n#include &lt;SafeInt.hpp&gt;\n\ntemplate &lt;typename CharT, typename TraitsT, typename IntT, typename ErrT&gt;\ntypename std::basic_ostream&lt;CharT, TraitsT&gt; &amp; operator&lt;&lt;(typename std::basic_ostream&lt;CharT, TraitsT&gt; &amp;stream, const typename SafeInt&lt;IntT, ErrT&gt; &amp;val) {\n    return stream &lt;&lt; static_cast&lt;IntT&gt;(val);\n}\n\ntemplate &lt;typename Ch, typename Tr, typename Alloc, typename IntT, typename ErrT&gt;\ntypename boost::basic_format&lt;Ch, Tr, Alloc&gt; &amp; operator%(typename boost::basic_format&lt;Ch, Tr, Alloc&gt; &amp;fmt, const typename SafeInt&lt;IntT, ErrT&gt; &amp;val) {\n    return fmt % static_cast&lt;IntT&gt;(val);\n}\n\nint main() {\n    using namespace std;\n    using namespace boost;\n\n    typedef SafeInt&lt;size_t&gt; SizeT;\n    SizeT x = 12;\n    //cout &lt;&lt; x &lt;&lt; endl;\n    auto fmt = format(&quot;Size is %1%&quot;) % x;\n    cout &lt;&lt; fmt &lt;&lt; endl;\n}</code></pre>\n\nWith Visual C 2013 I get these errors:<br />\n<pre><code>main.cpp(26): error C2593: 'operator %' is ambiguous\n          boost/format/format_class.hpp(63): could be 'boost::basic_format&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt; &amp;boost::basic_format&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::operator %&lt;SizeT&gt;(const T &amp;)'\n          with\n          [\n              T=SizeT\n          ]\n          SafeInt.hpp(6633): or       'SafeInt&lt;size_t,CPlusPlusExceptionHandler&gt; operator %&lt;size_t,boost::basic_format&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;,CPlusPlusExceptionHandler&gt;(U,SafeInt&lt;size_t,CPlusPlusExceptionHandler&gt;)'\n          with\n          [\n              U=boost::basic_format&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;\n          ]\n          main.cpp(13): or       'boost::basic_format&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt; &amp;boost::operator %&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;,size_t,CPlusPlusExceptionHandler&gt;(boost::basic_format&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt; &amp;,const SafeInt&lt;size_t,CPlusPlusExceptionHandler&gt; &amp;)'\n          while trying to match the argument list '(boost::basic_format&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;, SizeT)'\nmain.cpp(27): error C3536: 'fmt': cannot be used before it is initialized</code></pre>\n\nIsn't my operator% the more specialized version?<br />\n<br />\nThanks,<br />\nFlorin<br />\n",
    "PostedDate": "2015-01-22T02:55:54.003-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1345061",
    "ThreadId": "578321",
    "Html": "A workaround for this would be to create my own class, derived from boost::format. This way my operator would take precedence.<br />\n<pre><code>template &lt;class Ch&gt;\nclass BasicFormat : public boost::basic_format&lt;Ch&gt; {\n    typedef boost::basic_format&lt;Ch&gt; BaseT;\npublic:\n    BasicFormat(const char *psz) : BaseT(psz) {}\n\n    template &lt;typename T&gt;\n    BasicFormat &amp; operator%(const typename T &amp;val) {\n        BaseT::operator%(val);\n        return *this;\n    }\n\n    template &lt;typename IntT, typename ErrT&gt;\n    BasicFormat &amp; operator%(const typename SafeInt&lt;IntT, ErrT&gt; &amp;val) {\n        BaseT::operator%(static_cast&lt;IntT&gt;(val));\n        return *this;\n    }\n};</code></pre>\n\nStill, it somehow feels fragile and wrong...<br />\n",
    "PostedDate": "2015-01-22T03:20:22.54-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1363319",
    "ThreadId": "578321",
    "Html": "I haven't tested SafeInt with either of those. While I like the fix above, I wouldn't want to put it into the main library because I don't like to create dependencies on other headers unless I have to. I think I will document your approach as a potential fix. The other obvious fix is to just unbox it back to it's base type when calling &lt;&lt;.<br />\n",
    "PostedDate": "2015-03-13T19:25:13.187-07:00",
    "UserRole": "Coordinator",
    "MarkedAsAnswerDate": null
  }
]