[
  {
    "Id": "134581",
    "ThreadId": "40572",
    "Html": "<span id=UniqueID1227452953163>When you do an implicit conversion from <em>long</em> to <em>short</em>, the compiler will typically warn you that the conversion might be unsafe. For example (tested on MSVC 9 SP1):\r\n<p><em>  long myBuiltinLong = SHRT_MAX + 1L;<br>\r\n  short myBuiltinShort1 = myBuiltinLong; // warning: <em>possible loss of data</em>!<br>\r\n</em><br>\r\nOn the other hand, when <em>SafeInt&lt;long&gt;</em> is implicitly converted to <em>short</em>, the compiler doesn't give any warning:<br>\r\n<br>\r\n<em>    SafeInt&lt;long&gt; mySafeLong(SHRT_MAX + 1L);<br>\r\n    short myBuiltinShort2 = mySafeLong;  // No warning!<br>\r\n</em><br>\r\nThe safety net comes only at runtime. Wouldn't it be preferable to avoid implicit conversion whenever loss of data is possible.  In those cases, people could still use the SafeCast function, right?</p>\r\n<p>Clearly some conversions are guaranteed without loss of data at compile time. For example, <em>SafeInt&lt;unsigned char&gt;</em> to <em>short</em>, <em>SafeInt&lt;short&gt;</em> to <em>long</em>, and <em>SafeInt&lt;short&gt;</em> to <em>double</em>.  In those cases, I still find it very convenient to have implicit conversion, of course!</p>\r\n</span>\r\n",
    "PostedDate": "2008-11-23T07:34:08.393-08:00",
    "UserRole": "Developer",
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "134696",
    "ThreadId": "40572",
    "Html": "<p>The typical programmer will just cast away the warning, so the runtime protection is going to be a stronger approach. I think you also have the warning level turned up. I would suppose it would be nice to have the best of both worlds, perhaps have something you could put inline that would trigger the warning, but not something I'd want to see by default. The most serious problem is that GetCastMethod happens on a total of 92 lines, each of which represent a possible warning. Then there's the problem of this:<br>\r\n<br>\r\nlong a, b;<br>\r\nlong result c;<br>\r\nlong long tmp = (long long)a * (long long)b;<br>\r\nif(SafeCast(tmp, result))<br>\r\n<br>\r\nWhich is essentially what happens inside any of the 32-bit multiplication checks, and at compile time, it would appear to be a possible truncation that we'd like to warn about, but we're using it to widen our range. Another thing I prefer about the runtime protection is that if you do something like the above, you'll quickly get exceptions and those will point you to the line that's causing the trouble and you can go fix it. Better yet, the stack trace even tells you the values that made you get off the tracks.<br>\r\n<br>\r\nIt would be nice if there was some way to do some diagnostics - for example, someone did this:<br>\r\n<br>\r\nSafeInt&lt;unsigned long&gt; cch;<br>\r\n// lots of code<br>\r\n// check for cch too big (or that was the plan anyway)<br>\r\nif((int)cch &lt; 0)<br>\r\n  return E_FAIL; // doh! now not reached<br>\r\n<br>\r\nThe graceful error handling just turned into:<br>\r\nif((int)cch &lt; 0) RaiseException(...);<br>\r\n<br>\r\nOops.<br>\r\n<br>\r\nI take your point, but I don't know how to get both.</p>\r\n<p>Getting rid of the warnings can also have huge benefits in a lot of cases. For example:</p>\r\n<p>char* szIn = something;</p>\r\n<p>unsigned long cchIn = strnlen(szIn, cchMax); // cchMax easily fits in a ulong, so size_t cast is safe</p>\r\n<p>char* szTmp = strchr(szIn, <a href=\"mailto:'@'\">'@'</a>);</p>\r\n<p>if(szTmp != NULL)</p>\r\n<p>{</p>\r\n<p>   unsigned long offset = szTmp - szIn; // warning! truncation from ptrdiff_t to unsigned long</p>\r\n<p>  unsigned long offset2 = SafeInt&lt;ptrdiff_t&gt;(szTmp - szIn); // No warning, and if something gets bad and this is negative, we throw</p>\r\n<p>}</p>\r\n<p>Of course, if you really want to check at runtime, that's what the non-throwing functions are for.</p>\r\n",
    "PostedDate": "2008-11-24T00:52:16.28-08:00",
    "UserRole": "Coordinator",
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "134697",
    "ThreadId": "40572",
    "Html": "Oh, and we promote to int and check the cast all over the place, too. GetCastMethod isn't the only time we do this. We'd have a lot of false positives.\r\n",
    "PostedDate": "2008-11-24T00:54:32.287-08:00",
    "UserRole": "Coordinator",
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "135701",
    "ThreadId": "40572",
    "Html": "<p>Thank you for the SafeInt update, David!<br>\r\n<br>\r\nThanks also for your examples. I can imagine that someone who's doing <em>if((int)cch &lt; 0)</em> might be surprised to get an exception.  What's even worse IMhO, such a conversion might currently also take place implicitly, for example by passing a <em>SafeInt&lt;long&gt;</em> to a function that accepts a <em>short</em> as argument.  So a change of a function signature might unexpectedly yield exceptions! I think that that people would be less surprised if the conversion would be by an explicit function call, for example, <em>SafeCast&lt;int&gt;(cch)</em>. </p>\r\n<p>So I think it might be useful to try to have exception-throwing implicit conversions trigger a warning (preferably while keeping the warning disabled for the rest of SafeInt.hpp). But I'd find it even more interesting to just disable those implicit conversions that might cause an exception.This could be implemented by replacing your SafeInt conversion operators by a single member function template:</p>\r\n<p>    template &lt; typename U &gt;<br>\r\n    operator U() const<br>\r\n    {<br>\r\n        C_ASSERT_ConversionDoesNotNeedRuntimeCheck&lt;T,U&gt;();<br>\r\n        return m_int;<br>\r\n    }</p>\r\n<p>operator U() converts to any type, as long as the conversion doesn't need runtime checking.  <br>\r\n<br>\r\nC_ASSERT_ConversionDoesNotNeedRuntimeCheck is implemented using the type traits from TR1, which is included with the latest versions of both MSVC and GCC.  But I guess you can do the same by using SafeInt's own type traits.  I haven't yet extensively tested the class, but basically this is the idea:</p>\r\n<hr>\r\n<p>&nbsp;</p>\r\n<p>#include &lt;type_traits&gt;  // TR1<br>\r\n<br>\r\n  template &lt;typename T, typename U&gt;<br>\r\n  class C_ASSERT_ConversionDoesNotNeedRuntimeCheck<br>\r\n  {<br>\r\n    enum<br>\r\n    {<br>\r\n      fromSigned = std::tr1::is_signed&lt;T&gt;::value,<br>\r\n      fromUnsigned = std::tr1::is_integral&lt;U&gt;::value &amp;&amp;<br>\r\n        !fromSigned,<br>\r\n      toSigned = std::tr1::is_signed&lt;U&gt;::value,<br>\r\n      fromFloat = std::tr1::is_floating_point&lt;T&gt;::value,<br>\r\n      toFloat = std::tr1::is_floating_point&lt;U&gt;::value<br>\r\n    };<br>\r\n    enum<br>\r\n    {<br>\r\n      value =<br>\r\n        ( sizeof(T) &lt;= sizeof(U) &amp;&amp;<br>\r\n          fromSigned == toSigned &amp;&amp;<br>\r\n          fromFloat == toFloat ) ||<br>\r\n        ( sizeof(T) &lt; sizeof(U) &amp;&amp;<br>\r\n          (toFloat || (fromUnsigned &amp;&amp; toSigned)))<br>\r\n    };<br>\r\n    C_ASSERT(value);<br>\r\n  };</p>\r\n<hr>\r\n<p>What do you think?  Would it be feasible to only allow implicit conversion when there's no chance of exceptions?</p>\r\n",
    "PostedDate": "2008-11-26T14:26:34.007-08:00",
    "UserRole": "Developer",
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "136276",
    "ThreadId": "40572",
    "Html": "Checking implicit casts on entry to a function is a major feature. The problem with asking for a cast is that people will mess it up. That's the nice thing about SafeInt - the programmer has to make fewer decisions. For example, here's a bit of Office code:<br>\r\n<br>\r\nTK tk = SelfObfuscatingFunctionName(args);<br>\r\n<br>\r\nThis produces a warning that we're truncating an IRUL to a TK. So just what's an IRUL? And a TK is a lot of fun to try and search, since it's just 2 letters. Here's the SafeInt fix:<br>\r\n<br>\r\nTK tk = SafeInt&lt;IRUL&gt;(SelfObfuscatingFunctionName(args));<br>\r\n<br>\r\nThe IntSafe library attempts to solve integer overflows using C functions. I've seen a huge number of instances where someone passed a pair of ints to a function designed to do a checked multiplication of 2 unsigned ints.<br>\r\n<br>\r\nA big problem with your proposal is that internally, we just let the throw happen all over the place. The casting operators aren't low enough level, and there are too many places we check casts internally. If the cast fails, then some other operator is actually the problem.\r\n",
    "PostedDate": "2008-11-29T13:07:20.893-08:00",
    "UserRole": "Coordinator",
    "MarkedAsAnswerDate": null
  }
]