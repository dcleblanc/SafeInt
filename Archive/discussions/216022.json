[
  {
    "Id": "455441",
    "ThreadId": "216022",
    "Html": "<p>I recently encountered the need to check for int overflows in order to speed up the computation in an application we are developing that involves big numbers. We basically use the same trick with extending the size of the operands and checking if the result fits. It is unusual to have to do this when the processors do offer overflow flags and we can access them (although not in a nice way). Since you&nbsp;definitely&nbsp;have more experience in developing with overflows, I was wondering why you are not doing something like this</p>\r\n<p><span style=\"font-size:10pt;color:blue\">#include</span><span style=\"font-size:10pt\"> <span style=\"color:#a31515\">&lt;iostream&gt;<br></span></span><span style=\"font-size:10pt;color:blue\">#include</span><span style=\"font-size:10pt\"> <span style=\"color:#a31515\">&lt;limits&gt;</span></span><span style=\"color:#a31515\">&nbsp;</span></p>\r\n<p><span style=\"font-size:10pt;color:blue\">using</span><span style=\"font-size:10pt\"> <span style=\"color:blue\">namespace</span> std;</span></p>\r\n<p><span style=\"font-size:10pt;color:blue\">#undef</span><span style=\"font-size:10pt\"> max</span></p>\r\n<p><span style=\"font-size:10pt;color:blue\">#define</span><span style=\"font-size:10pt\"> CHECK_OVERFLOW(code, label) \\<br></span>&nbsp;&nbsp; &nbsp;code; \\<br>&nbsp;&nbsp; &nbsp;<span style=\"color:blue\">_asm</span> { jo label } \\&nbsp;</p>\r\n<p><span style=\"font-size:10pt;color:blue\">int</span><span style=\"font-size:10pt\"> main(<span style=\"color:blue\">int</span> argc, <span style=\"color:blue\">char</span>* argv[])<br></span>{<br>&nbsp;&nbsp; &nbsp;<span style=\"color:blue\">int</span> x, y = 0;<br>&nbsp;&nbsp; &nbsp;x = numeric_limits&lt;<span style=\"color:blue\">int</span>&gt;::max();<br>&nbsp;&nbsp; &nbsp;CHECK_OVERFLOW(y = x + 1, overflow_label);<br>&nbsp;&nbsp; &nbsp;CHECK_OVERFLOW(x = y + 1, overflow_label); &nbsp;&nbsp;<br>&nbsp;&nbsp; &nbsp;cout &lt;&lt; <span style=\"color:#a31515\">&quot;no overflow&quot;</span> &lt;&lt; endl;<br>&nbsp;&nbsp; &nbsp;<span style=\"color:blue\">return</span> 0;<br>overflow_label:<br>&nbsp;&nbsp; &nbsp;cout &lt;&lt; <span style=\"color:#a31515\">&quot;overflow&quot;</span> &lt;&lt; endl;<br>}</p>\r\n<p>Are there conditions where this would fail (like compiler optimizations), or is there other reasons that I'm not seeing?</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2010-06-14T17:40:30.707-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "455526",
    "ThreadId": "216022",
    "Html": "<p>Also, after some hacking, I got an equivalent in gcc</p>\r\n<p>\r\n<div style=\"color:black;background-color:white\">\r\n<pre>#include &lt;iostream&gt;\r\n#include &lt;limits&gt; \r\n\r\n<span style=\"color:blue\">using</span> <span style=\"color:blue\">namespace</span> std;\r\n\r\n<span style=\"color:blue\">int</span> main(<span style=\"color:blue\">int</span> argc, <span style=\"color:blue\">char</span>* argv[])\r\n{    \r\n    <span style=\"color:blue\">int</span> x, y;\r\n    <span style=\"color:blue\">bool</span> overflow = <span style=\"color:blue\">false</span>;\r\n    x = numeric_limits&lt;<span style=\"color:blue\">int</span>&gt;::max();\r\n    y = x + 1;\r\n    asm(<span style=\"color:#a31515\">&quot;jno no_overflow\\n&quot;</span>\r\n\t<span style=\"color:#a31515\">&quot;mov\\t$1, %0\\n&quot;</span>\r\n        <span style=\"color:#a31515\">&quot;no_overflow:\\n&quot;</span>\r\n       :<span style=\"color:#a31515\">&quot;=r&quot;</span>(overflow)\r\n       :<span style=\"color:#a31515\">&quot;r&quot;</span>(overflow) \r\n       );\r\n    <span style=\"color:blue\">if</span> (overflow) cout &lt;&lt; <span style=\"color:#a31515\">&quot;overflow&quot;</span> &lt;&lt; endl;\r\n    <span style=\"color:blue\">else</span> cout &lt;&lt; <span style=\"color:#a31515\">&quot;no overflow&quot;</span> &lt;&lt; endl;\r\n    <span style=\"color:blue\">return</span> 0;\r\n}\r\n</pre>\r\n</div>\r\nCheers, Dejan</p>",
    "PostedDate": "2010-06-15T01:02:38-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "455730",
    "ThreadId": "216022",
    "Html": "<p>The problem is two-fold. First, the overflow flag doesn't get set for everything. For example, assigning a 32-bit int to a 16-bit int is dangerous, but the CPU doesn't see an overflow. Adding two 16-bit ints won't set the overflow flag, either. There's a bunch of cases that don't set the overflow flag. I haven't checked, but I suspect that you could well run into the same thing on a 64-bit CPU where a 32-bit multiplication doesn't set the overflow flag, though it might because of different assembly instructions.</p>\r\n<p>The second part of the problem is that as soon as you start using assembly, the compiler decides that you must know what you're doing and disables optimizations. Michael Howard and I tried a test case with multiplication, and the inline assembly came in as _much_ slower than optimized SafeInt.</p>\r\n<p>We've recently been dinking with what produces the best assembly for a test case like uint32 * uint32, and it is all around upcasting to 64-bit, and then you get some very different numbers of branches depending on how you detect an overflow. If you _really_ want to get hard core about perf, what I'd suggest would be to take the approach I use in SafeInt for the specific operation you want, and then manipulate the logic until the optimizer gives you something you like.</p>",
    "PostedDate": "2010-06-15T10:08:03.72-07:00",
    "UserRole": "Coordinator",
    "MarkedAsAnswerDate": null
  }
]