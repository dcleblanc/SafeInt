[
  {
    "Id": "203818",
    "ThreadId": "60193",
    "Html": "<p>Hi David,</p>\r\n<p>There's another discussion on SafeInt at the Boost developer's mailing list, started earlier today: <a href=\"http://thread.gmane.org/gmane.comp.lib.boost.devel/191010\">[boost] SafeInt code proposal</a>.&nbsp;A guy named Omer Katz proposed to add a utility to the Boost libraries that looks very much like your SafeInt! (But yours is superior, definitely.) Actually I'm surprised he doesn't give you some credits. (But&nbsp;maybe he&rsquo;s just reinventing the wheel.) Anyway, I do think that it would be useful to have your SafeInt as a Boost library. It would very much help to increase its number of users. Boost has a very dedicated group of volunteering developers, which could review the class and possibly suggest further improvements. Furthermore, as a Boost library it would be tested automatically for many platforms: <a href=\"http://www.boost.org/development/tests/trunk/developer/\">www.boost.org/development/tests/trunk/developer/</a></p>\r\n<p>Of course, it would need some &ldquo;restyling&rdquo; in order to make it have&nbsp;a Boost look-and-feel. For instance, I guess it would need to be renamed, e.g., boost::safe_int. But it would still be <em>your</em> library, you&rsquo;d still have the copyrights.</p>\r\n<p>What do you think? I&rsquo;m certainly willing to help you, to see if we can get your library into Boost.</p>\r\n<p>Note that&nbsp;Boost users have&nbsp;been asking for&nbsp;a Boost version of SafeInt before:&nbsp;&nbsp;<a href=\"http://lists.boost.org/boost-users/2006/10/23187.php\">[Boost-users] Portable SafeInt?</a></p>",
    "PostedDate": "2009-06-21T05:51:07.76-07:00",
    "UserRole": "Developer",
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "203854",
    "ThreadId": "60193",
    "Html": "<p>Hi,</p>\r\n<p>As I wrote on the Boost mailing list earlier, I had no idea such library was previously created by David and distributed freely.</p>\r\n<p>We (my partner and I) first heard of David's library yesterday when it was mentioned in the replies to our proposal.</p>\r\n<p>Indeed, his library is currently more advanced than ours. If David chooses to port his code into Boost, we will be more than happy to help.</p>",
    "PostedDate": "2009-06-21T11:11:11.347-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "203877",
    "ThreadId": "60193",
    "Html": "<p>Hi Omer,</p>\r\n<p>Thanks for your reply. I'm sorry I hadn't&nbsp;read&nbsp;the mail you posted last month,&nbsp;<a href=\"http://lists.boost.org/Archives/boost/2009/05/151441.php\">[boost] SafeInt library for Boost</a>, otherwise I would have told you about David's library before. It might have saved you a lot of time! BTW, I do&nbsp;also reinvent the wheel from time to time, so that's no problem.&nbsp; :-)</p>\r\n<p>Kind regards, Niels</p>",
    "PostedDate": "2009-06-21T14:43:46.77-07:00",
    "UserRole": "Developer",
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "204607",
    "ThreadId": "60193",
    "Html": "<p>I'd like to have some more information before commenting extensively. First, why should we do the work? I am not sure why someone couldn't just use the library as is - what benefit is there to the users by having it in Boost? I am not making the argument there is none - I am just asking because I don't know.</p>\r\n<p>Next, what is involved in a port? I'd like to understand what is needed. I'm also wanting to try to keep the number of supported versions to 2 - this version, and the Visual Studio version. If I were to port it to Boost, I'd want to make that the only non-MS version.</p>\r\n<p>Finally, the biggest issue for me is that I'd have to get the Microsoft legal department to look into any licensing issues. The license I have on it now is what they like to use, and as a lay person, it seems to allow what I want, which is anyone can use it, derive from it, and they aren't encumbered by any sort of onerous requirements. I do not know how boost does licensing - perhaps this is OK, perhaps they can handle the license that is on it now, but if Boost cannot deal with the license that is on it now, then I'd have to get legal review on any new license. This is all possible - I just have to ask for some meetings, start some mail threads, etc. It will take at least a&nbsp;few hours of work, and the simplest thing for me is to keep the existing license. It could possibly turn into a large hassle. If there is some conflict between the Boost license and the MS license, I'd be interested to know what that is.</p>\r\n<p>If you'd like to take this to off-line e-mail, that's fine -</p>",
    "PostedDate": "2009-06-23T11:00:18.763-07:00",
    "UserRole": "Coordinator",
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "280123",
    "ThreadId": "60193",
    "Html": "<p>Hi David,</p>\r\n<p>I personally would love to see (any) SafeInt library included in boost, if this SafeInt library included in boost was yours I imagine it would save a great many people quite a bit of time (in terms of rewriting what your SafeInt implementation already does). I believe the issue is one of trust and perspective. I'm sure you're aware of how a great many open source advocates (and zealots among them) feel about Microsoft. While I can appreciate that you believe the MS-PL allows exactly what you want (and I can't argue, I can't speak legalese either), a lot of folks simply trust licenses that are provided by people or groups that have no monetary interest in their code a lot more. Was it you who, without oversight, chose to open-source this code or did Microsoft allow your request to open-source it? I might also point out that the mere fact that you would need to ask Microsoft's legal department about licensing issues with your own now-open-sourced code is a rather large red flag. Reading and rereading the first sentence of your third paragraph only made me question who owned the code. At least in theory (as I currently understand it from what I've read) that's you but the copyright notice on line 45 of version 3.0.12p says otherwise.</p>\r\n<p>I do hope you'll consider proposing your SafeInt implementation to boost (and using boosts' license).</p>\r\n<p>Geoff</p>\r\n<p>P.S. Imagine the good publicity for yourself and Microsoft if this happened, not to mention the increase in eyeballs!</p>",
    "PostedDate": "2010-01-21T09:42:54.713-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "280300",
    "ThreadId": "60193",
    "Html": "<p>I'd like to get it included in Boost myself. I've been really, really busy the last year - we're getting close to shipping Office 2010, so I've been working a lot. I think you can certainly use this with Boost code right now.</p>\r\n<p>As to the license, let me clear up a few things - first of all, <strong><em>I Am Not A Lawyer</em></strong>. If you are using ANYTHING from the Internet, especially in a commercial product, you ought to get legal advice from a lawyer about what it means. Some licenses have some interesting restrictions, others have very mild restrictions. With that caveat, let me give you my interpretation of the license:</p>\r\n<p>2. Grant of Rights</p>\r\n<p>(A) Copyright Grant- Subject to the terms of this license, including the license conditions and limitations in section 3, each contributor grants you a non-exclusive, worldwide, royalty-free copyright license to reproduce its contribution, prepare derivative works of its contribution, and distribute its contribution or any derivative works that you create.</p>\r\n<p>This means that you can use SafeInt, you can modify SafeInt, and you can distribute the results, whether that's your SafeInt or product that uses SafeInt. That's a very broad grant of license. You don't need to worry about us changing it - when we posted it in public with that license, that's what we gave you. And we agree (royalty-free) not to charge you if you do.</p>\r\n<p>(B) Patent Grant- Subject to the terms of this license, including the license conditions and limitations in section 3, each contributor grants you a non-exclusive, worldwide, royalty-free license under its licensed patents to make, have made, use, sell, offer for sale, import, and/or otherwise dispose of its contribution in the software or derivative works of the contribution in the software.</p>\r\n<p>If we had a patent on this (and we do not), then you'd have a license to use this work. Since we don't have a patent on SafeInt, this doesn't apply.</p>\r\n<p>Now for the conditions:</p>\r\n<p>A) This doesn't mean you get to use our trademarks - should be self-explanatory, and not a factor for most people.</p>\r\n<p>B) Only applies to something patented, so doesn't matter here.</p>\r\n<p>C) If you choose to redistribute my code, you can't say you wrote it.</p>\r\n<p>D) If you redistribute this code in source form, the license has to stay with it.</p>\r\n<p>E) We're not claiming the code is perfect. Use it at your own risk.</p>\r\n<p>Don't trust licenses based on who they're from. Trust licenses based on _your_ lawyer's opinion of them. I've spent a lot of time learning about intellectual property issues, and am good at it for a non-lawyer, but if I have questions, I get a lawyer. I haven't looked at the Boost license in depth lately, but IIRC, the MS-PL license is _less_ restrictive, though the Boost license is one of the better ones. BTW, the various GPL versions can vary significantly in what they mean, so be careful with those.</p>\r\n<p>We have no direct monetary interest in this code - we're not charging you to download it. We put it out here for free because we want the Internet to be a more secure place, and that's not just my position, but it is the Microsoft corporate position as well.</p>\r\n<p>In the sense that I wrote it, this is my code. In the sense that Microsoft was paying me to write the code, it is really the property of Microsoft. I'm just the author. In order to post this code, which is very, very close to the exact same code as we compile into Office, Windows, and a bunch of other projects, I had to get VP level approval. If I want to post code that we don't ship, then that's much less restricted - see the offcrypto project for an example, the test harness and gcc header for this one would be other examples. Only makes sense - I wanted to make something public that is Microsoft's property, and we invested a _lot_ of time in getting it to production quality, testing, etc. If we're going to put that out there for free, I need to make sure it's OK with someone who has authority to allow it. If I'd posted production code to the Internet without being allowed to, that's not only ethically wrong, but it would likely get me fired. Because we want all of our customers, and even people who might not be customers, to be more secure, we distributed this in open source form.</p>\r\n<p>I think you're misunderstanding my need to discuss this with our legal department. The problem is that we own the code, we have our MS-PL license on it, and if it goes out in a Boost library, it would then have a Boost license on it. These licenses aren't exactly the same. Maybe they can co-exist and both can be on it - not sure.&nbsp;Since I don't personally _own_ the code, I can't just swap one for the other. Now we have a legal decision to make, and the right way to solve that is to go talk to a lawyer about it. We have plenty of lawyers who will help me with this, I just have to find time. Doesn't mean we can't, but I do have to go sort out what it means. While I think the difference between the Boost license and MS-PL are minimal, something to look out for is that some licenses are contradictory - if you include the wrong combination of OSS software, you can get into a state where you can't meet the requirements of one without invalidating one of the other requirements.</p>\r\n<p>Good publicity is always nice, but if you search on 'David LeBlanc security', you get over 500,000 hits, so I think I've had my 15 minutes of fame and then some. I'm not motivated by publicity for myself. I am motivated to help make people's apps be more secure - that's what matters, not my ego. In terms of positive Microsoft PR, yes, that's also nice, but not the driving factor. The important thing is to make people secure, and getting this into a more well-known library and possibly even into the standard library would help do that.</p>\r\n<p>BTW, a Microsoft-specific version of SafeInt is shipping in Visual Studio 10. If someone reading this is programming only for the Windows platform, you should switch to that one when you upgrade libraries and the compiler. If your code is cross-platform, or you're on an earlier version of the compiler, stick with this one -&nbsp;I will keep maintaining it.</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2010-01-21T15:51:52.813-08:00",
    "UserRole": "Coordinator",
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "588476",
    "ThreadId": "60193",
    "Html": "<p>Hi</p>\r\n<p>I just would like to say that having SafeInt in boost would be very much appreciated. The C++ community would be grateful.</p>\r\n<p>Many a companies have defacto &nbsp;rules like \"no 3rd party libraries allowed except boost\". People trust the boost libraries just because the name is so well known and respected, even if they are a bit buggy sometimes.</p>\r\n<p>Also it would be good PR for MS.&nbsp;</p>\r\n<p>Just my 2 cents.</p>",
    "PostedDate": "2011-03-29T14:27:34.403-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "588500",
    "ThreadId": "60193",
    "Html": "<p>Thanks for reminding me - I think you could probably get an exception for this one, as you're almost certainly allowed to use libraries from Visual Studio, and this version is very, very close to the same thing as in Visual Studio. I do need to go have the discussion with legal people to see how this could work.</p>\r\n<p>My focus just this moment is to get 3.0.16 up - I'm trying to get the warnings down, and get it to work right with the older compiler Apple likes to use.</p>",
    "PostedDate": "2011-03-29T15:31:18.38-07:00",
    "UserRole": "Coordinator",
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "654353",
    "ThreadId": "60193",
    "Html": "<p>Boost has really smart people in its community, and sets ultra-high standards.&nbsp; Libraries are peer-reviewed too, so you'd get a lot of good feedback on your code.&nbsp; For example, I grabbed the latest SafeInt3.hpp, opened it up,&nbsp;and immediately saw this:</p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre>#<span style=\"color: blue;\">if</span> !defined NULL\r\n#define NULL ((<span style=\"color: blue;\">void</span>*)0)\r\n#endif\r\n</pre>\r\n</div>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre><span style=\"color: green;\">// These two may not be defined, either</span>\r\n#<span style=\"color: blue;\">if</span> !defined uintptr_t\r\n#define uintptr_t size_t\r\n#endif\r\n\r\n#<span style=\"color: blue;\">if</span> !defined intptr_t\r\n#define intptr_t ptrdiff_t\r\n#endif\r\n</pre>\r\n</div>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre><span style=\"color: green;\">// Might need this for gcc and older Microsoft compilers</span>\r\n#<span style=\"color: blue;\">if</span> !defined <span style=\"color: blue;\">nullptr</span>\r\n#define <span style=\"color: blue;\">nullptr</span> NULL\r\n#endif\r\n</pre>\r\n</div>\r\n<p>Code like that is evil.&nbsp; The folks at Boost would surely&nbsp;let you know about it, and you'll learn modern C++ programming paradigms, improving the quality of your code.</p>\r\n<p>I hope you can get the legal stuff out of the way.&nbsp; Good luck!</p>",
    "PostedDate": "2011-08-08T01:41:01.933-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "654688",
    "ThreadId": "60193",
    "Html": "<p>Could you perhaps explain how these are evil?</p>\r\n<p>If this is really wrong, then there's a number of standard libraries that have bugs. There's 10 different headers in the Microsoft headers that have NULL defined, which is needed because it isn't defined as part of the language. A compiler and platform-independent library such as this one has to define anything that isn't part of the language standard, or it has to include standard headers that will.</p>\r\n<p>Then uintptr_t and intptr_t are part of the language, but some versions of gcc that are supported by this class don't seem to know that these are keywords, and want them defined. If you have them defined, then these conditional definitions don't matter. Finally, nullptr is part of the newest edition of the standard, and this class is still supported on a number of compilers that are several years old, and you need that either defined as a keyword, or it needs a #define.</p>\r\n<p>Thanks for your interest, and I'm happy to know that Boost could teach me more about modern C++ programming.</p>\r\n<p><span style=\"font-family: Consolas; color: #0000ff; font-size: x-small;\"><span style=\"font-family: Consolas; color: #0000ff; font-size: x-small;\"><span style=\"font-family: Consolas; color: #0000ff; font-size: x-small;\"></span></span></span></p>\r\n&nbsp;",
    "PostedDate": "2011-08-08T10:22:03.19-07:00",
    "UserRole": "Coordinator",
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "654882",
    "ThreadId": "60193",
    "Html": "<p>Thanks for listening!&nbsp; Of course, I'll explain.</p>\r\n<p>The standard library is a special kind of library.&nbsp; It's allowed to declare identifiers&nbsp;that are <em>reserved.</em>&nbsp; This includes:</p>\r\n<ul>\r\n<li>Names in the global&nbsp;scope&nbsp;that begin with an underscore</li>\r\n<li>Names anywhere&nbsp;that contain two consecutive underscores</li>\r\n<li>Names anywhere&nbsp;that begin with an underscore and a capital letter</li>\r\n</ul>\r\n<p>That's why you see a lot of underscore usage in standard library headers.&nbsp; This makes sure that the library's internal identifiers don't clash with everyone else's.&nbsp; For this to work, though,&nbsp;everyone else&nbsp;must also not declare reserved identifiers.&nbsp; So the standard libraries get to use names like <span style=\"font-family: Consolas; font-size: x-small;\"><span style=\"font-family: Consolas; font-size: x-small;\">__foo</span></span>, <span style=\"font-family: Consolas; font-size: x-small;\"><span style=\"font-family: Consolas; font-size: x-small;\">_Foo</span></span>, and <span style=\"font-family: Consolas; font-size: x-small;\"><span style=\"font-family: Consolas; font-size: x-small;\">foo__</span></span>, while everything else gets to use names like <span style=\"font-family: Consolas; font-size: x-small;\"><span style=\"font-family: Consolas; font-size: x-small;\">foo</span></span>, <span style=\"font-family: Consolas; font-size: x-small;\"><span style=\"font-family: Consolas; font-size: x-small;\">Foo</span></span>, and <span style=\"font-family: Consolas; font-size: x-small;\"><span style=\"font-family: Consolas; font-size: x-small;\">foo_</span></span>.</p>\r\n<p>Where does that place non-standard libraries?&nbsp; The Boost convention is to&nbsp;use namespaces.&nbsp; Just as the standard library puts everything into <span style=\"font-family: Consolas; color: #0000ff; font-size: x-small;\"><span style=\"font-family: Consolas; color: #0000ff; font-size: x-small;\"><span style=\"font-family: Consolas; color: #0000ff; font-size: x-small;\"><span style=\"font-family: Consolas; color: #0000ff; font-size: x-small;\">namespace</span></span></span>&nbsp;</span><span style=\"font-family: Consolas; font-size: x-small;\"><span style=\"font-family: Consolas; font-size: x-small;\">std</span></span>, Boost puts everything under&nbsp;<span style=\"font-family: Consolas; color: #0000ff; font-size: x-small;\"><span style=\"font-family: Consolas; color: #0000ff; font-size: x-small;\"><span style=\"font-family: Consolas; color: #0000ff; font-size: x-small;\"><span style=\"font-family: Consolas; color: #0000ff; font-size: x-small;\">namespace</span></span></span>&nbsp;</span><span style=\"font-family: Consolas; font-size: x-small;\"><span style=\"font-family: Consolas; font-size: x-small;\">boost</span></span>.&nbsp; Macros ignore namespaces, so Boost capitalizes all macros&nbsp;and&nbsp;prefixes them with the name of the library&nbsp;(e.g. <span style=\"font-family: Consolas; font-size: x-small;\"><span style=\"font-family: Consolas; font-size: x-small;\">BOOST_UNREACHABLE_RETURN</span></span>).&nbsp; The rationale for that&nbsp;is the same as for namespaces, which I'll get to in a minute.</p>\r\n<p>In the first piece of code, you define <span style=\"font-family: Consolas; font-size: x-small;\"><span style=\"font-family: Consolas; font-size: x-small;\">NULL</span></span> as <span style=\"font-family: Consolas; font-size: x-small;\"><span style=\"font-family: Consolas; font-size: x-small;\"><span style=\"font-family: Consolas; font-size: x-small;\">((</span></span></span><span style=\"font-family: Consolas; color: #0000ff; font-size: x-small;\"><span style=\"font-family: Consolas; color: #0000ff; font-size: x-small;\"><span style=\"font-family: Consolas; color: #0000ff; font-size: x-small;\">void</span></span></span><span style=\"font-family: Consolas; font-size: x-small;\"><span style=\"font-family: Consolas; font-size: x-small;\">*)0)</span></span>.&nbsp; There are two problems with this.</p>\r\n<ul>\r\n<li>The user now cannot write&nbsp;<span style=\"font-family: Consolas; color: #0000ff; font-size: x-small;\"><span style=\"font-family: Consolas; color: #0000ff; font-size: x-small;\"><span style=\"font-family: Consolas; color: #0000ff; font-size: x-small;\"><span style=\"font-family: Consolas; color: #0000ff; font-size: x-small;\">char </span></span></span></span><span style=\"font-family: Consolas; font-size: x-small;\"><span style=\"font-family: Consolas; font-size: x-small;\">*p = malloc(n);</span></span> because&nbsp;<span style=\"font-family: Consolas; color: #0000ff; font-size: x-small;\"><span style=\"font-family: Consolas; color: #0000ff; font-size: x-small;\"><span style=\"font-family: Consolas; color: #0000ff; font-size: x-small;\">void </span></span></span><span style=\"font-family: Consolas; font-size: x-small;\"><span style=\"font-family: Consolas; font-size: x-small;\">*</span></span> is not implicitly convertible to <span style=\"font-family: Consolas; color: #0000ff; font-size: x-small;\"><span style=\"font-family: Consolas; color: #0000ff; font-size: x-small;\"><span style=\"font-family: Consolas; color: #0000ff; font-size: x-small;\"><span style=\"font-family: Consolas; color: #0000ff; font-size: x-small;\">char </span></span></span></span><span style=\"font-family: Consolas; font-size: x-small;\"><span style=\"font-family: Consolas; font-size: x-small;\">*</span></span>.</li>\r\n<li>GCC has a special definition for&nbsp;<span style=\"font-family: Consolas; font-size: x-small;\"><span style=\"font-family: Consolas; font-size: x-small;\">NULL</span></span>&nbsp;that allows the implicit conversion but gives a warning whenever one tries to&nbsp;convert it to a non-pointer type.</li>\r\n</ul>\r\n<p>A conforming standard library implementation will define&nbsp;<span style=\"font-family: Consolas; font-size: x-small;\"><span style=\"font-family: Consolas; font-size: x-small;\">NULL</span></span> when the&nbsp;header <span style=\"font-family: Consolas; color: #a31515; font-size: x-small;\"><span style=\"font-family: Consolas; color: #a31515; font-size: x-small;\"><span style=\"font-family: Consolas; color: #a31515; font-size: x-small;\">&lt;cstddef&gt;</span></span></span> is included.&nbsp; It's required by ISO C++.&nbsp; Every sane implementation has it.</p>\r\n<p>In the second example, you check for and define&nbsp;<span style=\"font-family: Consolas; font-size: x-small;\"><span style=\"font-family: Consolas; font-size: x-small;\">intptr_t</span></span> and&nbsp;<span style=\"font-family: Consolas; font-size: x-small;\"><span style=\"font-family: Consolas; font-size: x-small;\">uintptr_t</span></span>.&nbsp; This&nbsp;is flawed&nbsp;because those two names are typedefs according to the language.&nbsp; You can't check for them using the preprocessor.&nbsp; Also, consider what could happen&nbsp;when GCC does define the names.&nbsp; Your header would change the meaning of&nbsp;<span style=\"font-family: Consolas; font-size: x-small;\"><span style=\"font-family: Consolas; font-size: x-small;\">intptr_t</span></span> and <span style=\"font-family: Consolas; font-size: x-small;\"><span style=\"font-family: Consolas; font-size: x-small;\">uintptr_t</span></span>.&nbsp; If you're lucky, the two definitions&nbsp;will agree;&nbsp;<span style=\"font-family: Consolas; color: #a31515; font-size: x-small;\"><span style=\"font-family: Consolas; color: #a31515; font-size: x-small;\"><span style=\"font-family: Consolas; color: #a31515; font-size: x-small;\">&lt;cstdint&gt;</span></span></span> would say&nbsp;<span style=\"font-family: Consolas; color: #0000ff; font-size: x-small;\"><span style=\"font-family: Consolas; color: #0000ff; font-size: x-small;\"><span style=\"font-family: Consolas; color: #0000ff; font-size: x-small;\"><span style=\"font-family: Consolas; color: #0000ff; font-size: x-small;\">typedef</span></span></span>&nbsp;</span><span style=\"font-family: Consolas; font-size: x-small;\"><span style=\"font-family: Consolas; font-size: x-small;\">ptrdiff_t intptr_t; </span></span><span style=\"font-family: Consolas; color: #0000ff; font-size: x-small;\"><span style=\"font-family: Consolas; color: #0000ff; font-size: x-small;\"><span style=\"font-family: Consolas; color: #0000ff; font-size: x-small;\">typedef</span></span></span><span style=\"font-family: Consolas; font-size: x-small;\"> <span style=\"font-family: Consolas; font-size: x-small;\">size_t uintptr_t;</span></span>.&nbsp; However, if the library uses some other types, bad things&nbsp;could happen.&nbsp; Code that uses&nbsp;<span style=\"font-family: Consolas; font-size: x-small;\"><span style=\"font-family: Consolas; font-size: x-small;\">intptr_t</span></span> and <span style=\"font-family: Consolas; font-size: x-small;\"><span style=\"font-family: Consolas; font-size: x-small;\">uintptr_t</span></span> would&nbsp;then change simply because they included your header.</p>\r\n<p>Macros are generally&nbsp;avoided in modern C++.&nbsp;&nbsp;&nbsp;They replace all occurrences of the name regardless of where they are.&nbsp; For example, the following code...</p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre><span style=\"color: blue;\">namespace</span> boots\r\n{\r\n\t<span style=\"color: blue;\">typedef</span> std::intptr_t intptr_t;\r\n}\r\n</pre>\r\n</div>\r\n<p>...will be preprocessed into...</p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre><span style=\"color: blue;\">namespace</span> boots\r\n{\r\n\t<span style=\"color: blue;\">typedef</span> std::ptrdiff_t ptrdiff_t;\r\n}\r\n</pre>\r\n</div>\r\n<p>It's like doing a find-and-replace-all in your code, the standard library's code, and everyone else's code.&nbsp; Macros are evil.&nbsp; If there's no way to do what you want without macros,&nbsp;then use them, but follow the naming convention so that users won't unknowingly have their code changed.&nbsp; Likewise, don't&nbsp;declare identifiers that are in all capital letters that aren't prefixed by your library name, so that the <em>user's</em> macros won't change <em>your</em> code.</p>\r\n<p>In the last piece of code, you check for and define <span style=\"font-family: Consolas; color: #0000ff; font-size: x-small;\"><span style=\"font-family: Consolas; color: #0000ff; font-size: x-small;\"><span style=\"font-family: Consolas; color: #0000ff; font-size: x-small;\">nullptr</span></span></span>.&nbsp; <span style=\"font-family: Consolas; color: #0000ff; font-size: x-small;\"><span style=\"font-family: Consolas; color: #0000ff; font-size: x-small;\"><span style=\"font-family: Consolas; color: #0000ff; font-size: x-small;\">nullptr</span></span></span> is not a macro.&nbsp; It's a keyword, and, like typedefs,&nbsp;you can't check for&nbsp;keywords during preprocessing.</p>\r\n<p>Generally, if a feature isn't available in a particular C++ implementation that you need to support, don't use it.&nbsp;&nbsp;In place&nbsp;of <span style=\"font-family: Consolas; color: #0000ff; font-size: x-small;\"><span style=\"font-family: Consolas; color: #0000ff; font-size: x-small;\"><span style=\"font-family: Consolas; color: #0000ff; font-size: x-small;\">nullptr</span></span></span>, you can use <span style=\"font-family: Consolas; font-size: x-small;\"><span style=\"font-family: Consolas; font-size: x-small;\">NULL</span></span>.&nbsp; If there's no replacement, like with <span style=\"font-family: Consolas; font-size: x-small;\"><span style=\"font-family: Consolas; font-size: x-small;\">intptr_t</span></span>, then use your own definitions, but put them in your own namespace (or prefix their names if they're macros).&nbsp; Namespaces prevent conflicts with user code and other libraries.&nbsp; You shouldn't define&nbsp;anything&nbsp;outside of your namespace unless you're absolutely certain that the definition is, and will be, unique.&nbsp; Remember:&nbsp;<a title=\"One Definition Rule - Wikipedia, the free encyclopedia\" href=\"http://en.wikipedia.org/wiki/One_Definition_Rule\">In any translation unit, a template, type, function, or object can have no more than one definition.</a>&nbsp; Imagine every library defining&nbsp;the <span style=\"font-family: Consolas; font-size: x-small;\"><span style=\"font-family: Consolas; font-size: x-small;\">std::vector</span></span>!</p>\r\n<p>To reiterate,</p>\r\n<ul>\r\n<li>Standard libraries use names like <span style=\"font-family: Consolas; font-size: x-small;\"><span style=\"font-family: Consolas; font-size: x-small;\">__foo</span></span>, <span style=\"font-family: Consolas; font-size: x-small;\"><span style=\"font-family: Consolas; font-size: x-small;\">_Foo</span></span>, <span style=\"font-family: Consolas; font-size: x-small;\"><span style=\"font-family: Consolas; font-size: x-small;\">foo__</span></span>, and <span style=\"font-family: Consolas; font-size: x-small;\"><span style=\"font-family: Consolas; font-size: x-small;\">_FOO</span></span>.</li>\r\n<li>Non-standard libraries use names like <span style=\"font-family: Consolas; font-size: x-small;\"><span style=\"font-family: Consolas; font-size: x-small;\">boots::foo</span></span>, <span style=\"font-family: Consolas; font-size: x-small;\"><span style=\"font-family: Consolas; font-size: x-small;\">boots::Foo</span></span>, <span style=\"font-family: Consolas; font-size: x-small;\"><span style=\"font-family: Consolas; font-size: x-small;\">boots::foo_</span></span>, and <span style=\"font-family: Consolas; font-size: x-small;\"><span style=\"font-family: Consolas; font-size: x-small;\">BOOTS_FOO</span></span>.</li>\r\n<li>Users use names like <span style=\"font-family: Consolas; font-size: x-small;\"><span style=\"font-family: Consolas; font-size: x-small;\">foo</span></span>, <span style=\"font-family: Consolas; font-size: x-small;\"><span style=\"font-family: Consolas; font-size: x-small;\">Foo</span></span>, <span style=\"font-family: Consolas; font-size: x-small;\"><span style=\"font-family: Consolas; font-size: x-small;\">foo_</span></span>, and <span style=\"font-family: Consolas; font-size: x-small;\"><span style=\"font-family: Consolas; font-size: x-small;\">FOO</span></span>.</li>\r\n</ul>\r\n<p>Thanks for taking the time to read this.&nbsp; I'm a passionate C++ programmer who loves using libraries to ease my work.&nbsp; But it's frustrating to see libraries trample over each other.&nbsp; And it's impossible for me to review all the library code&nbsp;by myself.&nbsp; You might know Stephan T. Lavavej--he's&nbsp;a developer of the Visual C++ standard library implementation.&nbsp; He's really good with words.&nbsp; Maybe he could give you some tips.</p>",
    "PostedDate": "2011-08-08T17:26:44.853-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "654912",
    "ThreadId": "60193",
    "Html": "<p>OK, well, first of all, you can't do:</p>\r\n<p>char* c = malloc(1);</p>\r\n<p>to start with - it emits this:</p>\r\n<p>zz.cpp(5) : error C2440: 'initializing' : cannot convert from 'void *' to 'char*'<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Conversion from 'void*' to pointer to non-'void' requires an explicit cast</p>\r\n<p>That's completely independent of whether someone has defined NULL.</p>\r\n<p>Next, gcc is doing something a little non-standard, by treating NULL the same as nullptr, which is why nullptr exists. That's fine, and the expectation is that the user has almost certainly already defined NULL, so anything I do in this class won't matter. You see the same definition all over many other headers. Note that I don't bother to make it conditional on C++, since this class obviously isn't compiling on a C file.</p>\r\n<p>Next, as it turns out, I don't need intptr_t, and the instances of uintptr_t can be replaced with size_t. Regardless, uintptr_t and size_t, and the corresponding signed values are guaranteed to have the same size and behavior. Replacing one for the other won't cause any harm, even if it is regrettable. I am well aware of the evils of macros, and have largely tried to avoid them any time possible. I'm also well aware of how to use namespaces, and you may note that these are used internally to the class. At the moment, this version of the class isn't part of an external set of libraries, and thus it would be inappropriate (and clumsy) to add namespaces. There are namespaces defined in the Visual Studio version, which I also maintain.</p>\r\n<p>I also don't think I've named anything with __, except to follow what Visual Studio has done with __int8, __int16, etc. While that may not be something you're happy with, I can count on these being present in my primary target compiler. That one is a \"won't fix\".</p>\r\n<p>Yes, I do know Stephan. He's certainly a very smart guy, though I did report some integer-related bugs in his STL allocator code.</p>\r\n<p>While we're giving tips, you're more than welcome to report bugs. I'll certainly fix the uintptr_t and intptr_t issues - it was a surprise that my Linux system wouldn't compile when these types were used, and you're right that the defines aren't working as expected. However, please do not use words like 'evil', and it is especially silly to lecture me on modern C++ techniques when you're looking at a class that uses partial template specialization extensively. I'm clearly acquainted with modern programming techniques.</p>\r\n<p>Here's what I would have preferred to see:</p>\r\n<p>Issue - uintptr_t and intptr_t shouldn't be defined. intptr_t isn't used, and size_t would work just as well where uintptr_t is used.</p>\r\n<p>You're also looking at nearly 7000 LOC that have evolved over the last 8 years. It would be a miracle if everything were perfect.</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2011-08-08T19:55:38.74-07:00",
    "UserRole": "Coordinator",
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "654915",
    "ThreadId": "60193",
    "Html": "<p>I'm sorry, I made a mistake in that example.&nbsp; I meant <span style=\"font-family: Consolas; color: #0000ff; font-size: x-small;\"><span style=\"font-family: Consolas; color: #0000ff; font-size: x-small;\"><span style=\"font-family: Consolas; color: #0000ff; font-size: x-small;\"><span style=\"font-family: Consolas; color: #0000ff; font-size: x-small;\">char</span></span></span>&nbsp;</span><span style=\"font-family: Consolas; font-size: x-small;\"><span style=\"font-family: Consolas; font-size: x-small;\">*p = NULL;</span></span>.&nbsp; Can't believe I missed that after proofreading it dozens of times. &nbsp;:-(</p>\r\n<p>I'm sorry if I came off harsh.&nbsp; That was certainly not my intent.&nbsp; I used the word 'evil' because Stephan uses it to describe such things, and&nbsp;I put a lot of effort into the examples because I saw some questionable code and wanted to show you exactly my sentiments.&nbsp; I respect you and your work.&nbsp; Please don't take it personally.&nbsp; I'll shorten my explanations from now on.</p>\r\n<p>Congratulations on keeping this project going for so long!&nbsp; I saw your demo of SafeInt on Channel 9 and came here to check out the library.&nbsp; I'm very grateful that there's such a mature checked-integer library available for free.</p>",
    "PostedDate": "2011-08-08T20:31:19.313-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "655365",
    "ThreadId": "60193",
    "Html": "<p>That's an interesting issue with the NULL declaration - oops - my bad. I was surprised that my gcc environment didn't have it defined, and then I got the two forms of the definition flipped.</p>\r\n<p>Stephan and I have gotten into some debates, largely because he works only on a library, where I write features, and work on a wide array of code - some is high level C++, some is C written like you might have seen 20 years ago. He tends more towards what's theoretically correct, and I tend more toward the practical. For example, it is his position that we should never&nbsp;allocate an array of bytes, but always use&nbsp; a std::vector. He's right that the vector is safer, but go try to take apart a TCP/IP header using a vector - wouldn't be fun. Might be possible, but I'm not sure whether anyone coming after could figure out what it was doing. That said, I do use std::vector for many cases where I need an allocated array - an iterator (at least a current implementation) and the [] operator will crash rather than create an exploit. It's also a matter of absolutes - it isn't that we should _never_ call new[], it is that we should prefer std::vector.</p>\r\n<p>Same sort of thing with macros - there are things you can only do with macros. I don't like them, try not to use them, and often rip them out and turn them into inline functions, but they're not evil - just a dangerous tool (just like the rest of the language).</p>\r\n<p>The issues you pointed out were good ones - changes made as a result:</p>\r\n<p>NULL (if needed) is defined as 0<br />nullptr is only defined if you define NEEDS_NULLPTR_DEFINED 1<br />intptr_t define is removed<br />uintptr_t instances changed to size_t, define is removed</p>\r\n<p>An intentional design decision was to reduce the number of headers required by this class to the least possible. A side-effect is that depending on the environment, you don't always see everything defined that you expect.</p>\r\n<p>Issues I'm not going to address at the moment -</p>\r\n<p>The __int8, __int16, etc, are artifacts because the library was originally written for Visual Studio, and I can use them there without including any headers. They're nicely descriptive, which is handy in a world where 'long' has different meanings on different compilers and architectures. So that might be a technical violation of the language, but you can blame the Visual Studio team - I'm just following them. I could go rename them all, but it would make getting a diff between versions a major pain. So that's a won't fix.</p>\r\n<p>Greater use of namespaces - there's different valid arguments here. Some of the guts of the class work nicely as standalone utilities, especially IntTraits (yes, I know Boost has an analogue). Wrapping these in a namespace would be inconvenient. However, we made the opposite decision with the Visual Studio version. Using a namespace for the overall class seems inappropriate unless it is part of a larger library - again, the Visual Studio version does get wrapped in a namespace, along with a number of other utilities. I'd consider putting more of the implementation into a namespace, but it seems less important than say getting the throw decorations correct.</p>\r\n<p>Thanks for the input, and there's no offense taken.</p>",
    "PostedDate": "2011-08-09T10:37:40.46-07:00",
    "UserRole": "Coordinator",
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "655474",
    "ThreadId": "60193",
    "Html": "<p>I believe GCC adheres to the standard with NULL, so it's not exactly treated the same as nullptr.&nbsp; It just generates warnings where nullptr would generate errors.</p>\r\n<p>I often favor the theoretically correct myself.&nbsp; I'm not sure why using a std::vector for safety checks would be a theoretical argument, though; the standard doesn't&nbsp;mandate the safety checks.&nbsp; It seems more of a practical one, since theoretically our code is error-free while practically our code has buffer overflows and the std::vector catches them.&nbsp; Can I have an example where a std::vector can't easily replace operator new[]?</p>\r\n<p>I agree that macros are a necessary part of the language.&nbsp; It's just that many programmers still use macros inappropriately.&nbsp; I couldn't assume you knew about them.&nbsp; Programmers have surprisingly fragmented knowledge of C++, so someone who knows how to write template specializations but doesn't know how the preprocessor works&nbsp;doesn't sound&nbsp;far-fetched to me.&nbsp; Just look at the code of various open-source libraries other than Boost.</p>\r\n<p>I don't understand why&nbsp;you need to define nullptr.&nbsp; Can't you use NULL in your code instead?&nbsp; Remember, nullptr isn't the same as NULL.&nbsp; And you'll be making the user deal with errors when their compiler doesn't support it.</p>\r\n<p>I know the __int8 and __int16 stuff would be difficult to remove.&nbsp; I guess you weren't planning on this library outgrowing MSVC when you started it.&nbsp; If you could do it again today, you'd use typedefs, right?</p>\r\n<p>I'm not as worried about the namespaces as I am with the macros.&nbsp; But, of course, other issues take priority over both of those.&nbsp;&nbsp;Identifier conflicts&nbsp;would probably cause compile errors anyway.&nbsp; If nobody's complained yet, then your macros have good chances of uniqueness.</p>\r\n<p>I'd submit issue reports like you prefer, but unfortunately my time is extremely limited.&nbsp;&nbsp;Having your code reviewed by experts is mainly what I'm going for.&nbsp; Boost developers can find and discuss bugs with you just like I have.&nbsp; Even if your library doesn't make it into Boost,&nbsp;the review process&nbsp;would be a nice way to improve it.</p>",
    "PostedDate": "2011-08-09T13:51:23.37-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "655974",
    "ThreadId": "60193",
    "Html": "<p>I don't have time to pull up the headers to show a concrete&nbsp;example, but an IP header is a variable-length structure that has a minimum of 20 bytes. So you have to calculate the offset to the TCP header, and you end up using pointer math to do so. I could allocate the bytes using a vector, but the only gain I'd get out of it would be to have it clean itself up, and I'd take a hit of some overhead in what's typically highly perf-sensitive code. If I can't realistically use iterators, then converting the vector to a raw pointer really doesn't gain me much in terms of safety.</p>\r\n<p>Another example that I'd really rather not attempt to use a vector with would be a security descriptor on Windows - variable-length structs followed by more variable length structs. You will run into the same issues with most images, especially WMF or EMF, and to some extent bitmaps. So Stephan's point was that one should _never_ call new[] - mine is that it should be called as infrequently as possible.</p>\r\n<p>I know a fair bit about macros, though what did escape me and led to this mistake was that you can't check for a keyword with a #if defined. I should have tested exactly that piece of code. I've stepped through literally every single line and&nbsp;return case in the rest of the class, but defines and such are somewhat more annoying to debug.</p>\r\n<p>You're right that many programmers have a very fragmented knowlege - ran into a guy once that didn't know how to use sprintf, and went though hideously complex C++ hoops to do the same thing. You're also right that there's an amazing variance of errors and brilliance out there - I work on Office, which is over 100 million LOC, and I think every programming approach can be found in there somewhere - partially due to the fact that some of it is 20-25 years old.</p>\r\n<p>I'm sorely tempted to go back to NULL. That's what I get for attempting to use new features. I only actually need it in one function. Other instances of NULL occur in some of the pointer overloads.</p>\r\n<p>No, I wasn't planning on it being used on other compilers at the time I started. If I were to do it over, I'd probably use the types set up in stdint.h.</p>\r\n<p>To be honest, this code has been reviewed by a large number of experts. Some find interesting issues, others don't. The most effective thing that we've done is to create a rigorous test harness. It's one thing to look at code and think it looks good, quite another to _prove_ it works - we caught errors created by the Intel compiler this way, and then proved that we'd coded around them. Most of what's left are things like you caught, where there's no runtime effect, just playing nice with other libraries and code. The remainder of what's left is debatable issues, like how much of the guts to enclose in a namespace, one file or two, whether to put the whole class's external interfaces in a namespace, etc.</p>\r\n<p>I should still look into getting it into Boost, though I think the legal stuff is the bigger hurdle. We have a perfectly fine license, they do too, not sure why everyone can't just get along... It would be one thing is one license were restrictive, but neither of these are.</p>",
    "PostedDate": "2011-08-10T10:35:31.39-07:00",
    "UserRole": "Coordinator",
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "656156",
    "ThreadId": "60193",
    "Html": "<p>This should work:</p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre><span style=\"color: blue;\">void</span> handle_packet(vector&lt;<span style=\"color: blue;\">char</span>&gt; packet)\r\n{\r\n    <span style=\"color: green;\">// determine length of IP header</span>\r\n    uint32_t word_1;\r\n    packet.at(4 - 1);\r\n    memcpy(&amp;word_1, &amp;packet[0], 4);\r\n    word_1 = ntohl(word_1);\r\n    <span style=\"color: blue;\">auto</span> length = 4 * (SafeInt&lt;uint32_t&gt;(word_1) &lt;&lt; 24 &gt;&gt; 24 &gt;&gt; 4);\r\n    <span style=\"color: blue;\">if</span> (length &lt; 20)\r\n        <span style=\"color: blue;\">throw</span> some_error();\r\n    packet.at(length - 1);\r\n    <span style=\"color: green;\">// get iterator to data section</span>\r\n    <span style=\"color: blue;\">auto</span> data = packet.begin() + length;\r\n    <span style=\"color: blue;\">if</span> (data != packet.end())\r\n    {\r\n        <span style=\"color: green;\">// do stuff with data</span>\r\n    }\r\n}\r\n</pre>\r\n</div>\r\n<p>The only reason to use operator new[] that I can think of is optimization, though vector is so fast in VC10 that I can't see it happening much.&nbsp;&nbsp;I would store variable-length structs using malloc.&nbsp; operator new[] seems inappropriate if I'm circumventing the type system anyway.</p>\r\n<p>I know it sucks giving up nullptr.&nbsp; I love it myself.&nbsp; NULL&nbsp;was&nbsp;a mistake&nbsp;to me.&nbsp; But I've tried shoehorning nullptr into my program when&nbsp;GCC didn't have it, and it wasn't easy.&nbsp; std::function needed an overload for nullptr_t, for example.</p>\r\n<p>stdint.h isn't available in VC9.&nbsp; I wanted to see if you would add typedefs for an extra layer of portability, like:</p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre><span style=\"color: green;\">// assume we have &lt;stdint.h&gt; by default</span>\r\n#define SAFEINT_HAS_STDINT_H\r\n<span style=\"color: green;\">// MSVC versions earlier than 10.0</span>\r\n#<span style=\"color: blue;\">if</span> defined _MSC_VER &amp;&amp; _MSC_VER &lt; 1600\r\n#undef SAFEINT_HAS_STDINT_H\r\n#endif  <span style=\"color: green;\">// defined _MSC_VER &amp;&amp; _MSC_VER &lt; 1600</span>\r\n\r\n#ifdef SAFEINT_HAS_STDINT_H\r\n#include &lt;stdint.h&gt;\r\n#endif  <span style=\"color: green;\">// SAFEINT_HAS_STDINT_H</span>\r\n\r\n<span style=\"color: blue;\">namespace</span> safeint\r\n{\r\n#ifdef SAFEINT_HAS_STDINT_H\r\n    <span style=\"color: blue;\">using</span> ::int8_t;\r\n    <span style=\"color: blue;\">using</span> ::uint8_t;\r\n#elif defined _MSC_VER\r\n    <span style=\"color: blue;\">typedef</span> __int8 int8_t;\r\n    <span style=\"color: blue;\">typedef</span> <span style=\"color: blue;\">unsigned</span> __int8 uint8_t;\r\n#<span style=\"color: blue;\">else</span>   <span style=\"color: green;\">// defined _MSC_VER</span>\r\n#error need fixed-width integer types\r\n#endif  <span style=\"color: green;\">// defined _MSC_VER</span>\r\n\r\n    <span style=\"color: blue;\">template</span>&lt;<span style=\"color: blue;\">class</span> Ty&gt;\r\n    <span style=\"color: blue;\">class</span> safeint\r\n    {\r\n    <span style=\"color: blue;\">public</span>:\r\n        <span style=\"color: blue;\">operator</span> int8_t() <span style=\"color: blue;\">const</span>;\r\n\r\n        <span style=\"color: blue;\">operator</span> uint8_t() <span style=\"color: blue;\">const</span>;\r\n    }\r\n}\r\n</pre>\r\n</div>\r\n<p>That's how I would do it.</p>\r\n<p>By the way, the line endings are inconsistent in 3.0.16.</p>",
    "PostedDate": "2011-08-10T15:27:38.187-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "656203",
    "ThreadId": "60193",
    "Html": "<p>Heh - here's how you really do it:</p>\r\n<p>unsigned long GetHeaderLen(const char* pPacket, unsigned long cbPacket)<br />{<br />&nbsp;&nbsp; ip* pIp = reinterpret_cast&lt;ip*&gt;(pPacket);<br />&nbsp;&nbsp; if( ﻿pIp == NULL || pIp-&gt;﻿ip_v != 4) return 0;<br />&nbsp;&nbsp; unsigned long len =&nbsp;pIp-&gt;ip_hl * 8; // int overflow not possible, ip_hl can be at most 15 - only 4 bits<br />&nbsp;&nbsp; return len&nbsp;&gt; cbPacket || len &lt; 20 ?&nbsp;0 : len;<br />}</p>\r\n<p>Lots easier and no overhead. You _can_ do nearly anything using STL, the question is whether maybe plain old C might be a more efficient choice (and sometimes more readable)</p>\r\n<p>Usually Visual Studio fixes up line endings - have to look into that.</p>\r\n<p>The point about the header is why I try as much as possible to avoid depending on them (for this sort of project). Given some number of compilers that are supported on some number of platforms, the more headers, the more chance for headaches.</p>",
    "PostedDate": "2011-08-10T18:09:17.817-07:00",
    "UserRole": "Coordinator",
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "656229",
    "ThreadId": "60193",
    "Html": "<p>It really depends on the requirements of the application.&nbsp; In most cases, the overhead will be negligible.&nbsp; Without solid profiling, I can't justify the security tradeoff.&nbsp; But if you have proof that the vector has too much overhead, then of course you shouldn't use it.&nbsp; Otherwise, it would be premature optimization.</p>\r\n<p>There's a way to get the fixed-width types without the header by using limits.h instead, but practically only Boost needs that kind of portability.</p>",
    "PostedDate": "2011-08-10T19:45:43.59-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "676225",
    "ThreadId": "60193",
    "Html": "<blockquote style=\"border: 0.1em solid #cccccc; font-style: italic; margin: 0.25em 1em 0pt; padding: 0pt 0.25em;\"><strong>Timothy003 wrote:</strong><br />\r\n<p>.... In most cases, the overhead will be negligible.&nbsp; Without solid profiling, I can't justify the security tradeoff.&nbsp; But if you have proof that the vector has too much overhead, then of course you shouldn't  use it.&nbsp; Otherwise, it would be premature optimization.</p>\r\n</blockquote>\r\n<p>Seriously? A program has to be correct before anything else.</p>\r\n<p>Out of curiosity, how can you be certain the attacker does not control the input?</p>",
    "PostedDate": "2011-09-24T13:28:56.107-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "676228",
    "ThreadId": "60193",
    "Html": "<blockquote style=\"padding-bottom: 0px; font-style: italic; margin: 0.25em 1em 0px; padding-left: 0.25em; padding-right: 0.25em; padding-top: 0px; border: #ccc 0.1em solid;\"><strong>noloader wrote:</strong><br />\r\n<blockquote style=\"padding-bottom: 0pt; font-style: italic; margin: 0.25em 1em 0pt; padding-left: 0.25em; padding-right: 0.25em; padding-top: 0pt; border: #cccccc 0.1em solid;\"><strong>Timothy003 wrote:</strong><br />\r\n<p>.... In most cases, the overhead will be negligible.&nbsp; Without solid profiling, I can't justify the security tradeoff.&nbsp; But if you have proof that the vector has too much overhead, then of course you shouldn't use it.&nbsp; Otherwise, it would be premature optimization.</p>\r\n</blockquote>\r\n<p>Seriously? A program has to be correct before anything else.</p>\r\n<p>Out of curiosity, how can you be certain the attacker does not control the input?</p>\r\n</blockquote>\r\n<p><br />Are you implying that dcleblanc's&nbsp;code is safer and more correct?&nbsp; Other than relying on undefined behavior with the type punning, there's already a bug in it; it doesn't validate the packet's size.&nbsp; With vector, iterator debugging will give you a better chance of catching incorrect code.</p>\r\n<p>The two examples don't do the same things, anyway.</p>",
    "PostedDate": "2011-09-24T13:44:51.18-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "676423",
    "ThreadId": "60193",
    "Html": "<blockquote style=\"border: 0.1em solid #cccccc; font-style: italic; margin: 0.25em 1em 0pt; padding: 0pt 0.25em;\"><strong>Timothy003 wrote:</strong><br />\n<blockquote style=\"padding: 0px 0.25em; font-style: italic; margin: 0.25em 1em 0px; border: 0.1em solid #cccccc;\"><strong>noloader wrote:</strong><br />\n<blockquote style=\"padding: 0pt 0.25em; font-style: italic; margin: 0.25em 1em 0pt; border: 0.1em solid #cccccc;\"><strong>Timothy003 wrote:</strong><br />\n<p>.... In most cases, the overhead will be negligible.&nbsp; Without solid profiling, I can't justify the security tradeoff.&nbsp; But if you have proof that the vector has too much overhead, then of course you shouldn't use it.&nbsp; Otherwise, it would be premature optimization.</p>\n</blockquote>\n<p>Seriously? A program has to be correct before anything else.</p>\n<p>Out of curiosity, how can you be certain the attacker does not control the input?</p>\n</blockquote>\n<p><br /> Are you implying that dcleblanc's&nbsp;code is safer and more correct?&nbsp; Other than relying on undefined behavior with the type punning, there's already a bug in it; it doesn't validate the packet's size.&nbsp; With vector, iterator debugging will give you a better chance  of catching incorrect code.</p>\n<p>The two examples don't do the same things, anyway.</p>\n</blockquote>\n<p># Are you implying that dcleblanc's&nbsp;code is safer and more correct?<br /> Yes, I believe LeBlanc's SafeInt code is safer in general.</p>\n<p>If the time ever comes, I believe ignoring wrap and overflow will be grossly negligent. The industry enjoys software patents, it should also enjoy liability.</p>\n<p># Other than relying on undefined behavior with the type punning...<br /> My bad, I was commenting in general, and not on the particular examples.</p>\n<p>For what its worth, the Visual Studio compiler is more tolerant of punning. I think VS just does the right thing and gets the alignments right (with no warning). There is some hand waiving on the way the code is fixed up at runtime, though.</p>\n<p># With vector, iterator debugging will give you a better chance of catching incorrect code.<br /> I love debug builds and asserts (I'm a student of John Robbins), but this is a problem in practice. To convince yourself, install libboost via apt-get or yum and define _GLIBCXX_DEBUG (http://gcc.gnu.org/onlinedocs/libstdc++/manual/debug_mode.html). I recently  [incorreclty] filed a report against Boost::Regex (it was an ABI problem).</p>\n<p>I know I could have built the source from scratch. But Boost has broken the tried and true configure/make/install in favor of something else buried in a spaghetti of documentation. I could be wrong, but I had no joy in building on Solaris (a Boost bug report  was filed, no acknowledgement to date).</p>\n<p>Jeff</p>",
    "PostedDate": "2011-09-25T13:33:23.913-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "676448",
    "ThreadId": "60193",
    "Html": "<blockquote style=\"border: 0.1em solid #cccccc; font-style: italic; margin: 0.25em 1em 0pt; padding: 0pt 0.25em;\"><strong>Timothy003 wrote:</strong><br />\n<p>Boost has really smart people in its community, and sets ultra-high standards.&nbsp; Libraries are peer-reviewed too, so you'd get a lot of good feedback on your code.&nbsp; For example, I grabbed the latest SafeInt3.hpp, opened it up,&nbsp;and immediately saw this:</p>\n<div style=\"color: black; background-color: white;\">\n<pre>#<span style=\"color: blue;\">if</span> !defined NULL<br />#define NULL ((<span style=\"color: blue;\">void</span>*)0)<br />#endif<br /></pre>\n</div>\n<div style=\"color: black; background-color: white;\">\n<pre><span style=\"color: green;\">// These two may not be defined, either</span><br />#<span style=\"color: blue;\">if</span> !defined uintptr_t<br />#define uintptr_t size_t<br />#endif<br /><br />#<span style=\"color: blue;\">if</span> !defined intptr_t<br />#define intptr_t ptrdiff_t<br />#endif<br /></pre>\n</div>\n<div style=\"color: black; background-color: white;\">\n<pre><span style=\"color: green;\">// Might need this for gcc and older Microsoft compilers</span><br />#<span style=\"color: blue;\">if</span> !defined <span style=\"color: blue;\">nullptr</span><br />#define <span style=\"color: blue;\">nullptr</span> NULL<br />#endif<br /></pre>\n</div>\n<p>Code like that is evil.&nbsp; The folks at Boost would surely&nbsp;let you know about it, and you'll learn modern C++ programming paradigms, improving the quality of your code.</p>\n</blockquote>\n<p># Boost has really smart people in its community, and sets ultra-high standards.<br /> I'm not sure about the ultra high standards.</p>\n<p># Libraries are peer-reviewed too, so you'd get a lot of good feedback on your code<br /> That&nbsp; Boost will accept anything and hope that someone will [eventually] spot an error is a detriment, not a feature. For example, it appears Boost accepted threads and rolled them out without rigorous review or acceptance testing. Distributions generally don't  backport bug fixes, so downlevel users are stuck with defective code.</p>\n<p>On my cursory review, Boost::Threads did not meet production quality (I filed about 15 bugs against it). For example, ignoring return values from WaitForSingleObject and pthread_mutex_lock was egregious. In addition, the subproject suffers resource leaks  on negative code paths and race conditions.</p>\n<p>Ignoring return values is something I would expect from a self-taught, l33t, K&amp;R coder. I don't think a CompSci freshman would make the same mistakes. And I don't want code like that in my code base.</p>\n<p>It also appears Boost does not audit the bug database. To date, none of the bugs have even been acknowledged.</p>\n<p># Code like that is evil. The folks at Boost would surely&nbsp;let you know about it...<br /> Have a look at Boost::Test and its use of macros sometime. If you are offended by LeBlanc's three uses, you will be horrified with Boost::Test.</p>",
    "PostedDate": "2011-09-25T14:57:01.043-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]