diff -Naurp safe_int.orig/SafeInt3.hpp safe_int/SafeInt3.hpp
--- safe_int.orig/SafeInt3.hpp	2010-01-12 19:06:08.000000000 -0500
+++ safe_int/SafeInt3.hpp	2010-01-12 19:41:49.000000000 -0500
@@ -419,6 +419,7 @@ SAFEINT_DISABLE_SHIFT_ASSERT       - Set
 * 
 * * */
 
+#if !defined SAFEINT_GCC_HPP
 #pragma warning(push)
 //this avoids warnings from the unary '-' operator being applied to unsigned numbers
 #pragma warning(disable:4146)
@@ -434,6 +435,7 @@ SAFEINT_DISABLE_SHIFT_ASSERT       - Set
 #pragma warning(disable:4244)
 #pragma warning(disable:4267)
 #endif
+#endif
 
 
 //use these if the compiler does not support _intXX
@@ -549,7 +551,7 @@ namespace SafeIntInternal
    {
    public:
 #if defined SAFEINT_GCC_HPP
-       static void SafeIntOnOverflow()
+       static __attribute__((noreturn)) void SafeIntOnOverflow()
 #else
        static __declspec(noreturn) void __stdcall SafeIntOnOverflow()
 #endif
@@ -559,7 +561,7 @@ namespace SafeIntInternal
        }
 
 #if defined SAFEINT_GCC_HPP
-       static void SafeIntOnDivZero()
+       static __attribute__((noreturn)) void SafeIntOnDivZero()
 #else
        static __declspec(noreturn) void __stdcall SafeIntOnDivZero()
 #endif
@@ -655,7 +657,9 @@ public:
     C_ASSERT( NumericType<T>::isInt );
     enum
     {
+#if !defined SAFEINT_GCC_HPP
 #pragma warning(suppress:4804) 
+#endif
         isSigned  = ( (T)(-1) < 0 ),
         is64Bit   = ( sizeof(T) == 8 ),
         is32Bit   = ( sizeof(T) == 4 ),
@@ -672,7 +676,9 @@ public:
         isInt64   = ( sizeof(T) == 8 && isSigned ),
         isUint64  = ( sizeof(T) == 8 && !isSigned ),
         bitCount  = ( sizeof(T)*8 ),
+#if !defined SAFEINT_GCC_HPP
 #pragma warning(suppress:4804)
+#endif
         isBool    = ( (T)2 == (T)1 )
     };
 
@@ -680,8 +686,72 @@ public:
     // so we'll use const statics instead!
     const static T maxInt = isSigned ? ((T)~((T)1 << (T)(bitCount-1))) : ((T)(~(T)0));
     const static T minInt = isSigned ? ((T)((T)1 << (T)(bitCount-1)))  : ((T)0);
+
+    // GCC warnings workarounds: GCC will detect & warn for comparisons which
+    // will always be true, e.g. unsigned int x; if(x >= 0). This warning can't
+    // be disabled in v4.2. Workaround this by only performing the comparisons
+    // for types where the comparison could conceivably be false.
+
+    // Returns true if t >= 0.
+    static bool greaterEqualZero(const T& t);
+    // Returns true if t == -1.
+    static bool equalsMinusOne(const T& t);
+    // Returns true if u <= T::maxInt. u's type doesn't need to be T.
+    template<typename U> static inline bool isLessEqualMaxInt(const U& u);
+};
+
+
+// GCC workaround implementation
+template<bool isSigned> struct CompareConstHelper;
+template<> struct CompareConstHelper<true>
+{
+    template<typename T> static inline bool GreaterEqualZero(const T &a) { return a >= 0; }
+    template<typename T> static inline bool EqualsMinusOne(const T &a) { return a == -1; }
+};
+template<> struct CompareConstHelper<false>
+{
+    template<typename T> static inline bool GreaterEqualZero(const T &a) { return true; }
+    template<typename T> static inline bool EqualsMinusOne(const T &a) { return false; }
 };
 
+template<typename T> inline bool IntTraits<T>::greaterEqualZero(const T& t)
+{
+    return CompareConstHelper<isSigned>::GreaterEqualZero(t);
+}
+template<typename T> inline bool IntTraits<T>::equalsMinusOne(const T& t)
+{
+    return CompareConstHelper<isSigned>::EqualsMinusOne(t);
+}
+
+// couldExceed will be true if U's range might exceed LimitType's.
+template<typename LimitType, typename U, bool couldExceed> struct CompareMaxHelper;
+
+template<typename LimitType, typename U> struct CompareMaxHelper<LimitType, U, true>
+{
+    static inline bool LessEqualMaxInt(const U &u)
+    {
+        // if we reach this, we know that converting T->U will not overflow
+        return u <= U(IntTraits<LimitType>::maxInt);
+    }
+};
+
+template<typename LimitType, typename U> struct CompareMaxHelper<LimitType, U, false>
+{
+    static inline bool LessEqualMaxInt(const U &u) { return false; }
+};
+
+template<typename T> template<typename U>
+inline bool IntTraits<T>::isLessEqualMaxInt(const U& u)
+{
+    const bool couldExceed = sizeof(U) > sizeof(T) || 
+        (sizeof(U) == sizeof(T) && 
+         IntTraits<T>::isSigned &&
+         !IntTraits<U>::isSigned);
+    return CompareMaxHelper<T, U, couldExceed>::LessEqualMaxInt(u);
+}
+
+
+
 template < typename T, typename U > class SafeIntCompare
 {
 public:
@@ -1058,7 +1128,7 @@ template < typename T, typename U > clas
 public:
     static bool Cast( U u, T& t ) throw()
     {
-        if( u > IntTraits< T >::maxInt )
+        if( !IntTraits<T>::isLessEqualMaxInt(u) )
             return false;
 
         t = (T)u;
@@ -1068,7 +1138,7 @@ public:
     template < typename E >
     static void CastThrow( U u, T& t )
     {
-        if( u > IntTraits< T >::maxInt )
+        if( !IntTraits<T>::isLessEqualMaxInt(u) )
             E::SafeIntOnOverflow();
 
         t = (T)u;
@@ -1301,13 +1371,10 @@ public:
             E::SafeIntOnDivZero();
 
         //trap corner case
-        if( IntTraits< U >::isSigned )
+        if(IntTraits<U>::equalsMinusOne(u))
         {
-            if(u == -1)
-            {
-               result = 0;
-               return;
-            }
+           result = 0;
+           return;
         }
 
         result = (T)(t % u);
@@ -1323,13 +1390,10 @@ public:
             return SafeIntDivideByZero;
 
         //trap corner case
-        if( IntTraits< U >::isSigned )
+        if(IntTraits<U>::equalsMinusOne(u))
         {
-            if(u == -1)
-            {
-                result = 0;
-                return SafeIntNoError;
-            }
+            result = 0;
+            return SafeIntNoError;
         }
 
         result = (T)(t % u);
@@ -1343,13 +1407,10 @@ public:
             E::SafeIntOnDivZero();
 
         //trap corner case
-        if( IntTraits< U >::isSigned )
+        if( IntTraits< U >::equalsMinusOne(u) )
         {
-            if(u == -1)
-            {
-               result = 0;
-               return;
-            }
+           result = 0;
+           return;
         }
 
         result = (T)(t % u);
@@ -1378,7 +1439,7 @@ public:
         if(u == 0)
             E::SafeIntOnDivZero();
 
-        if(IntTraits< U >::isSigned && u == -1)
+        if(IntTraits< U >::equalsMinusOne(u))
             result = 0;
         else
             result = (T)((__int64)t % (__int64)u);
@@ -1621,14 +1682,15 @@ public:
     }
 };
 
-// T = left arg and return type
-// U = right arg
-template < typename T, typename U > class LargeIntRegMultiply;
+// Ttmp = type whose signedness and size matches left arg and return type
+// Utmp = type whose signedness and size matches right arg
+template < typename Ttmp, typename Utmp > class LargeIntRegMultiply;
 
 template<> class LargeIntRegMultiply< unsigned __int64, unsigned __int64 >
 {
 public:
-    static bool RegMultiply( const unsigned __int64& a, const unsigned __int64& b, unsigned __int64& ret ) throw()
+    template < typename T, typename U >
+    static bool RegMultiply( const T& a, const U& b, T& ret ) throw()
     {
         unsigned __int32 aHigh, aLow, bHigh, bLow;
 
@@ -1684,8 +1746,8 @@ public:
         return true;
     }
 
-    template < typename E >
-    static void RegMultiplyThrow( const unsigned __int64& a, const unsigned __int64& b, unsigned __int64& ret )
+    template < typename E, typename T, typename U >
+    static void RegMultiplyThrow( const T& a, const U& b, T& ret )
     {
         unsigned __int32 aHigh, aLow, bHigh, bLow;
 
@@ -1744,7 +1806,8 @@ public:
 template<> class LargeIntRegMultiply< unsigned __int64, unsigned __int32 >
 {
 public:
-    static bool RegMultiply( const unsigned __int64& a, unsigned __int32 b, unsigned __int64& ret ) throw()
+    template < typename T, typename U >
+    static bool RegMultiply( const T& a, const U& b, T& ret ) throw()
     {
         unsigned __int32 aHigh, aLow;
 
@@ -1780,8 +1843,8 @@ public:
         return true;
     }
 
-    template < typename E >
-    static void RegMultiplyThrow( const unsigned __int64& a, unsigned __int32 b, unsigned __int64& ret )
+    template < typename E, typename T, typename U >
+    static void RegMultiplyThrow( const T& a, const U& b, T& ret )
     {
         unsigned __int32 aHigh, aLow;
 
@@ -1821,7 +1884,8 @@ public:
 template<> class LargeIntRegMultiply< unsigned __int64, signed __int32 >
 {
 public:
-    static bool RegMultiply( const unsigned __int64& a, signed __int32 b, unsigned __int64& ret ) throw()
+    template < typename T, typename U >
+    static bool RegMultiply( const T& a, const U& b, T& ret ) throw()
     {
         if( b < 0 && a != 0 )
             return false;
@@ -1829,8 +1893,8 @@ public:
         return LargeIntRegMultiply< unsigned __int64, unsigned __int32 >::RegMultiply(a, (unsigned __int32)b, ret);
     }
 
-    template < typename E >
-    static void RegMultiplyThrow( const unsigned __int64& a, signed __int32 b, unsigned __int64& ret )
+    template < typename E, typename T, typename U >
+    static void RegMultiplyThrow( const T& a, const U& b, T& ret )
     {
         if( b < 0 && a != 0 )
             E::SafeIntOnOverflow();
@@ -1842,7 +1906,8 @@ public:
 template<> class LargeIntRegMultiply< unsigned __int64, signed __int64 >
 {
 public:
-    static bool RegMultiply( const unsigned __int64& a, signed __int64 b, unsigned __int64& ret ) throw()
+    template < typename T, typename U >
+    static bool RegMultiply( const T& a, const U& b, T& ret ) throw()
     {
         if( b < 0 && a != 0 )
             return false;
@@ -1850,8 +1915,8 @@ public:
         return LargeIntRegMultiply< unsigned __int64, unsigned __int64 >::RegMultiply(a, (unsigned __int64)b, ret);
     }
 
-    template < typename E >
-    static void RegMultiplyThrow( const unsigned __int64& a, signed __int64 b, unsigned __int64& ret )
+    template < typename E, typename T, typename U >
+    static void RegMultiplyThrow( const T& a, const U& b, T& ret )
     {
         if( b < 0 && a != 0 )
             E::SafeIntOnOverflow();
@@ -1863,7 +1928,8 @@ public:
 template<> class LargeIntRegMultiply< signed __int32, unsigned __int64 >
 {
 public:
-    static bool RegMultiply( signed __int32 a, const unsigned __int64& b, signed __int32& ret ) throw()
+    template < typename T, typename U >
+    static bool RegMultiply( const T& a, const U& b, T& ret ) throw()
     {
         signed __int32 bHigh, bLow;
         bool fIsNegative = false;
@@ -1909,8 +1975,8 @@ public:
         return false;
     }
 
-    template < typename E >
-    static void RegMultiplyThrow( signed __int32 a, const unsigned __int64& b, signed __int32& ret )
+    template < typename E, typename T, typename U >
+    static void RegMultiplyThrow( T a, const U& b, T& ret )
     {
         signed __int32 bHigh, bLow;
         bool fIsNegative = false;
@@ -1959,7 +2025,8 @@ public:
 template<> class LargeIntRegMultiply< unsigned __int32, unsigned __int64 >
 {
 public:
-    static bool RegMultiply( unsigned __int32 a, const unsigned __int64& b, unsigned __int32& ret ) throw()
+    template < typename T, typename U >
+    static bool RegMultiply( const T& a, const U& b, T& ret ) throw()
     {
         // Consider that a*b can be broken up into:
         // (bHigh * 2^32 + bLow) * a
@@ -1979,8 +2046,8 @@ public:
         return true;
     }
 
-    template < typename E >
-    static void RegMultiplyThrow( unsigned __int32 a, const unsigned __int64& b, unsigned __int32& ret )
+    template < typename E, typename T, typename U >
+    static void RegMultiplyThrow( const T& a, const U& b, T& ret )
     {
         if( (unsigned __int32)(b >> 32) != 0 && a != 0 )
            E::SafeIntOnOverflow();
@@ -1997,15 +2064,16 @@ public:
 template<> class LargeIntRegMultiply< unsigned __int32, signed __int64 >
 {
 public:
-    static bool RegMultiply( unsigned __int32 a, const signed __int64& b, unsigned __int32& ret ) throw()
+    template < typename T, typename U >
+    static bool RegMultiply( const T& a, const U& b, T& ret ) throw()
     {
         if( b < 0 && a != 0 )
             return false;
         return LargeIntRegMultiply< unsigned __int32, unsigned __int64 >::RegMultiply( a, (unsigned __int64)b, ret );
     }
 
-    template < typename E >
-    static void RegMultiplyThrow( unsigned __int32 a, const signed __int64& b, unsigned __int32& ret )
+    template < typename E, typename T, typename U >
+    static void RegMultiplyThrow( const T& a, const U& b, T& ret )
     {
         if( b < 0 && a != 0 )
             E::SafeIntOnOverflow();
@@ -2017,7 +2085,8 @@ public:
 template<> class LargeIntRegMultiply< signed __int64, signed __int64 >
 {
 public:
-    static bool RegMultiply( const signed __int64& a, const signed __int64& b, signed __int64& ret ) throw()
+    template < typename T, typename U >
+    static bool RegMultiply( const T& a, const U& b, T& ret ) throw()
     {
         bool aNegative = false;
         bool bNegative = false;
@@ -2064,8 +2133,8 @@ public:
         return false;
     }
 
-    template < typename E >
-    static void RegMultiplyThrow( const signed __int64& a, const signed __int64& b, signed __int64& ret )
+    template < typename E, typename T, typename U >
+    static void RegMultiplyThrow( const T& a, const U& b, T& ret )
     {
         bool aNegative = false;
         bool bNegative = false;
@@ -2115,7 +2184,8 @@ public:
 template<> class LargeIntRegMultiply< signed __int64, unsigned __int32 >
 {
 public:
-    static bool RegMultiply( const signed __int64& a, unsigned __int32 b, signed __int64& ret ) throw()
+    template < typename T, typename U >
+    static bool RegMultiply( const T& a, const U& b, T& ret ) throw()
     {
         bool aNegative = false;
         unsigned __int64 tmp;
@@ -2153,8 +2223,8 @@ public:
         return false;
     }
 
-    template < typename E >
-    static void RegMultiplyThrow( const signed __int64& a, unsigned __int32 b, signed __int64& ret )
+    template < typename E, typename T, typename U >
+    static void RegMultiplyThrow( const T& a, const U& b, T& ret )
     {
         bool aNegative = false;
         unsigned __int64 tmp;
@@ -2195,7 +2265,8 @@ public:
 template<> class LargeIntRegMultiply< signed __int64, signed __int32 >
 {
 public:
-    static bool RegMultiply( const signed __int64& a, signed __int32 b, signed __int64& ret ) throw()
+    template < typename T, typename U >
+    static bool RegMultiply( const T& a, const U& b, T& ret ) throw()
     {
         bool aNegative = false;
         bool bNegative = false;
@@ -2242,8 +2313,8 @@ public:
         return false;
     }
 
-    template < typename E >
-    static void RegMultiplyThrow( signed __int64 a, signed __int32 b, signed __int64& ret )
+    template < typename E, typename T, typename U >
+    static void RegMultiplyThrow( T a, U b, T& ret )
     {
         bool aNegative = false;
         bool bNegative = false;
@@ -2291,7 +2362,8 @@ public:
 template<> class LargeIntRegMultiply< signed __int32, signed __int64 >
 {
 public:
-    static bool RegMultiply( signed __int32 a, const signed __int64& b, signed __int32& ret ) throw()
+    template < typename T, typename U >
+    static bool RegMultiply( T a, const U& b, T& ret ) throw()
     {
         bool aNegative = false;
         bool bNegative = false;
@@ -2337,8 +2409,8 @@ public:
         return false;
     }
 
-    template < typename E >
-    static void RegMultiplyThrow( signed __int32 a, const signed __int64& b, signed __int32& ret )
+    template < typename E, typename T, typename U >
+    static void RegMultiplyThrow( T a, const U& b, T& ret )
     {
         bool aNegative = false;
         bool bNegative = false;
@@ -2387,7 +2459,8 @@ public:
 template<> class LargeIntRegMultiply< signed __int64, unsigned __int64 >
 {
 public:
-    static bool RegMultiply( const signed __int64& a, const unsigned __int64& b, signed __int64& ret ) throw()
+    template < typename T, typename U >
+    static bool RegMultiply( const T& a, const U& b, T& ret ) throw()
     {
         bool aNegative = false;
 
@@ -2426,8 +2499,8 @@ public:
         return false;
     }
 
-    template < typename E >
-    static void RegMultiplyThrow( const signed __int64& a, const unsigned __int64& b, signed __int64& ret )
+    template < typename E, typename T, typename U >
+    static void RegMultiplyThrow( const T& a, const U& b, T& ret )
     {
         bool aNegative = false;
         unsigned __int64 tmp;
@@ -2466,47 +2539,47 @@ public:
     }
 };
 
-template <> class MultiplicationHelper< unsigned __int64, unsigned __int64, MultiplicationState_Uint64Uint64 >
+template < typename T, typename U > class MultiplicationHelper< T, U, MultiplicationState_Uint64Uint64 >
 {
 public:
-    static bool Multiply( const unsigned __int64& t, const unsigned __int64& u, unsigned __int64& ret ) throw()
+    static bool Multiply( const T& t, const U& u, T& ret ) throw()
     {
         return LargeIntRegMultiply< unsigned __int64, unsigned __int64 >::RegMultiply( t, u, ret );
     }
 
     template < typename E >
-    static void MultiplyThrow(const unsigned __int64& t, const unsigned __int64& u, unsigned __int64& ret)
+    static void MultiplyThrow(const T& t, const U& u, T& ret)
     {
         LargeIntRegMultiply< unsigned __int64, unsigned __int64 >::template RegMultiplyThrow< E >( t, u, ret );
     }
 };
 
-template < typename U > class MultiplicationHelper<unsigned __int64, U, MultiplicationState_Uint64Uint >
+template < typename T, typename U > class MultiplicationHelper<T, U, MultiplicationState_Uint64Uint >
 {
 public:
     //U is any unsigned int 32-bit or less
-    static bool Multiply( const unsigned __int64& t, const U& u, unsigned __int64& ret ) throw()
+    static bool Multiply( const T& t, const U& u, T& ret ) throw()
     {
         return LargeIntRegMultiply< unsigned __int64, unsigned __int32 >::RegMultiply( t, (unsigned __int32)u, ret );
     }
 
     template < typename E >
-    static void MultiplyThrow( const unsigned __int64& t, const U& u, unsigned __int64& ret )
+    static void MultiplyThrow( const T& t, const U& u, T& ret )
     {
         LargeIntRegMultiply< unsigned __int64, unsigned __int32 >::template RegMultiplyThrow< E >( t, (unsigned __int32)u, ret );
     }
 };
 
 // converse of the previous function
-template <typename T> class MultiplicationHelper< T, unsigned __int64, MultiplicationState_UintUint64 >
+template <typename T, typename U> class MultiplicationHelper< T, U, MultiplicationState_UintUint64 >
 {
 public:
     // T is any unsigned int up to 32-bit
-    static bool Multiply(const T& t, const unsigned __int64& u, T& ret) throw()
+    static bool Multiply(const T& t, const U& u, T& ret) throw()
     {
         unsigned __int32 tmp;
 
-        if( LargeIntRegMultiply< unsigned __int32, unsigned __int64 >::RegMultiply( t, u, tmp ) &&
+        if( LargeIntRegMultiply< unsigned __int32, unsigned __int64 >::RegMultiply( (unsigned __int32)t, u, tmp ) &&
             SafeCastHelper< T, unsigned __int32, GetCastMethod< T, unsigned __int32 >::method >::Cast(tmp, ret) )
         {
             return true;
@@ -2516,51 +2589,51 @@ public:
     }
 
     template < typename E >
-    static void MultiplyThrow(const T& t, const unsigned __int64& u, T& ret)
+    static void MultiplyThrow(const T& t, const U& u, T& ret)
     {
         unsigned __int32 tmp;
         
-        LargeIntRegMultiply< unsigned __int32, unsigned __int64 >::template RegMultiplyThrow< E >( t, u, tmp );
+        LargeIntRegMultiply< unsigned __int32, unsigned __int64 >::template RegMultiplyThrow< E >( (unsigned __int32)t, u, tmp );
         SafeCastHelper< T, unsigned __int32, GetCastMethod< T, unsigned __int32 >::method >::template CastThrow< E >(tmp, ret);
     }
 };
 
-template < typename U > class MultiplicationHelper<unsigned __int64, U, MultiplicationState_Uint64Int >
+template < typename T, typename U > class MultiplicationHelper<T, U, MultiplicationState_Uint64Int >
 {
 public:
     //U is any signed int, up to 64-bit
-    static bool Multiply(const unsigned __int64& t, const U& u, unsigned __int64& ret) throw()
+    static bool Multiply(const T& t, const U& u, T& ret) throw()
     {
         return LargeIntRegMultiply< unsigned __int64, signed __int32 >::RegMultiply(t, (signed __int32)u, ret);
     }
 
     template < typename E >
-    static void MultiplyThrow(const unsigned __int64& t, const U& u, unsigned __int64& ret)
+    static void MultiplyThrow(const T& t, const U& u, T& ret)
     {
         LargeIntRegMultiply< unsigned __int64, signed __int32 >::template RegMultiplyThrow< E >(t, (signed __int32)u, ret);
     }
 };
 
-template < > class MultiplicationHelper<unsigned __int64, __int64, MultiplicationState_Uint64Int64 >
+template < typename T, typename U > class MultiplicationHelper<T, U, MultiplicationState_Uint64Int64 >
 {
 public:
-    static bool Multiply(const unsigned __int64& t, const __int64& u, unsigned __int64& ret) throw()
+    static bool Multiply(const T& t, const U& u, T& ret) throw()
     {
         return LargeIntRegMultiply< unsigned __int64, __int64 >::RegMultiply(t, u, ret);
     }
 
     template < typename E >
-    static void MultiplyThrow(const unsigned __int64& t, const __int64& u, unsigned __int64& ret)
+    static void MultiplyThrow(const T& t, const U& u, T& ret)
     {
         LargeIntRegMultiply< unsigned __int64, __int64 >::template RegMultiplyThrow< E >(t, u, ret);
     }
 };
 
-template <typename T> class MultiplicationHelper< T, __int64, MultiplicationState_UintInt64 >
+template <typename T, typename U> class MultiplicationHelper< T, U, MultiplicationState_UintInt64 >
 {
 public:
     //T is unsigned up to 32-bit
-    static bool Multiply(const T& t, const __int64& u, T& ret) throw()
+    static bool Multiply(const T& t, const U& u, T& ret) throw()
     {
         unsigned __int32 tmp;
 
@@ -2574,7 +2647,7 @@ public:
     }
 
     template < typename E >
-    static void MultiplyThrow(const T& t, const __int64& u, T& ret)
+    static void MultiplyThrow(const T& t, const U& u, T& ret)
     {
         unsigned __int32 tmp;
         
@@ -2583,58 +2656,58 @@ public:
     }
 };
 
-template < typename U > class MultiplicationHelper<__int64, U, MultiplicationState_Int64Uint >
+template < typename T, typename U > class MultiplicationHelper<T, U, MultiplicationState_Int64Uint >
 {
 public:
     //U is unsigned up to 32-bit
-    static bool Multiply( const __int64& t, const U& u, __int64& ret ) throw()
+    static bool Multiply( const T& t, const U& u, T& ret ) throw()
     {
         return LargeIntRegMultiply< __int64, unsigned __int32 >::RegMultiply( t, (unsigned __int32)u, ret );
     }
 
     template < typename E >
-    static void MultiplyThrow( const __int64& t, const U& u, __int64& ret )
+    static void MultiplyThrow( const T& t, const U& u, T& ret )
     {
         LargeIntRegMultiply< __int64, unsigned __int32 >::template RegMultiplyThrow< E >(t, (unsigned __int32)u, ret);
     }
 };
 
-template <> class MultiplicationHelper<__int64, __int64, MultiplicationState_Int64Int64 >
+template < typename T, typename U > class MultiplicationHelper<T, U, MultiplicationState_Int64Int64 >
 {
 public:
-    static bool Multiply( const __int64& t, const __int64& u, __int64& ret ) throw()
+    static bool Multiply( const T& t, const U& u, T& ret ) throw()
     {
         return LargeIntRegMultiply< __int64, __int64 >::RegMultiply( t, u, ret );
     }
 
     template < typename E >
-    static void MultiplyThrow( const __int64& t, const __int64& u, __int64& ret )
+    static void MultiplyThrow( const T& t, const U& u, T& ret )
     {
         LargeIntRegMultiply< __int64, __int64 >::template RegMultiplyThrow< E >(t, u, ret);
     }
 };
 
-template < typename U > class MultiplicationHelper<__int64, U, MultiplicationState_Int64Int>
+template < typename T, typename U > class MultiplicationHelper<T, U, MultiplicationState_Int64Int>
 {
 public:
     //U is signed up to 32-bit
-    static bool Multiply( const __int64& t, U u, __int64& ret ) throw()
+    static bool Multiply( const T& t, U u, T& ret ) throw()
     {
         return LargeIntRegMultiply< __int64, __int32 >::RegMultiply( t, (__int32)u, ret );
     }
 
     template < typename E >
-    static void MultiplyThrow( const __int64& t, U u, __int64& ret )
+    static void MultiplyThrow( const T& t, U u, T& ret )
     {
         LargeIntRegMultiply< __int64, __int32 >::template RegMultiplyThrow< E >(t, (__int32)u, ret);
     }
 };
 
-template <typename T> class MultiplicationHelper< T, unsigned __int64, MultiplicationState_IntUint64 >
+template <typename T, typename U> class MultiplicationHelper< T, U, MultiplicationState_IntUint64 >
 {
 public:
     //T is signed up to 32-bit
-    static bool Multiply(T t, const unsigned __int64& u, T& ret) throw()
+    static bool Multiply(T t, const U& u, T& ret) throw()
     {
         __int32 tmp;
 
@@ -2648,7 +2721,7 @@ public:
     }
 
     template < typename E >
-    static void MultiplyThrow(T t, const unsigned __int64& u, T& ret)
+    static void MultiplyThrow(T t, const U& u, T& ret)
     {
         __int32 tmp;
         
@@ -2657,27 +2730,26 @@ public:
     }
 };
 
-template <> class MultiplicationHelper<__int64, unsigned __int64, MultiplicationState_Int64Uint64>
+template < typename T, typename U > class MultiplicationHelper<T, U, MultiplicationState_Int64Uint64>
 {
 public:
-    //U is signed up to 32-bit
-    static bool Multiply( const __int64& t, const unsigned __int64& u, __int64& ret ) throw()
+    static bool Multiply( const T& t, const U& u, T& ret ) throw()
     {
         return LargeIntRegMultiply< __int64, unsigned __int64 >::RegMultiply( t, u, ret );
     }
 
     template < typename E >
-    static void MultiplyThrow( const __int64& t, const unsigned __int64& u, __int64& ret )
+    static void MultiplyThrow( const T& t, const U& u, T& ret )
     {
         LargeIntRegMultiply< __int64, unsigned __int64 >::template RegMultiplyThrow< E >( t, u, ret );
     }
 };
 
-template <typename T> class MultiplicationHelper< T, __int64, MultiplicationState_IntInt64>
+template <typename T, typename U> class MultiplicationHelper< T, U, MultiplicationState_IntInt64>
 {
 public:
     //T is signed, up to 32-bit
-    static bool Multiply( T t, const __int64& u, T& ret ) throw()
+    static bool Multiply( T t, const U& u, T& ret ) throw()
     {
         __int32 tmp;
 
@@ -2691,7 +2763,7 @@ public:
     }
 
     template < typename E >
-    static void MultiplyThrow(T t, const __int64& u, T& ret)
+    static void MultiplyThrow(T t, const U& u, T& ret)
     {
         __int32 tmp;
         
@@ -2874,10 +2946,10 @@ public:
     }
 };
 
-template < typename T > class DivisionHelper< T, unsigned __int64, DivisionState_SignedUnsigned64 >
+template < typename T, typename U > class DivisionHelper< T, U, DivisionState_SignedUnsigned64 >
 {
 public:
-    static SafeIntError Divide( const T& t, const unsigned __int64& u, T& result ) throw()
+    static SafeIntError Divide( const T& t, const U& u, T& result ) throw()
     {
         if( t == 0 )
         {
@@ -2890,7 +2962,7 @@ public:
             return SafeIntDivideByZero;
         }
 
-        if( u <= (unsigned __int64)IntTraits< T >::maxInt )
+        if( u <= (U)IntTraits< T >::maxInt )
         {
             // Else u can safely be cast to T
             if( sizeof( T ) < sizeof( __int64 ) )
@@ -2899,7 +2971,7 @@ public:
                 result = (T)((__int64)t/(__int64)u);
         }
         else // Corner case
-        if( t == IntTraits< T >::minInt && u == (unsigned __int64)IntTraits< T >::minInt )
+        if( t == IntTraits< T >::minInt && u == (U)IntTraits< T >::minInt )
         {
             // Min int divided by it's own magnitude is -1
             result = -1;
@@ -2912,7 +2984,7 @@ public:
     }
 
     template < typename E >
-    static void DivideThrow( const T& t, const unsigned __int64& u, T& result )
+    static void DivideThrow( const T& t, const U& u, T& result )
     {
         if( t == 0 )
         {
@@ -2925,7 +2997,7 @@ public:
             E::SafeIntOnDivZero();
         }
 
-        if( u <= (unsigned __int64)IntTraits< T >::maxInt )
+        if( u <= (U)IntTraits< T >::maxInt )
         {
             // Else u can safely be cast to T
             if( sizeof( T ) < sizeof( __int64 ) )
@@ -2934,7 +3006,7 @@ public:
                 result = (T)((__int64)t/(__int64)u);
         }
         else // Corner case
-        if( t == IntTraits< T >::minInt && u == (unsigned __int64)IntTraits< T >::minInt )
+        if( t == IntTraits< T >::minInt && u == (U)IntTraits< T >::minInt )
         {
             // Min int divided by it's own magnitude is -1
             result = -1;
@@ -3606,13 +3678,13 @@ public:
     }
 };
 
-template < > class AdditionHelper < __int64, unsigned __int64, AdditionState_ManualCheckInt64Uint64 >
+template < typename T, typename U > class AdditionHelper < T, U, AdditionState_ManualCheckInt64Uint64 >
 {
 public:
-    static bool Addition( const __int64& lhs, const unsigned __int64& rhs, __int64& result ) throw()
+    static bool Addition( const T& lhs, const U& rhs, T& result ) throw()
     {
         // rhs is unsigned __int64, lhs __int64
-        __int64 tmp = lhs + (__int64)rhs;
+        T tmp = lhs + (T)rhs;
         
         if( tmp >= lhs )
         {
@@ -3624,10 +3696,10 @@ public:
     }
 
     template < typename E >
-    static void AdditionThrow( const __int64& lhs, const unsigned __int64& rhs, __int64& result )
+    static void AdditionThrow( const T& lhs, const U& rhs, T& result )
     {
         // rhs is unsigned __int64, lhs __int64
-        __int64 tmp = lhs + (__int64)rhs;
+        T tmp = lhs + (T)rhs;
         
         if( tmp >= lhs )
         {
@@ -4119,7 +4191,7 @@ public:
             tmp = lhs + (unsigned __int64)AbsValueHelper< T, GetAbsMethod< T >::method >::Abs( rhs );
 
             // must check for addition overflow and max
-            if( tmp >= lhs && tmp <= IntTraits< T >::maxInt )
+            if( tmp >= lhs && IntTraits<T>::isLessEqualMaxInt(tmp) )
             {
                 result = (T)tmp;
                 return;
@@ -4138,7 +4210,7 @@ public:
             // result is positive
             unsigned __int64 tmp = (unsigned __int64)lhs - (unsigned __int64)rhs;
 
-            if( tmp <= IntTraits< T >::maxInt )
+            if( IntTraits<T>::isLessEqualMaxInt(tmp) )
             {
                 result = (T)tmp;
                 return;
@@ -4718,13 +4790,13 @@ public:
 
 };
 
-template < > class SubtractionHelper< __int64, unsigned __int64, SubtractionState_Int64Uint64 >
+template < typename T, typename U > class SubtractionHelper< T, U, SubtractionState_Int64Uint64 >
 {
 public:
-    static bool Subtract( const __int64& lhs, const unsigned __int64& rhs, __int64& result ) throw()
+    static bool Subtract( const T& lhs, const U& rhs, T& result ) throw()
     {
        // if we subtract, and it gets larger, there's a problem
-       __int64 tmp = lhs - (__int64)rhs;
+       T tmp = lhs - (T)rhs;
 
        if( tmp <= lhs )
        {
@@ -4735,10 +4807,10 @@ public:
     }
 
     template < typename E >
-    static void SubtractThrow( const __int64& lhs, const unsigned __int64& rhs, __int64& result )
+    static void SubtractThrow( const T& lhs, const U& rhs, T& result )
     {
        // if we subtract, and it gets larger, there's a problem
-       __int64 tmp = lhs - (__int64)rhs;
+       T tmp = lhs - (T)rhs;
 
        if( tmp <= lhs )
        {
@@ -4751,16 +4823,16 @@ public:
 
 };
 
-template < > class SubtractionHelper< __int64, unsigned __int64, SubtractionState_Int64Uint642 >
+template <typename U, typename T> class SubtractionHelper< U, T, SubtractionState_Int64Uint642 >
 {
 public:
 	 // If lhs is negative, immediate problem - return must be positive, and subtracting only makes it
 	 // get smaller. If rhs > lhs, then it would also go negative, which is the other case
-    static bool Subtract( const __int64& lhs, const unsigned __int64& rhs, unsigned __int64& result ) throw()
+    static bool Subtract( const U& lhs, const T& rhs, T& result ) throw()
     {
-		 if( lhs >= 0 && (unsigned __int64)lhs >= rhs )
+		 if( lhs >= 0 && (T)lhs >= rhs )
 		 {
-			 result = (unsigned __int64)lhs - rhs;
+			 result = (T)lhs - rhs;
 			 return true;
 		 }
 
@@ -4768,11 +4840,11 @@ public:
     }
 
     template < typename E >
-    static void SubtractThrow( const __int64& lhs, const unsigned __int64& rhs, unsigned __int64& result )
+    static void SubtractThrow( const U& lhs, const T& rhs, T& result )
     {
-		 if( lhs >= 0 && (unsigned __int64)lhs >= rhs )
+		 if( lhs >= 0 && (T)lhs >= rhs )
 		 {
-			 result = (unsigned __int64)lhs - rhs;
+			 result = (T)lhs - rhs;
 			 return;
 		 }
 
@@ -5622,7 +5694,7 @@ public:
     template < typename U > 
     SafeInt< T, E > operator <<( U bits ) const throw()
     {
-        ShiftAssert( !IntTraits< U >::isSigned || bits >= 0 );
+        ShiftAssert( IntTraits< U >::greaterEqualZero(bits)  );
         ShiftAssert( bits < (int)IntTraits< T >::bitCount );
 
         return SafeInt< T, E >( (T)( m_int << bits ) );
@@ -5631,7 +5703,7 @@ public:
     template < typename U > 
     SafeInt< T, E > operator <<( SafeInt< U, E > bits ) const throw()
     {
-        ShiftAssert( !IntTraits< U >::isSigned || (U)bits >= 0 );
+        ShiftAssert( IntTraits< U >::greaterEqualZero((U)bits) );
         ShiftAssert( (U)bits < (int)IntTraits< T >::bitCount );
 
         return SafeInt< T, E >( (T)( m_int << (U)bits ) );
@@ -5642,7 +5714,7 @@ public:
     template < typename U >
     SafeInt< T, E >& operator <<=( U bits ) throw()
     {
-        ShiftAssert( !IntTraits< U >::isSigned || bits >= 0 );
+        ShiftAssert( IntTraits< U >::greaterEqualZero(bits) );
         ShiftAssert( bits < (int)IntTraits< T >::bitCount );
 
         m_int <<= bits;
@@ -5652,7 +5724,7 @@ public:
     template < typename U >
     SafeInt< T, E >& operator <<=( SafeInt< U, E > bits ) throw()
     {
-        ShiftAssert( !IntTraits< U >::isSigned || (U)bits >= 0 );
+        ShiftAssert( IntTraits< U >::greaterEqualZero((U)bits) );
         ShiftAssert( (U)bits < (int)IntTraits< T >::bitCount );
 
         m_int <<= (U)bits;
@@ -5663,7 +5735,7 @@ public:
     template < typename U > 
     SafeInt< T, E > operator >>( U bits ) const throw()
     {
-        ShiftAssert( !IntTraits< U >::isSigned || bits >= 0 );
+        ShiftAssert( IntTraits< U >::greaterEqualZero(bits) );
         ShiftAssert( bits < (int)IntTraits< T >::bitCount );
 
         return SafeInt< T, E >( (T)( m_int >> bits ) );
@@ -5672,7 +5744,7 @@ public:
     template < typename U > 
     SafeInt< T, E > operator >>( SafeInt< U, E > bits ) const throw()
     {
-        ShiftAssert( !IntTraits< U >::isSigned || (U)bits >= 0 );
+        ShiftAssert( IntTraits< U >::greaterEqualZero((U)bits) );
         ShiftAssert( bits < (int)IntTraits< T >::bitCount );
 
         return SafeInt< T, E >( (T)(m_int >> (U)bits) );
@@ -5682,7 +5754,7 @@ public:
     template < typename U >
     SafeInt< T, E >& operator >>=( U bits ) throw()
     {
-        ShiftAssert( !IntTraits< U >::isSigned || bits >= 0 );
+        ShiftAssert( IntTraits< U >::greaterEqualZero(bits) );
         ShiftAssert( bits < (int)IntTraits< T >::bitCount );
 
         m_int >>= bits;
@@ -5692,7 +5764,7 @@ public:
     template < typename U >
     SafeInt< T, E >& operator >>=( SafeInt< U, E > bits ) throw()
     {
-        ShiftAssert( !IntTraits< U >::isSigned || (U)bits >= 0 );
+        ShiftAssert( IntTraits< U >::greaterEqualZero((U)bits) );
         ShiftAssert( (U)bits < (int)IntTraits< T >::bitCount );
 
         m_int >>= (U)bits;
@@ -6058,7 +6130,7 @@ SafeInt< T, E > operator %( U lhs, SafeI
     {
         if( rhs != 0 )
         {
-            if( IntTraits< T >::isSigned && (T)rhs == -1 )
+            if( IntTraits< T >::equalsMinusOne((T)rhs) )
                 return 0;
 
             return SafeInt< T, E >( (T)( lhs % (T)rhs ) );
@@ -6102,12 +6174,14 @@ template < typename T, typename U, typen
                 else
                     tmp = lhs/(U)( -(T)rhs );
 
-                if( tmp <= IntTraits< T >::maxInt )
+                if( IntTraits<T>::isLessEqualMaxInt(tmp) )
                     return SafeInt< T, E >( -( (T)tmp ) );
 
                 // Corner case
+#if !defined SAFEINT_GCC_HPP
 #pragma warning(push)
 #pragma warning(disable:4307)
+#endif
                 // Note - this warning happens because we're not using partial
                 // template specialization in this case. For any real cases where
                 // this block isn't optimized out, the warning won't be present.
@@ -6117,7 +6191,9 @@ template < typename T, typename U, typen
                     T minT = IntTraits< T >::minInt;
                     return SafeInt< T, E >( minT );
                 }
+#if !defined SAFEINT_GCC_HPP
 #pragma warning(pop)
+#endif
 
                 E::SafeIntOnOverflow();
             }
@@ -6130,7 +6206,7 @@ template < typename T, typename U, typen
 
     if( SafeIntCompare< T, U >::isBothSigned )
     {
-        if( lhs == IntTraits< U >::minInt && (T)rhs == -1 )
+        if( lhs == IntTraits< U >::equalsMinusOne((T)rhs) )
         {
             // corner case of a corner case - lhs = min int, rhs = -1, 
             // but rhs is the return type, so in essence, we can return -lhs
@@ -6349,7 +6425,7 @@ T*& operator >>=( T*& lhs, SafeInt< U, E
 template < typename T, typename U, typename E >
 SafeInt< U, E > operator <<( U lhs, SafeInt< T, E > bits ) throw()
 {
-    ShiftAssert( !IntTraits< T >::isSigned || (T)bits >= 0 );
+    ShiftAssert( IntTraits< T >::greaterEqualZero((T)bits) );
     ShiftAssert( (T)bits < (int)IntTraits< U >::bitCount );
 
     return SafeInt< U, E >( (U)( lhs << (T)bits ) );
@@ -6359,7 +6435,7 @@ SafeInt< U, E > operator <<( U lhs, Safe
 template < typename T, typename U, typename E >
 SafeInt< U, E > operator >>( U lhs, SafeInt< T, E > bits ) throw()
 {
-    ShiftAssert( !IntTraits< T >::isSigned || (T)bits >= 0 );
+    ShiftAssert( IntTraits< T >::greaterEqualZero((T)bits) );
     ShiftAssert( (T)bits < (int)IntTraits< U >::bitCount );
 
     return SafeInt< U, E >( (U)( lhs >> (T)bits ) );
@@ -6390,6 +6466,8 @@ SafeInt< T, E > operator |( U lhs, SafeI
     return SafeInt< T, E >( BinaryOrHelper< T, U, BinaryMethod< T, U >::method >::Or( (T)rhs, lhs ) );
 }
 
+#if !defined SAFEINT_GCC_HPP
 #pragma warning(pop)
+#endif
 
 #endif //SAFEINT_HPP
diff -Naurp safe_int.orig/.SafeInt3.hpp.swp safe_int/.SafeInt3.hpp.swp
--- safe_int.orig/.SafeInt3.hpp.swp	1969-12-31 19:00:00.000000000 -0500
+++ safe_int/.SafeInt3.hpp.swp	2010-01-12 19:38:48.000000000 -0500
@@ -0,0 +1,517 @@
+b0VIM 7.1      MK,‡Éﬂ  bmb                                     paco                                    ~bmb/safe_int/SafeInt3.hpp                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   utf-8 3210    #"! U                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 tp<           E                     $       >       F              %       i       Ñ              &       T       Ì              '       D       A             (       T       Ö             )       y       Ÿ             2       D       R             1       a       ñ             0       :       ˜             /       ã       1             .       å       º             -       ç       H             ,       k       ’             +       ã       @             *       T       À             3       g                    4       ~       Ü             5       á                    6       Ç       ã             7       |                    8       É       â             9       á       	                    m       ì	                            
+             <              
+             =       _       
+             ;       r       u
+             :       Ö       Á
+                    å       l                    f       ¯                    u       ^             	       Ç       ”             
+       }       U                    }       “                    |       O                    B       À                    f                           l       s                    y       ﬂ                    z       X                    r       “                    n       D                    à       ≤                    Å       :                    ã       ª                    w       F                    u       Ω                    w       2                    y       ©                    a       "                    n       É                    {       Ò                    p       l                    {       ‹                     q       W             !       o       »             "       s       7             #       r       ™                    :                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ad  o   ü     E       í  Ü  v  u  /  Í  ∏  ∑  M        õ  3  –  s  r  b  ı  å  !  ¯
+  ˜
+  ä
+  
+  ±	  h	  g	  L	  Â  —  g  
+  †  e  ˜  à    •  4  ƒ  x  w  v  ;  :  ˜  ›  ‹  ™  ©  p  o  c  !    ˘  ¯  ‰  „  “  ö  ì  í      ≤  ±  ü  û                                                                                                                 Compiler options:  SafeInt supports several compile-time options that can change the behavior of the class.  /************* Compiler Options *****************************************************************************************************  #endif #define C_ASSERT(e) typedef char __C_ASSERT__[(e)?1:-1] #ifndef C_ASSERT  #include <assert.h>  #define SAFEINT_HPP #ifndef SAFEINT_HPP ---------------------------------------------------------------*/ Version 3.0  Please read the leading comments before using the class.  This header compiles properly at warning level 4.  unsafe integer operations This header implements an integer handling class designed to catch  Copyright (c) Microsoft Corporation.  All rights reserved.   	of merchantability, fitness for a particular purpose and non-infringement. 	cannot change. To the extent permitted under your local laws, the contributors exclude the implied warranties      guarantees, or conditions. You may have additional consumer rights under your local laws which this license  (E) The software is licensed "as-is." You bear the risk of using it. The contributors give no express warranties,  	software in compiled or object code form, you may only do so under a license that complies with this license.      by including a complete copy of this license with your distribution. If you distribute any portion of the  (D) If you distribute any portion of the software in source code form, you may do so only under this license      attribution notices that are present in the software.  (C) If you distribute any portion of the software, you must retain all copyright, patent, trademark, and      software, your patent license from such contributor to the software ends automatically.  (B) If you bring a patent claim against any contributor over patents that you claim are infringed by the      or trademarks.  (A) No Trademark License- This license does not grant you rights to use any contributors' name, logo,  Conditions and Limitations  in the software or derivative works of the contribution in the software. patents to make, have made, use, sell, offer for sale, import, and/or otherwise dispose of its contribution  section 3, each contributor grants you a non-exclusive, worldwide, royalty-free license under its licensed  (B) Patent Grant- Subject to the terms of this license, including the license conditions and limitations in   or any derivative works that you create. reproduce its contribution, prepare derivative works of its contribution, and distribute its contribution  in section 3, each contributor grants you a non-exclusive, worldwide, royalty-free copyright license to  (A) Copyright Grant- Subject to the terms of this license, including the license conditions and limitations  Grant of Rights  "Licensed patents" are a contributor's patent claims that read directly on its contribution. the software. A "contributor" is any person that distributes its contribution under this license.  as under U.S. copyright law. A "contribution" is the original software, or any additions or changes to  The terms "reproduce," "reproduction," "derivative works," and "distribution" have the same meaning here  Definitions  If you do not accept the license, do not use the software. This license governs use of the accompanying software. If you use the software, you accept this license.   http://www.microsoft.com/opensource/licenses.mspx For more information about Microsoft open source licenses, refer to  This software is licensed under the Microsoft Public License (Ms-PL).  Version 3.0.12p SafeInt.hpp /*----------------------------------------------------------------------------------------------------------- ad  #  '	     :       “  ≤  ô  ó  ñ  É  >  =  /  ˇ  º  ∫  |  @  ?  
+      ¯  »  Ö  É  E  	    ”  —  –  ª  u  ;  :  -  ˝  º  ∫  Q  O  N  ?    Œ
+  Ã
+  d
+  b
+  a
+  S
+  #
+  ‚	  ‡	  y	  w	  v	  Y	  D	  =	  <	  '	  &	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     #endif //SAFEINT_HPP  #endif #pragma warning(pop) #if !defined SAFEINT_GCC_HPP  }     return SafeInt< T, E >( BinaryOrHelper< T, U, BinaryMethod< T, U >::method >::Or( (T)rhs, lhs ) ); { SafeInt< T, E > operator |( U lhs, SafeInt< T, E > rhs ) throw() template < typename T, typename U, typename E > // Bitwise OR  }     return SafeInt< T, E >(BinaryXorHelper< T, U, BinaryMethod< T, U >::method >::Xor( (T)rhs, lhs ) ); { SafeInt< T, E > operator ^( U lhs, SafeInt< T, E > rhs ) throw() template < typename T, typename U, typename E > // Bitwise XOR  }     return SafeInt< T, E >( BinaryAndHelper< T, U, BinaryMethod< T, U >::method >::And( (T)rhs, lhs ) ); { SafeInt< T, E > operator &( U lhs, SafeInt< T, E > rhs ) throw() template < typename T, typename U, typename E > // Bitwise &  // demand a type T, or something that fits into a type T. // This only makes sense if we're dealing with the same type and size // Bitwise operators  }     return SafeInt< U, E >( (U)( lhs >> (T)bits ) );      ShiftAssert( (T)bits < (int)IntTraits< U >::bitCount );     ShiftAssert( IntTraits< T >::greaterEqualZero((T)bits) ); { SafeInt< U, E > operator >>( U lhs, SafeInt< T, E > bits ) throw() template < typename T, typename U, typename E > // Right shift  }     return SafeInt< U, E >( (U)( lhs << (T)bits ) );      ShiftAssert( (T)bits < (int)IntTraits< U >::bitCount );     ShiftAssert( IntTraits< T >::greaterEqualZero((T)bits) ); { SafeInt< U, E > operator <<( U lhs, SafeInt< T, E > bits ) throw() template < typename T, typename U, typename E > // Left shift  // NOTE - shift operators always return the type of the lhs argument // Shift operators  }     return (lhs = NULL);     C_ASSERT( sizeof(T) == 0 );     // This operator explicitly not supported ad  i  ≈            ˙  ˘  ›  ü  ô  )  #       π  ∑  Ø  Ñ  A  ;  ≈  º  ö  v  L  A    Ã  π  ¶  ú  ñ                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                bool              bo        bool               bool boolre        bool boolret =         bool boolret = LargeIntRegMultiply< unsigned __        ret = ret64        ret                            return LargeIntRegMultiply< u             return LargeIntR        retu                      return Large        r        return LargeIntRegMultiply< unsigned __int64, unsigned __int32 >::RegMultiply( t, (unsigned __int32)u, ret );     {     static bool Multiply( const T& t, const U& u, T& ret ) throw()     //U is any unsigned int 32-bit or less public: { template < typename T, typename U > class MultiplicationHelper<T, U, MultiplicationState_Uint64Uint >  };     }         LargeIntRegMultiply< unsigned __int64, unsigned __int64 >::template RegMultiplyThrow< E >( t, u, ret );     {     static void MultiplyThrow(const T& t, const U& u, T& ret)     template < typename E >      } ad    ‘     m       ±  £  w  _  Q  G  :  0  	  ∫  ¨  Å  i  [  Q  P  0  *  '  &  ›  €  ”  ´  e  _  ?  >         Ú  Ë     ¥  ™  ©  "    ›  ¡  ≥  à  5  #  Ò
+  –
+  æ
+  ∞
+  ü
+  ë
+  f
+  
+  
+  “	  ±	  ü	  ë	  á	  Ü	  p	  j	  i	  5	  Ú  Ï  Ã  Æ  ñ  ï  Ä  v  X  B  8  7  ∞  ¶  k  O  A    √  ±    c  Q  C  2  $  ˘  ¶  î  e  I  7  )      ˛  ¯  ı  Ù  ã  â  Å  >  8  ‘  ¥  £  é  s  m  ˝  ˜  Ù  Û  ç  ã  É  X                 {     static bool Multiply( const T& t, const U& u, T& ret ) throw()     //U is any unsigned int 32-bit or less public: { template < typename T, typename U > class MultiplicationHelper<T, U, MultiplicationState_Uint64Uint >  };     }         LargeIntRegMultiply< unsigned __int64, unsigned __int64 >::template RegMultiplyThrow< E >( t, u, ret );     {     static void MultiplyThr                 ret                          return LargeIntRegMultip        return LargeIntRegMultiply< unsigned __int64, unsigned __int64 >::RegMultiply( t, u, ret );     {     static bool Multiply( const T& t, const U& u, T& ret ) throw() public: { template < typename T, typename U > class MultiplicationHelper< T, U, MultiplicationState_Uint64Uint64 >  };     }         E::SafeIntOnOverflow();          }             }                 }                     return;                     ret = (signed __int64)tmp;                 {                 if( tmp <= (unsigned __int64)IntTraits< signed __int64 >::maxInt )                 // Result must be positive             {             else             }                 }                     return;                     ret = -((signed __int64)tmp);                 {                 if( tmp <= (unsigned __int64)IntTraits< signed __int64 >::minInt )                 // Result must be negative             {             if( aNegative )             // The unsigned multiplication didn't overflow         {         if( LargeIntRegMultiply< unsigned __int64, unsigned __int64 >::RegMultiply( (unsigned __int64)a1, (unsigned __int64)b, tmp ) )          }             a1 = -a1;             aNegative = true;         {         if( a1 < 0 )          __int64 a1 = a;         unsigned __int64 tmp;         bool aNegative = false;     {     static void RegMultiplyThrow( const T& a, const U& b, T& ret )     template < typename E, typename T, typename U >      }         return false;          }             }                 }                     return true;                     ret = (signed __int64)tmp;                 {                 if( tmp <= (unsigned __int64)IntTraits< signed __int64 >::maxInt )                 // Result must be positive             {             else             }                 }                     return true;                     ret = -((signed __int64)tmp);                 {                 if( tmp <= (unsigned __int64)IntTraits< signed __int64 >::minInt )                 // Result must be negative             {             if( aNegative )             // The unsigned multiplication didn't overflow         {         if( LargeIntRegMultiply< unsigned __int64, unsigned __int64 >::RegMultiply( (unsigned __int64)a1, (unsigned __int64)b, tmp ) )          }             a1 = -a1;             aNegative = true;         {         if( a1 < 0 )          __int64 a1 = a;         unsigned __int64 tmp;          bool aNegative = false;     {     static bool RegMultiply( const T& a, const U& b, T& ret ) throw()     template < typename T, typename U > public: { template<> class LargeIntRegMultiply< signed __int64, unsigned __int64 >  };     }         E::SafeIntOnOverflow();          }             }                 return;                 ret = (signed __int32)tmp;             {             if( tmp <= (unsigned __int32)IntTraits< signed __int32 >::maxInt )             // Result must be positive         {         else         }             }                 return;                 ret = -(signed __int32)tmp;             {             if( tmp <= (unsigned __int32)IntTraits< signed __int32 >::minInt ) ad     Z     å       Â  ä         Í  ›  ™  ©  ä  Ñ  É  g  &         Í  ◊  Õ  Ã  ∑  ≠  ä  Ä    d  	  ü  û  ä  i  \  )  #       æ  º  ¥  h  b  M  C  ,  
+     ˇ
+  Í
+  ‡
+  ∏
+  Æ
+  ≠
+  Ä
+  v
+  H
+  
+  Á	  ÷	  °	  ó	  {	  /	  %	  Í  —  «  ∫  ∞  ò  é  o  i  h  L        Ê  œ  º  ≤  ±  ú  í  o  e  d  7  -  ˇ  Õ  û  ç  X  N  2  Ê  ‹  °  à  ~  q  g  O  E  ?  <  ;  ›  €  ”  ï  [    	  Ù  Í  ”  ±  ß  ¶  ë  á  _  U  T  7        ı  ¥  Æ  ô  è  x  e  [  Z  Y                         }            return;            result = 0;         {         if( t == 0 )     {     static void DivideThrow( const T& t, const U& u, T& result )     template < typename E >      }         return SafeIntNoError;         result = (T)( t/u );          }             return SafeIntDivideByZero;         {         if( u == 0 )          }            return SafeIntNoError;            result = 0;         {         if( t == 0 )     {     static SafeIntError Divide( const T& t, const U& u, T& result ) throw()     // In this case, standard operator casting is correct     // T is any signed, U is unsigned and smaller than 32-bit public: { template < typename T, typename U > class DivisionHelper< T, U, DivisionState_SignedUnsigned>  };     }         }             result = 0;         {         else         }             result = -1;             // Min int divided by it's own magnitude is -1         {         if( t == IntTraits< T >::minInt && u == (U)IntTraits< T >::minInt )         else // Corner case         }                 result = (T)((__int64)t/(__int64)u);             else                 result = (T)( (int)t/(int)u );             if( sizeof( T ) < sizeof( __int64 ) )             // Else u can safely be cast to T         {         if( u <= (U)IntTraits< T >::maxInt )          }             E::SafeIntOnDivZero();         {         if( u == 0 )          }            return;            result = 0;         {         if( t == 0 )     {     static void DivideThrow( const T& t, const U& u, T& result )     template < typename E >      }         return SafeIntNoError;         }             result = 0;         {         else         }             result = -1;             // Min int divided by it's own magnitude is -1         {         if( t == IntTraits< T >::minInt && u == (U)IntTraits< T >::minInt )         else // Corner case         }                 result = (T)((__int64)t/(__int64)u);             else                 result = (T)( (int)t/(int)u );             if( sizeof( T ) < sizeof( __int64 ) )             // Else u can safely be cast to T         {         if( u <= (U)IntTraits< T >::maxInt )          }             return SafeIntDivideByZero;         {         if( u == 0 )          }            return SafeIntNoError;            result = 0;         {         if( t == 0 )     {     static SafeIntError Divide( const T& t, const U& u, T& result ) throw() public: { template < typename T, typename U > class DivisionHelper< T, U, DivisionState_SignedUnsigned64 >  };     }             result = (T)( (__int64)t/(__int64)u );         else             result = (T)( t/u );         if( t > 0 )          // As it turns out, 32-bit division is about twice as fast, which justifies the extra conditional         // If t < 0, must explicitly upcast, or implicit upcast to ulong will cause errors         // Test for t > 0           }             E::SafeIntOnDivZero();         {         if( u == 0 )          }            return;            result = 0;         {         if( t == 0 )     {     static void DivideThrow( const T& t, const U& u, T& result )     template < typename E >      }         return SafeIntNoError;              result = (T)( (__int64)t/(__int64)u );         else             result = (T)( t/u );         if( t > 0 )          // As it turns out, 32-bit division is about twice as fast, which justifies the extra conditional         // If t < 0, must explicitly upcast, or implicit upcast to ulong will cause errors         // Test for t > 0  ad  T        f       Î  ·  æ  ¥  ≥  ñ  ê  ç  å  0  .  &  ⁄  ‘  ø  µ  û  |  r  q  \  R  *       ˙  ≈  ó  ñ  y  Z  T  S  7  ˆ    €  —  ∫  ß  ù  ú  â    \  R  Q  ,  ˜  ”  “  µ  Ø  ¨  ´  ò  ñ  s  J    Û
+  ≈
+  ü
+  w
+  R
+  )
+  ˇ	  ’	  •	  x	  N	  /	  	  	  	    €  Ÿ  —  »  ¬  ù  <  ’  k    ñ  s    —  k  1     b  A  ›  †  :    ô  +                                                                                                           //signed-unsigned                  (IntRegion< T,U >::IntZone_IntLT64_Int64)     ? AdditionState_CastInt64CheckOverflowMinMax :                   IntRegion< T,U >::IntZone_Int64_Int64)       ? AdditionState_CastInt64CheckOverflow :                  (IntRegion< T,U >::IntZone_Int64_Int ||                   IntRegion< T,U >::IntZone_IntLT32_Int32)     ? AdditionState_CastInt64CheckMinMax :                  (IntRegion< T,U >::IntZone_Int32_IntLT64 ||                  (IntRegion< T,U >::IntZone_IntLT32_IntLT32)   ? AdditionState_CastIntCheckMinMax :                  //signed-signed                  (IntRegion< T,U >::IntZone_UintLT64_Int64)    ? AdditionState_CastUint64CheckMinMax2 :                   IntRegion< T,U >::IntZone_Uint64_Int64)      ? AdditionState_CastUint64CheckMinMax :                  (IntRegion< T,U >::IntZone_Uint64_Int ||                   IntRegion< T,U >::IntZone_UintLT32_Int32)    ? AdditionState_CastInt64CheckMinMax :                  (IntRegion< T,U >::IntZone_Uint32_IntLT64 ||                  (IntRegion< T,U >::IntZone_UintLT32_IntLT32)  ? AdditionState_CastIntCheckMinMax :                  //unsigned-signed                  (IntRegion< T,U >::IntZone_UintLT64_Uint64)   ? AdditionState_CastUint64CheckOverflowMax :                  (IntRegion< T,U >::IntZone_Uint64_Uint)       ? AdditionState_CastUint64CheckOverflow :                  (IntRegion< T,U >::IntZone_UintLT32_Uint32)   ? AdditionState_CastUintCheckOverflowMax :                  (IntRegion< T,U >::IntZone_Uint32_UintLT64)   ? AdditionState_CastUintCheckOverflow :         method = (IntRegion< T,U >::IntZone_UintLT32_UintLT32  ? AdditionState_CastIntCheckMax :                  //unsigned-unsigned     {     enum public: { class AdditionMethod template< typename T, typename U >  };     AdditionState_Error     AdditionState_ManualCheck,     AdditionState_ManualCheckInt64Uint64,     AdditionState_CastInt64CheckOverflowMax,     AdditionState_CastInt64CheckOverflowMinMax,     AdditionState_CastInt64CheckOverflow,     AdditionState_CastUint64CheckMinMax2,     AdditionState_CastUint64CheckMinMax,     AdditionState_CastInt64CheckMax,     AdditionState_CastInt64CheckMinMax,     AdditionState_CastIntCheckMinMax,     AdditionState_CastUint64CheckOverflowMax,     AdditionState_CastUint64CheckOverflow,     AdditionState_CastUintCheckOverflowMax,     AdditionState_CastUintCheckOverflow,     AdditionState_CastIntCheckMax, { enum AdditionState  };     }         result = (T)( t/u );              E::SafeIntOnOverflow();         if( t == IntTraits< T >::minInt && u == -1 )         // Must test for corner case          }             E::SafeIntOnDivZero();         {         if(u == 0)          }            return;            result = 0;         {         if( t == 0 )     {     static void DivideThrow( const T& t, const U& u, T& result )     template < typename E >      }         return SafeIntNoError;         result = (T)( t/u );              return SafeIntArithmeticOverflow;         if( t == IntTraits< T >::minInt && u == -1 )         // Must test for corner case          }             return SafeIntDivideByZero;         {         if( u == 0 )          }            return SafeIntNoError;            result = 0;         {         if( t == 0 )     {     static SafeIntError Divide( const T& t, const U& u, T& result ) throw() public: { template < typename T, typename U > class DivisionHelper< T, U, DivisionState_SignedSigned>  };     }         result = (T)( t/u );          }             E::SafeIntOnDivZero();         {         if( u == 0 ) ad     ¯     u       ü  a  ˛  ì  +  Œ  ß  †  ù  ú  V  U  Ù  Ú  Í  †  ö  o  N  M      Ò  ÿ  Œ  Õ  ∑  ±  ∞  î  M  G    ˚
+  ˙
+  ≈
+  ª
+  û
+  ä
+  Ä
+  
+  _
+  Y
+  V
+  U
+  Ó	  Ï	  ‰	  ö	  î	  f	  	  	  Ò  ÿ  Œ  ±  ò  é  p  j  i  M       “  Ñ  É  ]  D  :    	  ˇ  ﬂ  Ÿ  ÷  ’  l  j  b      ‰  ñ  ï  V      ı  ‹  “  º  ∂  µ  ô  R  L    —  –  ë  W  M  0      Ú  Ï  È  Ë  Ä  ~  v  ,  &  ¯  ˜                  // lhs unsigned __int64, rhs unsigned     {     static bool Addition( const T& lhs, const U& rhs, T& result ) throw() public: { template < typename T, typename U > class AdditionHelper < T, U, AdditionState_CastUint64CheckOverflow>  };     }         E::SafeIntOnOverflow();         }             return;             result = (T)tmp;         {         if( tmp >= lhs && tmp <= IntTraits< T >::maxInt )         // We added and it didn't get smaller or exceed maxInt          unsigned __int32 tmp = (unsigned __int32)lhs + (unsigned __int32)rhs;         //32-bit or less - both are unsigned     {     static void AdditionThrow( const T& lhs, const U& rhs, T& result )     template < typename E >      }         return false;         }             return true;             result = (T)tmp;         {         if( tmp >= lhs && tmp <= IntTraits< T >::maxInt )         // We added and it didn't get smaller or exceed maxInt          unsigned __int32 tmp = (unsigned __int32)lhs + (unsigned __int32)rhs;         // 32-bit or less - both are unsigned     {     static bool Addition( const T& lhs, const U& rhs, T& result ) throw() public: { template < typename T, typename U > class AdditionHelper < T, U, AdditionState_CastUintCheckOverflowMax>  };     }         E::SafeIntOnOverflow();         }             return;             result = (T)tmp;         {         if( tmp >= lhs )         //we added didn't get smaller          unsigned __int32 tmp = (unsigned __int32)lhs + (unsigned __int32)rhs;         // 32-bit or less - both are unsigned     {     static void AdditionThrow( const T& lhs, const U& rhs, T& result )     template < typename E >      }         return false;                 }             return true;             result = (T)tmp;         {         if( tmp >= lhs )         //we added didn't get smaller          unsigned __int32 tmp = (unsigned __int32)lhs + (unsigned __int32)rhs;         // 32-bit or less - both are unsigned     {     static bool Addition( const T& lhs, const U& rhs, T& result ) throw() public: { template < typename T, typename U > class AdditionHelper < T, U, AdditionState_CastUintCheckOverflow >  };     }         E::SafeIntOnOverflow();          }             return;             result = (T)tmp;         {         if( tmp <= (__int32)IntTraits< T >::maxInt )          __int32 tmp = lhs + rhs;         //16-bit or less unsigned addition     {     static void AdditionThrow( const T& lhs, const U& rhs, T& result )     template < typename E >      }         return false;          }             return true;             result = (T)tmp;         {         if( tmp <= (__int32)IntTraits< T >::maxInt )          __int32 tmp = lhs + rhs;         //16-bit or less unsigned addition     {     static bool Addition( const T& lhs, const U& rhs, T& result ) throw() public: { template < typename T, typename U > class AdditionHelper < T, U, AdditionState_CastIntCheckMax >  template < typename T, typename U, int method > class AdditionHelper;  };     };                   AdditionState_Error)                  (IntRegion< T,U >::IntZone_Int_Uint64)        ? AdditionState_ManualCheck :                  (IntRegion< T,U >::IntZone_Int64_Uint64)      ? AdditionState_ManualCheckInt64Uint64 :                  (IntRegion< T,U >::IntZone_Int64_UintLT64)    ? AdditionState_CastInt64CheckOverflowMax :                   IntRegion< T,U >::IntZone_IntLT64_Uint32)    ? AdditionState_CastInt64CheckMax :                  (IntRegion< T,U >::IntZone_Int32_UintLT32 ||                  (IntRegion< T,U >::IntZone_IntLT32_UintLT32)  ? AdditionState_CastIntCheckMax : ad  b   Ü     Ç       ≤  ±  É  l  b  E  ,  "      ˝  ¸  ‡  ô  ì  e      Ë  —  «  ™  ñ  å  É  c  ]  Z  Y  Ì  Î  „  ô  ì  f      È  Ø  •  à  o  e  d  N  H  G  +  ‰
+  ﬁ
+  ±
+  c
+  b
+  4
+  ˙	  	  ”	  ø	  µ	  ¥	  î	  é	  ã	  ä	  &	  $	  	  “  Ã  ô  x  w      Ò  ÿ  Œ  Õ  ∑  ±  ∞  î  M  G    Û  Ú  ì  â  l  X  N  M  -  '  $  #  Ω  ª  ≥  i  c  0  ˝  ¸  ù  ì  v  ]  S  J  4  .  -       ƒ  ë  ^  ]  ˛  Ù  ◊  √  π  ∞  ê  ä  á  Ü  Ö                                                                                                     };     }         E::SafeIntOnOverflow();                  }             return;             result = (T)tmp;         {         if( tmp <= (__int64)IntTraits< T >::maxInt && tmp >= (__int64)IntTraits< T >::minInt )          __int64 tmp = (__int64)lhs + (__int64)rhs;         // 32-bit or less - one or both are signed     {     static void AdditionThrow( const T& lhs, const U& rhs, T& result )     template < typename E >      }         return false;                  }             return true;             result = (T)tmp;         {         if( tmp <= (__int64)IntTraits< T >::maxInt && tmp >= (__int64)IntTraits< T >::minInt )          __int64 tmp = (__int64)lhs + (__int64)rhs;         // 32-bit or less - one or both are signed     {     static bool Addition( const T& lhs, const U& rhs, T& result ) throw() public: { template < typename T, typename U > class AdditionHelper < T, U, AdditionState_CastInt64CheckMinMax >  };     }         E::SafeIntOnOverflow();          }             return;             result = (T)tmp;         {         if( tmp <= (__int32)IntTraits< T >::maxInt && tmp >= (__int32)IntTraits< T >::minInt )          __int32 tmp = lhs + rhs;         // 16-bit or less - one or both are signed     {     static void AdditionThrow( const T& lhs, const U& rhs, T& result )     template < typename E >      }         return false;          }             return true;             result = (T)tmp;         {         if( tmp <= (__int32)IntTraits< T >::maxInt && tmp >= (__int32)IntTraits< T >::minInt )          __int32 tmp = lhs + rhs;         // 16-bit or less - one or both are signed     {     static bool Addition( const T& lhs, const U& rhs, T& result ) throw() public: { template < typename T, typename U > class AdditionHelper < T, U, AdditionState_CastIntCheckMinMax >  };     }         E::SafeIntOnOverflow();          }             return;             result = (T)tmp;         {         if( tmp >= lhs && tmp <= IntTraits< T >::maxInt )         // We added and it didn't get smaller          unsigned __int64 tmp = (unsigned __int64)lhs + (unsigned __int64)rhs;         //lhs unsigned __int64, rhs unsigned     {     static void AdditionThrow( const T& lhs, const U& rhs, T& result )     template < typename E >      }         return false;          }             return true;             result = (T)tmp;         {         if( tmp >= lhs && tmp <= IntTraits< T >::maxInt )         // We added and it didn't get smaller          unsigned __int64 tmp = (unsigned __int64)lhs + (unsigned __int64)rhs;         //lhs unsigned __int64, rhs unsigned     {     static bool Addition( const T& lhs, const U& rhs, T& result ) throw() public: { template < typename T, typename U > class AdditionHelper < T, U, AdditionState_CastUint64CheckOverflowMax >  };     }         E::SafeIntOnOverflow();                  }             return;             result = (T)tmp;         {         if(tmp >= lhs)         // We added and it didn't get smaller          unsigned __int64 tmp = (unsigned __int64)lhs + (unsigned __int64)rhs;         // lhs unsigned __int64, rhs unsigned     {     static void AdditionThrow( const T& lhs, const U& rhs, T& result )     template < typename E >      }         return false;                  }             return true;             result = (T)tmp;         {         if(tmp >= lhs)         // We added and it didn't get smaller          unsigned __int64 tmp = (unsigned __int64)lhs + (unsigned __int64)rhs; ad     %     }       ù  õ  ì  I  C    €  ⁄  Æ  §  á  n  d  c  M  G  F  *  „  ›  ®  u  t  H  >  !        ‚  ‹  Ÿ  ÿ  q  o  g      Ë     …  ≥  ©  y  +  *    ˇ
+  €
+  æ
+  ∞
+  ¶
+  ô
+  è
+  ?
+  ˛	  ˝	  «	  ™	  ú	  {	  ^	  P	  F	  E	  /	  )	  (	  	  ≈  ø  ê  r  q  [  Q  !  ”  “  µ  ß  É  k  ]  S  F  <  Ï  ´  ™  t  W  I  (      ¯  ˜  ◊  —  Œ  Õ  f  d  \      –  ∫  ∞  U  G    ˇ  Ò  Á  ⁄  –  Ä  .  -  º  c  3  %  $                                   {             if( tmp <= IntTraits< T >::maxInt )             // it is not possible for the operation above to overflow, so just check max             // special case - rhs cannot be larger than 0x7fffffffffffffff, lhs cannot be larger than 0xffffffff              unsigned __int64 tmp = (unsigned __int64)lhs + (unsigned __int64)rhs;             // now we know that rhs can be safely cast into an unsigned __int64         {         else         }             }                 return true;                 result = (T)( lhs + rhs );             {             if( lhs >= (unsigned __int64)( -rhs ) )//negation is safe, since rhs is 64-bit         {         if( rhs < 0 )         // lhs is unsigned and < 64-bit, rhs signed __int64     {     static bool Addition( const T& lhs, const U& rhs, T& result ) throw() public: { template < typename T, typename U > class AdditionHelper < T, U, AdditionState_CastUint64CheckMinMax2>  };     }         E::SafeIntOnOverflow();          }             }                 return;                 result = (T)tmp;             {             if( tmp >= lhs )             // We added and it did not become smaller              tmp = (unsigned __int64)lhs + (unsigned __int64)rhs;             // now we know that rhs can be safely cast into an unsigned __int64         {         else         }             }                 return;                 result = lhs - tmp;             {             if( tmp <= lhs )              tmp = AbsValueHelper< U, GetAbsMethod< U >::method >::Abs( rhs );             // So we're effectively subtracting         {         if( rhs < 0 )          unsigned __int64 tmp;         // lhs is unsigned __int64, rhs signed     {     static void AdditionThrow( const T& lhs, const U& rhs, T& result )     template < typename E >      }         return false;          }             }                 return true;                 result = (T)tmp;             {             if( tmp >= lhs )             // We added and it did not become smaller              tmp = (unsigned __int64)lhs + (unsigned __int64)rhs;             // now we know that rhs can be safely cast into an unsigned __int64         {         else         }             }                 return true;                 result = lhs - tmp;             {             if( tmp <= lhs )              tmp = AbsValueHelper< U, GetAbsMethod< U >::method >::Abs( rhs );             // So we're effectively subtracting         {         if( rhs < 0 )          unsigned __int64 tmp;         // lhs is unsigned __int64, rhs signed     {     static bool Addition( const T& lhs, const U& rhs, T& result ) throw() public: { template < typename T, typename U > class AdditionHelper < T, U, AdditionState_CastUint64CheckMinMax >  };     }         E::SafeIntOnOverflow();          }             return;             result = (T)tmp;         {         if( tmp <= IntTraits< T >::maxInt )          __int64 tmp = (__int64)lhs + (__int64)rhs;         // 32-bit or less - lhs signed, rhs unsigned     {     static void AdditionThrow( const T& lhs, const U& rhs, T& result )     template < typename E >      }         return false;          }             return true;             result = (T)tmp;         {         if( tmp <= IntTraits< T >::maxInt )          __int64 tmp = (__int64)lhs + (__int64)rhs;         // 32-bit or less - lhs signed, rhs unsigned     {     static bool Addition( const T& lhs, const U& rhs, T& result ) throw() public: { template < typename T, typename U > class AdditionHelper < T, U, AdditionState_CastInt64CheckMax > ad  I   Y     }       ﬂ  ¬  ¥  ™  î  é  ç  q  *  $  Ë  “  »  m  _  4        ˜  Ì  ù  K  J  Ÿ  Ä  P  B  !  	  ˚  Ò  —  À  »  «  `  ^  V      Ÿ
+  ¶
+  •
+  é
+  Ñ
+  Z
+  2
+  
+  
+
+  ˝	  Û	  ◊	  ∞	  í	  à	  á	  n	  Y	  S	  N	  2	  Î  Â  ∏  Ö  Ñ  m  c  9    È  ﬂ  “  »  ¨  Ö  ]  S  R  9  3  0  /  ¬  ¿  ∏  n  h  <  '    ô  l  @  6       ˆ  ı  ﬂ  Ÿ  ÿ  º  u  o  C  .  %  ú  ñ  i  =  3      ¯  ˜  ◊  —  Œ  Õ  c  a  Y  X                                                                           public: { template < typename T, typename U > class AdditionHelper < T, U, AdditionState_CastInt64CheckOverflowMax>  };     }         E::SafeIntOnOverflow();          }             return;             result = (T)tmp;         {             tmp >= IntTraits< T >::minInt )         if( tmp <= IntTraits< T >::maxInt &&               AdditionHelper< __int64, __int64, AdditionState_CastInt64CheckOverflow >::AdditionThrow< E >( (__int64)lhs, (__int64)rhs, tmp );                  __int64 tmp;         //rhs is signed __int64, lhs signed     {     static void AdditionThrow( const T& lhs, const U& rhs, T& result )     template < typename E >      }         return false;          }             return true;             result = (T)tmp;         {             tmp >= IntTraits< T >::minInt )             tmp <= IntTraits< T >::maxInt &&         if( AdditionHelper< __int64, __int64, AdditionState_CastInt64CheckOverflow >::Addition( (__int64)lhs, (__int64)rhs, tmp ) &&                  __int64 tmp;         //rhs is signed __int64, lhs signed     {     static bool Addition( const T& lhs, const U& rhs, T& result ) throw() public: { template < typename T, typename U > class AdditionHelper < T, U, AdditionState_CastInt64CheckOverflowMinMax>  };     }         result = (T)tmp;          }                 E::SafeIntOnOverflow();             if( rhs < 0 && tmp > lhs )             // lhs negative         {         else         }                 E::SafeIntOnOverflow();             if( rhs >= 0 && tmp < lhs )             // mixed sign cannot overflow         {         if( lhs >= 0 )          __int64 tmp = (__int64)lhs + (__int64)rhs;         // lhs is signed __int64, rhs signed     {     static void AdditionThrow( const T& lhs, const U& rhs, T& result )     template < typename E >          }         return true;         result = (T)tmp;          }                 return false;             if( rhs < 0 && tmp > lhs )             // lhs negative         {         else         }                 return false;             if( rhs >= 0 && tmp < lhs )             // mixed sign cannot overflow         {         if( lhs >= 0 )          __int64 tmp = (__int64)lhs + (__int64)rhs;         // lhs is signed __int64, rhs signed     {     static bool Addition( const T& lhs, const U& rhs, T& result ) throw() public: { template < typename T, typename U > class AdditionHelper < T, U, AdditionState_CastInt64CheckOverflow>  };     }         E::SafeIntOnOverflow();         }             }                 return;                 result = (T)tmp;             {             if( tmp <= IntTraits< T >::maxInt )             // it is not possible for the operation above to overflow, so just check max             // special case - rhs cannot be larger than 0x7fffffffffffffff, lhs cannot be larger than 0xffffffff              unsigned __int64 tmp = (unsigned __int64)lhs + (unsigned __int64)rhs;             // now we know that rhs can be safely cast into an unsigned __int64         {         else         }             }                 return;                 result = (T)( lhs + rhs );             {             if( lhs >= (unsigned __int64)( -rhs ) )//negation is safe, since rhs is 64-bit         {         if( rhs < 0 )         // lhs is unsigned and < 64-bit, rhs signed __int64     {     static void AdditionThrow( const T& lhs, const U& rhs, T& result )     template < typename E >      }         return false;         }             }                 return true;                 result = (T)tmp; ad           |       ∂  ∞  y  O  N  5  +    ı  Î  Í  ‘  Œ  Õ  ±  j  d  -      È  ﬂ  ¬  Æ  §  £  É  }  z  y        Ω  ∑  á  i  `  G  =  $        Î  Â  ‰  »  Å  {  K  -  $      Ë
+  ’
+  À
+   
+  ™
+  §
+  °
+  †
+  D
+  B
+  :
+  	  Í	  ´	  ¢	  o	  e	  		  æ  h  g    ”  …  »  ≤  ¨  ´  è  H  B    ˙  «  Ω  a    ¿  ø  ¢  î      Û  È  …  √  ¿  ø  ©  ß  Ñ  [  5  
+  ‚  ¬  °  Ç  c  C  #    ‹  ∏  é  b  A                               SubtractionState_UintInt642,     SubtractionState_Uint64Int2,     SubtractionState_CastInt64CheckMinMax2,     SubtractionState_CastIntCheckMinMax2,     SubtractionState_BothUnsigned2,     // states for SubtractionMethod2     SubtractionState_Int64Uint64,     SubtractionState_IntUint64,     SubtractionState_Int64Uint,     SubtractionState_IntInt64,     SubtractionState_Int64Int,     SubtractionState_UintInt64,      SubtractionState_Uint64Int,     SubtractionState_CastInt64CheckMin,     SubtractionState_CastInt64CheckMinMax,     SubtractionState_CastIntCheckMin,     SubtractionState_CastIntCheckMinMax,     SubtractionState_BothUnsigned, { enum SubtractionState  };     }         E::SafeIntOnOverflow();         }             }                 return;                 SafeCastHelper< T, __int32, GetCastMethod< T, __int32 >::method >::template CastThrow< E >( tmp, result );             {             if( tmp >= lhs )              __int32 tmp = (__int32)( (unsigned __int32)rhs + (unsigned __int32)lhs );             // Adding explicit casts to show exactly what's happening here             // Now it just happens to work out that the standard behavior does what we want         {         if( (unsigned __int32)( rhs >> 32 ) == 0 )                  // rhs is unsigned __int64, lhs signed, 32-bit or less     {     static void AdditionThrow( const T& lhs, const U& rhs, T& result )     template < typename E >      }         return false;          }                 return true;             if( tmp >= lhs && SafeCastHelper< T, __int32, GetCastMethod< T, __int32 >::method >::Cast( tmp, result ) )              __int32 tmp = (__int32)( (unsigned __int32)rhs + (unsigned __int32)lhs );             // Adding explicit casts to show exactly what's happening here             // Now it just happens to work out that the standard behavior does what we want         {         if( (unsigned __int32)( rhs >> 32 ) == 0 )                  // rhs is unsigned __int64, lhs signed, 32-bit or less     {     static bool Addition( const T& lhs, const U& rhs, T& result ) throw() public: { template < typename T, typename U > class AdditionHelper < T, U, AdditionState_ManualCheck>  };     }         E::SafeIntOnOverflow();          }            return;            result = tmp;         {         if( tmp >= lhs )                  T tmp = lhs + (T)rhs;         // rhs is unsigned __int64, lhs __int64     {     static void AdditionThrow( const T& lhs, const U& rhs, T& result )     template < typename E >      }         return false;          }            return true;            result = tmp;         {         if( tmp >= lhs )                  T tmp = lhs + (T)rhs;         // rhs is unsigned __int64, lhs __int64     {     static bool Addition( const T& lhs, const U& rhs, T& result ) throw() public: { template < typename T, typename U > class AdditionHelper < T, U, AdditionState_ManualCheckInt64Uint64 >  };     }         E::SafeIntOnOverflow();          }             return;             result = (T)tmp;         {         if( tmp >= lhs )          __int64 tmp = lhs + (__int64)rhs;         //lhs is signed __int64, rhs unsigned < 64-bit     {     static void AdditionThrow( const T& lhs, const U& rhs, T& result )     template < typename E >      }         return false;          }             return true;             result = (T)tmp;         {         if( tmp >= lhs )          __int64 tmp = lhs + (__int64)rhs;         //lhs is signed __int64, rhs unsigned < 64-bit     {     static bool Addition( const T& lhs, const U& rhs, T& result ) throw() ad     9     B       ‡  ¿  ü  ~  [  @  =  <     ˛  ˆ  Ì  Á  ¡    <  ˘  ∂  Q  -  ¬  Ñ    ›  {    ˜
+  å
+  O
+  ‚	  ©	  H	  Á  √  [    ≥  Q  Ô  ã  a  Z  W  V  '  Í  Ë  ‡  ◊  —  ´  i  &  „  †  ;    ¨  n    «  e    ·  v  9  8                                        (IntRegion< T,U >::IntZone_Int32_IntLT64 ||                  (IntRegion< T,U >::IntZone_IntLT32_IntLT32)      ? SubtractionState_CastIntCheckMinMax2 :                  // signed-signed                  (IntRegion< T,U >::IntZone_UintLT64_Int64)       ? SubtractionState_UintInt642 :                   IntRegion< T,U >::IntZone_Uint64_Int64)         ? SubtractionState_Uint64Int2 :                  (IntRegion< T,U >::IntZone_Uint64_Int ||                   IntRegion< T,U >::IntZone_UintLT32_Int32)       ? SubtractionState_CastInt64CheckMinMax2 :                  (IntRegion< T,U >::IntZone_Uint32_IntLT64 ||                  (IntRegion< T,U >::IntZone_UintLT32_IntLT32)     ? SubtractionState_CastIntCheckMinMax2 :                  // unsigned-signed                  (IntRegion< T,U >::IntZone_UintLT64_Uint64))     ? SubtractionState_BothUnsigned2 :                  (IntRegion< T,U >::IntZone_Uint64_Uint)       ||                   (IntRegion< T,U >::IntZone_UintLT32_Uint32)   ||                   (IntRegion< T,U >::IntZone_Uint32_UintLT64)   ||          method = ((IntRegion< T,U >::IntZone_UintLT32_UintLT32 ||                  // unsigned-unsigned     {     enum public: { template < typename T, typename U > class SubtractionMethod2 // this is for the case of U - SafeInt< T, E >  };     };                   SubtractionState_Error)                  (IntRegion< T,U >::IntZone_Int64_Uint64)          ? SubtractionState_Int64Uint64 :                  (IntRegion< T,U >::IntZone_Int_Uint64)            ? SubtractionState_IntUint64 :                  (IntRegion< T,U >::IntZone_Int64_UintLT64)        ? SubtractionState_Int64Uint :                   IntRegion< T,U >::IntZone_IntLT64_Uint32)        ? SubtractionState_CastInt64CheckMin :                  (IntRegion< T,U >::IntZone_Int32_UintLT32 ||                  (IntRegion< T,U >::IntZone_IntLT32_UintLT32)      ? SubtractionState_CastIntCheckMin :                  // signed-unsigned                  (IntRegion< T,U >::IntZone_IntLT64_Int64)         ? SubtractionState_IntInt64 :                   IntRegion< T,U >::IntZone_Int64_Int64)           ? SubtractionState_Int64Int :                  (IntRegion< T,U >::IntZone_Int64_Int ||                   IntRegion< T,U >::IntZone_IntLT32_Int32)         ? SubtractionState_CastInt64CheckMinMax :                  (IntRegion< T,U >::IntZone_Int32_IntLT64 ||                  (IntRegion< T,U >::IntZone_IntLT32_IntLT32)       ? SubtractionState_CastIntCheckMinMax :                  // signed-signed                  (IntRegion< T,U >::IntZone_UintLT64_Int64)        ? SubtractionState_UintInt64 :                   IntRegion< T,U >::IntZone_Uint64_Int64)          ? SubtractionState_Uint64Int :                  (IntRegion< T,U >::IntZone_Uint64_Int ||                   IntRegion< T,U >::IntZone_UintLT32_Int32)        ? SubtractionState_CastInt64CheckMinMax :                  (IntRegion< T,U >::IntZone_Uint32_IntLT64 ||                  (IntRegion< T,U >::IntZone_UintLT32_IntLT32)      ? SubtractionState_CastIntCheckMinMax :                  // unsigned-signed                  (IntRegion< T,U >::IntZone_UintLT64_Uint64))      ? SubtractionState_BothUnsigned :                  (IntRegion< T,U >::IntZone_Uint64_Uint)       ||                   (IntRegion< T,U >::IntZone_UintLT32_Uint32)   ||                   (IntRegion< T,U >::IntZone_Uint32_UintLT64)   ||          method = ((IntRegion< T,U >::IntZone_UintLT32_UintLT32 ||                  // unsigned-unsigned     {     enum public: { template < typename T, typename U > class SubtractionMethod  };     SubtractionState_Error     SubtractionState_Int64Uint642,     SubtractionState_IntUint642,     SubtractionState_Int64Uint2,     SubtractionState_IntInt642,     SubtractionState_Int64Int2, ad  r   &     f       ì  Z  ˘  ò  t  	  À  ^  ¸  ö  6  ⁄  ”  –  œ  Ü  Ö  "       Œ
+  »
+  ü
+  Ü
+  |
+  U
+  <
+  2
+  )
+  
+  
+  
+  	  ©	  £	  z	  a	  W	  0	  	  	  		  È  „  ‡  ﬂ  {  y  q  '  !  ¯  ö  Å  w  T  ˙    Á  —  À     Æ  g  a  8      Ú  ç  z  p  g  G  A  >  =  ‘  “     Ä  z  P    Ï  Î  Ü  |  _  F  <  ;  %        ª  µ  ã  H  '  &  %                                                                                                                             __int32 tmp = lhs - rhs;         // rhs is signed, so could end up increasing or decreasing         // both values are 16-bit or less     {     static void SubtractThrow( const T& lhs, const U& rhs, T& result )     template < typename E >      }         return false;          }             return true;             result = (T)tmp;         {         if( SafeCastHelper< T, __int32, GetCastMethod< T, __int32 >::method >::Cast( tmp, result ) )          __int32 tmp = lhs - rhs;         // rhs is signed, so could end up increasing or decreasing         // both values are 16-bit or less     {     static bool Subtract( const T& lhs, const U& rhs, T& result ) throw() public: { template < typename T, typename U > class SubtractionHelper< T, U, SubtractionState_CastIntCheckMinMax >  };     }         E::SafeIntOnOverflow();                  }            return;            SafeCastHelper< U, T, GetCastMethod<U, T>::method >::template CastThrow<E>( tmp, result);            T tmp = (T)(lhs - rhs);         {         if( rhs <= lhs )         // both are unsigned - easy case     {     static void SubtractThrow( const T& lhs, const U& rhs, U& result )     template < typename E >      }         return false;                  }            return SafeCastHelper< U, T, GetCastMethod<U, T>::method>::Cast( tmp, result);            T tmp = (T)(lhs - rhs);         {         if( rhs <= lhs )         // Except we do have to check for overflow - lhs could be larger than result can hold         // both are unsigned - easy case     {     static bool Subtract( const T& lhs, const U& rhs, U& result ) throw() public: { template < typename T, typename U > class SubtractionHelper< T, U, SubtractionState_BothUnsigned2 >  };     }         E::SafeIntOnOverflow();                  }             return;             result = (T)( lhs - rhs );         {         if( rhs <= lhs )         // both are unsigned - easy case     {     static void SubtractThrow( const T& lhs, const U& rhs, T& result )     template < typename E >      }         return false;                  }             return true;             result = (T)( lhs - rhs );         {         if( rhs <= lhs )         // both are unsigned - easy case     {     static bool Subtract( const T& lhs, const U& rhs, T& result ) throw() public: { template < typename T, typename U > class SubtractionHelper< T, U, SubtractionState_BothUnsigned >  template < typename T, typename U, int method > class SubtractionHelper;  };     };                                                                     SubtractionState_Error)                  (IntRegion< T,U >::IntZone_Int64_Uint64)         ? SubtractionState_Int64Uint642 :                  (IntRegion< T,U >::IntZone_Int_Uint64)           ? SubtractionState_IntUint642 :                  (IntRegion< T,U >::IntZone_Int64_UintLT64)       ? SubtractionState_Int64Uint2 :                   IntRegion< T,U >::IntZone_IntLT64_Uint32)       ? SubtractionState_CastInt64CheckMinMax2 :                  (IntRegion< T,U >::IntZone_Int32_UintLT32 ||                  (IntRegion< T,U >::IntZone_IntLT32_UintLT32)     ? SubtractionState_CastIntCheckMinMax2 :                  // signed-unsigned                  (IntRegion< T,U >::IntZone_IntLT64_Int64)        ? SubtractionState_IntInt642 :                   IntRegion< T,U >::IntZone_Int64_Int64)          ? SubtractionState_Int64Int2 :                  (IntRegion< T,U >::IntZone_Int64_Int ||                   IntRegion< T,U >::IntZone_IntLT32_Int32)        ? SubtractionState_CastInt64CheckMinMax2 : ad  S        l       ç  á  Ñ  É        «  ¡  ó  T  3  2  À  ≈  ƒ  ®  a  [  1  Ó  Õ  Ã  Y  S  P  O  È  Á  ﬂ  ï  è  e  5      ﬁ
+  ‘
+  ∑
+  û
+  î
+  á
+  q
+  k
+  j
+  N
+  
+  
+  ◊	  ß	  Ü	  Ö	  P	  F	  )	  	  	  ˛  ﬁ  ÿ  ’  ‘  i  g  _      Â  ¢  o  n         ‰  ù  ó  m  *  ˜  ˆ  É  }  z  y        ª  µ  ã  H      ≠  ß  ¶  ä  C  =    –  ù  ú  )  #                                                                                             };     }         SafeCastHelper< T, __int64, GetCastMethod< T, __int64 >::method >::template CastThrow< E >( tmp, result );          __int64 tmp = (__int64)lhs - (__int64)rhs;         // rhs is signed, so could end up increasing or decreasing         // both values are 32-bit or less     {     static void SubtractThrow( const U& lhs, const T& rhs, T& result )     template < typename E >      }         return SafeCastHelper< T, __int64, GetCastMethod< T, __int64 >::method >::Cast( tmp, result );          __int64 tmp = (__int64)lhs - (__int64)rhs;         // rhs is signed, so could end up increasing or decreasing         // both values are 32-bit or less     {     static bool Subtract( const U& lhs, const T& rhs, T& result ) throw() public: { template <typename U, typename T> class SubtractionHelper< U, T, SubtractionState_CastInt64CheckMinMax2 >  };     }         SafeCastHelper< T, __int64, GetCastMethod< T, __int64 >::method >::template CastThrow< E >( tmp, result );          __int64 tmp = (__int64)lhs - (__int64)rhs;         // rhs is signed, so could end up increasing or decreasing         // both values are 32-bit or less     {     static void SubtractThrow( const T& lhs, const U& rhs, T& result )     template < typename E >      }         return SafeCastHelper< T, __int64, GetCastMethod< T, __int64 >::method >::Cast( tmp, result );          __int64 tmp = (__int64)lhs - (__int64)rhs;         // rhs is signed, so could end up increasing or decreasing         // both values are 32-bit or less     {     static bool Subtract( const T& lhs, const U& rhs, T& result ) throw() public: { template < typename T, typename U > class SubtractionHelper< T, U, SubtractionState_CastInt64CheckMinMax >  };     }         E::SafeIntOnOverflow();                      }             return;             result = (T)tmp;         {         if( tmp >= (__int32)IntTraits< T >::minInt )          __int32 tmp = lhs - rhs;         // rhs is unsigned - check only minimum         // both values are 16-bit or less     {     static void SubtractThrow( const T& lhs, const U& rhs, T& result )     template < typename E >      }         return false;                      }             return true;             result = (T)tmp;         {         if( tmp >= (__int32)IntTraits< T >::minInt )          __int32 tmp = lhs - rhs;         // rhs is unsigned - check only minimum         // both values are 16-bit or less     {     static bool Subtract( const T& lhs, const U& rhs, T& result ) throw() public: { template < typename T, typename U > class SubtractionHelper< T, U, SubtractionState_CastIntCheckMin >  };     }         SafeCastHelper< T, __int32, GetCastMethod< T, __int32 >::method >::template CastThrow< E >( tmp, result );          __int32 tmp = lhs - rhs;         // rhs is signed, so could end up increasing or decreasing         // both values are 16-bit or less     {     static void SubtractThrow( const U& lhs, const T& rhs, T& result )     template < typename E >      }         return SafeCastHelper< T, __int32, GetCastMethod< T, __int32 >::method >::Cast( tmp, result );          __int32 tmp = lhs - rhs;         // rhs is signed, so could end up increasing or decreasing         // both values are 16-bit or less     {     static bool Subtract( const U& lhs, const T& rhs, T& result ) throw() public: { template <typename U, typename T> class SubtractionHelper< U, T, SubtractionState_CastIntCheckMinMax2 >  };     }         SafeCastHelper< T, __int32, GetCastMethod< T, __int32 >::method >::template CastThrow< E >( tmp, result ); ad  2   2     y       ò  ñ  é  D  >    ‰  ±  ∞  {  q  T  ;  1  (        Ô  ®  ¢  x  H      ﬂ  ’  ∏  §  ö  ë  q  k  h  g      ˝  ≥  ≠  {  B  +  !  Ú
+  ‰
+  ß
+  ä
+  |
+  r
+  e
+  [
+  /
+  ÿ	  ◊	  π	  ú	  í	  ë	  {	  u	  t	  X	  	  	  Ÿ  †  â    P  B    Ì  ﬂ  ’  »  æ  í  ;  :      ˙  ˘  Ÿ  ”  –  œ  n  l  d      Ê  –  ∆  †  ~  }      ﬁ  †  í  q  T  F  <  ÿ  Œ  ¨  `    ·  »  æ  ±  ß  Ö  3  2  1                                                                 unsigned __int64 tmp = (unsigned __int64)lhs - (unsigned __int64)rhs;             // result is positive         {         else         }             return true;             result = (T)lhs - (T)rhs;             // Also allows us to drop to 32-bit math, which is faster on a 32-bit system             // implies that lhs must fit into T, and result cannot overflow             // result is negative         {         else if( (unsigned __int64)rhs > lhs ) // now both are positive, so comparison always works         }             }                 return true;                 result = (T)tmp;             {             if( tmp >= lhs && tmp <= IntTraits< T >::maxInt )             // must check for addition overflow and max              tmp = lhs + (unsigned __int64)AbsValueHelper< T, GetAbsMethod< T >::method >::Abs( rhs );              unsigned __int64 tmp;             // treat this as addition         {         if( rhs < 0 )         // U is unsigned __int64, T is signed     {     static bool Subtract( const U& lhs, const T& rhs, T& result ) throw() public: { template < typename U, typename T > class SubtractionHelper< U, T, SubtractionState_Uint64Int2 >  };     }         E::SafeIntOnOverflow();          }                 return;             if(result >= lhs)              result = lhs + AbsValueHelper< U, GetAbsMethod< U >::method >::Abs( rhs );             // we're now effectively adding         {         else         }             }                 return;                 result = (T)( lhs - (unsigned __int64)rhs );             {             if( (unsigned __int64)rhs <= lhs )         {         if( rhs >= 0 )         // must first see if rhs is positive or negative         // lhs is an unsigned __int64, rhs signed     {     static void SubtractThrow( const T& lhs, const U& rhs, T& result )     template < typename E >      }         return false;          }                 return true;             if(result >= lhs)              result = lhs + AbsValueHelper< U, GetAbsMethod< U >::method >::Abs( rhs );             // we're now effectively adding         {         else         }             }                 return true;                 result = (T)( lhs - (unsigned __int64)rhs );             {             if( (unsigned __int64)rhs <= lhs )         {         if( rhs >= 0 )         // must first see if rhs is positive or negative         // lhs is an unsigned __int64, rhs signed     {     static bool Subtract( const T& lhs, const U& rhs, T& result ) throw() public: { template < typename T, typename U > class SubtractionHelper< T, U, SubtractionState_Uint64Int >  };     }         E::SafeIntOnOverflow();                  }             return;             result = (T)tmp;         {         if( tmp >= (__int64)IntTraits< T >::minInt )          __int64 tmp = (__int64)lhs - (__int64)rhs;         // rhs is unsigned - check only minimum         // both values are 32-bit or less     {     static void SubtractThrow( const T& lhs, const U& rhs, T& result )     template < typename E >      }         return false;                  }             return true;             result = (T)tmp;         {         if( tmp >= (__int64)IntTraits< T >::minInt )          __int64 tmp = (__int64)lhs - (__int64)rhs;         // rhs is unsigned - check only minimum         // both values are 32-bit or less     {     static bool Subtract( const T& lhs, const U& rhs, T& result ) throw() public: { template < typename T, typename U > class SubtractionHelper< T, U, SubtractionState_CastInt64CheckMin > ad  (   ,     z       –  ¬  °  Ñ  v  l  k  U  O  N  2  Î  Â  ∑  °  ó  q  O  N  Ë  Á  Ø  j  \  ;  #      ß  ù  {  /  ÷  ∞  ú  í  Ö  {  Y      œ
+  ¡
+  †
+  à
+  z
+  p
+  o
+  O
+  I
+  F
+  E
+  Â	  „	  €	  ë	  ã	  H	  	  ¯  Ó  ø  ±  É  f  X  N  A  7    Ã  ü  I  H      ‚  ¡  §  ñ  å  ã  u  o  n  R      ¬  â  r  h  9  +  ˝  Â  ◊  Õ  ¿  ∂  ä  K    »  «  ù  o  a  @  (        Ô  È  Ê  Â  Ü  Ñ  |  2  ,  +                                              {     static bool Subtract( const U& lhs, const T& rhs, T& result ) throw() public: { template <typename U, typename T> class SubtractionHelper< U, T, SubtractionState_UintInt642 >  };     }         E::SafeIntOnOverflow();          }             }                 return;                 result = (T)tmp;             {             if(tmp <= IntTraits< T >::maxInt)             // but we could exceed MaxInt              unsigned __int64 tmp = lhs + (unsigned __int64)( -rhs ); // negation safe             // this addition cannot overflow             // since lhs is 32-bit, and rhs cannot exceed 2^63             // we're now effectively adding         {         else         }             }                 return;                 result = (T)( lhs - (T)rhs );             {             if( (unsigned __int64)rhs <= lhs )         {         if( rhs >= 0 )         // must first see if rhs is positive or negative         // lhs is an unsigned int32 or smaller, rhs signed __int64     {     static void SubtractThrow( const T& lhs, const U& rhs, T& result )     template < typename E >      }         return false;          }             }                 return true;                 result = (T)tmp;             {             if(tmp <= IntTraits< T >::maxInt)             // but we could exceed MaxInt              unsigned __int64 tmp = lhs + (unsigned __int64)( -rhs ); // negation safe             // this addition cannot overflow             // since lhs is 32-bit, and rhs cannot exceed 2^63             // we're now effectively adding         {         else         }             }                 return true;                 result = (T)( lhs - (T)rhs );             {             if( (unsigned __int64)rhs <= lhs )         {         if( rhs >= 0 )         // must first see if rhs is positive or negative         // lhs is an unsigned int32 or smaller, rhs signed __int64     {     static bool Subtract( const T& lhs, const U& rhs, T& result ) throw() public: { template < typename T, typename U > class SubtractionHelper< T, U, SubtractionState_UintInt64 >  };     }         E::SafeIntOnOverflow();          }             }                 return;                 result = (T)tmp;             {             if( IntTraits<T>::isLessEqualMaxInt(tmp) )              unsigned __int64 tmp = (unsigned __int64)lhs - (unsigned __int64)rhs;             // result is positive         {         else         }             return;             result = (T)lhs - (T)rhs;             // Also allows us to drop to 32-bit math, which is faster on a 32-bit system             // implies that lhs must fit into T, and result cannot overflow             // result is negative         {         else if( (unsigned __int64)rhs > lhs ) // now both are positive, so comparison always works         }             }                 return;                 result = (T)tmp;             {             if( tmp >= lhs && IntTraits<T>::isLessEqualMaxInt(tmp) )             // must check for addition overflow and max              tmp = lhs + (unsigned __int64)AbsValueHelper< T, GetAbsMethod< T >::method >::Abs( rhs );              unsigned __int64 tmp;             // treat this as addition         {         if( rhs < 0 )         // U is unsigned __int64, T is signed     {     static void SubtractThrow( const U& lhs, const T& rhs, T& result )     template < typename E >      }         return false;          }             }                 return true;                 result = (T)tmp;             {             if( tmp <= IntTraits< T >::maxInt ) ad     ˇ     r       –  π  Ø  ä  Z  A  7  *     Ò  ¡  j  i  '    ¯  €  Õ  √  ¬  ¨  ¶  •  â  B  <    ı  Î  ∆  ñ  Ç  x  k  a  2    ´  ™  h  Z  9  !    	    Ë
+  ‚
+  ﬂ
+  ﬁ
+  
+  }
+  u
+  +
+  %
+  Ì	  ≈	  ∫	  y	  	  ﬂ  û  ù  |  {  3  ˜  ‘  ë  N  D  )          Í  È  Õ  Ü  Ä  H       ‘  y  :  ˘  ¯  ◊  ÷  é  R  /  Ï  ©  ü  {  q  p  W  Q  N  M  Ì  Î  „  ô  ì  T  3  2  
+  ˇ  ˛                                     //         // we have essentially 4 cases:          __int64 tmp = lhs - rhs;         // lhs __int64, rhs any signed int (including __int64)     {     static bool Subtract( const U& lhs, const T& rhs, T& result ) throw() public: { template < typename U, typename T > class SubtractionHelper< U, T, SubtractionState_Int64Int2 >  };     }         result = (T)tmp;          }             E::SafeIntOnOverflow();         {             ( rhs >= 0 && tmp > lhs ) )             // condition 3         if( ( lhs >= 0 && rhs < 0 && tmp < lhs ) || // condition 2         // It isn't practical here         // lead to success, which enables better pipelining         // Note - ideally, we can order these so that true conditionals          __int64 tmp = lhs - rhs;          // 4) lhs negative, rhs negative - overflow not possible         // 3) lhs negative, rhs positive - check result <= lhs         // 2) lhs positive, rhs negative - equivalent to addition - result >= lhs or error         // 1) lhs positive, rhs positive - overflow not possible         //         // we have essentially 4 cases:         // lhs is an __int64, rhs signed (up to 64-bit)     {     static void SubtractThrow( const T& lhs, const U& rhs, T& result )     template < typename E >      }         return true;         result = (T)tmp;          }              return false;         {             ( rhs >= 0 && tmp > lhs ) )             // condition 3         if( ( lhs >= 0 && rhs < 0 && tmp < lhs ) || // condition 2         // It isn't practical here         // lead to success, which enables better pipelining         // Note - ideally, we can order these so that true conditionals          __int64 tmp = lhs - rhs;          // 4) lhs negative, rhs negative - overflow not possible         // 3) lhs negative, rhs positive - check result <= lhs         // 2) lhs positive, rhs negative - equivalent to addition - result >= lhs or error         // 1) lhs positive, rhs positive - overflow not possible         //         // we have essentially 4 cases:         // lhs is an __int64, rhs signed (up to 64-bit)     {     static bool Subtract( const T& lhs, const U& rhs, T& result ) throw() public: { template < typename T, typename U > class SubtractionHelper< T, U, SubtractionState_Int64Int >  };     }         E::SafeIntOnOverflow();          }             }                 return;                 result = (T)tmp;             {             if( tmp <= (unsigned __int64)IntTraits< T >::maxInt )              unsigned __int64 tmp = (unsigned __int64)lhs + (unsigned __int64)( -rhs );             // which cannot overflow internally             // we effectively have an addition         {         else         }             return;             result = (T)( (__int64)lhs - rhs );             // overflow not possible         {         if( rhs >= 0 )         // U unsigned 32-bit or less, T __int64     {     static void SubtractThrow( const U& lhs, const T& rhs, T& result )     template < typename E >      }         return false;          }             }                 return true;                 result = (T)tmp;             {             if( tmp <= (unsigned __int64)IntTraits< T >::maxInt )              unsigned __int64 tmp = (unsigned __int64)lhs + (unsigned __int64)( -rhs );             // which cannot overflow internally             // we effectively have an addition         {         else         }             return true;             result = (T)( (__int64)lhs - rhs );             // overflow not possible         {         if( rhs >= 0 )         // U unsigned 32-bit or less, T __int64 ad  "   ˆ     n       ∏  ]    ÷  ’  æ  ¥  q     œ  §  ñ  x  j  `  S  I  -  ›  ≤  §  Ü  x  n  m  T  ?  9  8    ’  œ  ê  o  n  F  ;  Û
+  ò
+  Y
+  
+  
+  ˘	  Ô	  ¨	  [	  
+	  ﬂ  —  ©  õ  ë  Ñ  z  ^    „  ’  ≠  ü  ï  î  {  u  r  q        æ  ∏  Ñ  \  Q  ˛  £  X  ˘  ¯  Œ  Õ  ∂  ¨  í  w  i  5  #  ˛  ›  À  Ω  ¨  û    =  +    Â  ”  ≈  ª  Æ  §  ç  s  X  J    ˆ  ı                                                    {                 if( tmp <= lhs && tmp >= IntTraits< T >::minInt )             {             if( rhs >= 0 )             // third case             // lhs < 0         {         else         }             }                 }                     return true;                     result = (T)tmp;                 {                 if( tmp >= lhs && tmp <= IntTraits< T >::maxInt )                 // second case             {             else             }                 }                     return true;                     result = (T)tmp;                 {                 if( tmp >= IntTraits< T >::minInt )             {             if( rhs >= 0 )             // first case         {         if( lhs >= 0 )          __int64 tmp = (__int64)lhs - rhs;          // lhs negative, rhs negative - addition cannot internally overflow, check against max         // lhs negative, rhs positive - check tmp <= lhs and tmp < min int         // lhs positive, rhs negative - additive case - check tmp >= lhs and tmp > max int         // lhs positive, rhs positive - rhs could be larger than lhs can represent         //         // we have essentially 4 cases:         // lhs is a 32-bit int or less, rhs __int64     {     static bool Subtract( const T& lhs, const U& rhs, T& result ) throw() public: { template < typename T, typename U > class SubtractionHelper< T, U, SubtractionState_IntInt64 >  };     }         result = (T)tmp;          }             }                 E::SafeIntOnOverflow();             {                 ( rhs >=0 && tmp > lhs ) )             if( ( IntTraits< T >::isLT64Bit && tmp < IntTraits< T >::minInt) ||             // lhs negative         {         else         }             }                 E::SafeIntOnOverflow();             {                 ( rhs < 0 && tmp < lhs ) )             if( ( IntTraits< T >::isLT64Bit && tmp > IntTraits< T >::maxInt ) ||             // which is why we'll explicitly check maxInt, and not call SafeCast             // if both positive, overflow to negative not possible         {         if( lhs >= 0 )          // 4) lhs negative, rhs negative - overflow not possible in tmp         // 3) lhs negative, rhs positive - check result <= lhs         // 2) lhs positive, rhs negative - equivalent to addition - result >= lhs or error         // 1) lhs positive, rhs positive - overflow not possible in tmp         //         // we have essentially 4 cases:          __int64 tmp = lhs - rhs;         // lhs __int64, rhs any signed int (including __int64)     {     static void SubtractThrow( const U& lhs, const T& rhs, T& result )     template < typename E >      }         return true;         result = (T)tmp;          }             }                 return false;             {                 ( rhs >=0 && tmp > lhs ) )             if( ( IntTraits< T >::isLT64Bit && tmp < IntTraits< T >::minInt) ||             // lhs negative         {         else         }             }                 return false;             {                 ( rhs < 0 && tmp < lhs ) )             if( ( IntTraits< T >::isLT64Bit && tmp > IntTraits< T >::maxInt ) ||             // which is why we'll explicitly check maxInt, and not call SafeCast             // if both positive, overflow to negative not possible         {         if( lhs >= 0 )          // 4) lhs negative, rhs negative - overflow not possible in tmp         // 3) lhs negative, rhs positive - check result <= lhs         // 2) lhs positive, rhs negative - equivalent to addition - result >= lhs or error         // 1) lhs positive, rhs positive - overflow not possible in tmp ad  
+   F     à       €  ∫  ®  ö  â  {  \  (    Ò  –  æ  ∞  ¶  •  è  â  à  l  %    Î  √  ∏  e  
+  ø  `  _  5  4      ˘  ﬁ  –  ú  ä  e  I  7  )    
+  Î
+  ©
+  ó
+  r
+  V
+  D
+  6
+  ,
+  
+  
+  ˛	  ‰	  …	  ª	  y	  g	  B	  &	  	  	  ı  Á  »  î  Ç  ]  A  /  !      ˆ    Ì  Ï  å  ä  Ç  8  2  ˆ  Ã  À  ó  p  f  L  6  ,  +    ˝  ˜  ˆ  ⁄  ì  ç  Q  '  &  Ú  À  ¡  ù  á  }  |  c  ]  Z  Y  ˘  ˜  Ô  •  ü  a  `  6  5      ı  ‹  “  Ã  ∂  ∞  Ø  ì  L  F  E                {     static void SubtractThrow( const T& lhs, const U& rhs, T& result )     template < typename E >      }         return false;               }             return true;             result = (T)tmp;         {         if( tmp <= lhs )          __int64 tmp = lhs - (__int64)rhs;          // lhs is a 64-bit int, rhs unsigned int32 or smaller     {     static bool Subtract( const T& lhs, const U& rhs, T& result ) throw() public: { template < typename T, typename U > class SubtractionHelper< T, U, SubtractionState_Int64Uint >  };     }         result = (T)tmp;          }             //else OK             E::SafeIntOnOverflow();         {             ( rhs > 0 && tmp > lhs ) )         if( ( lhs >= 0 && rhs < 0 && tmp < lhs ) ||          __int64 tmp = (__int64)lhs - rhs;         // lhs is any signed int32 or smaller, rhs is int64     {     static void SubtractThrow( const U& lhs, const T& rhs, T& result )     template < typename E >      }         return true;         result = (T)tmp;          }             //else OK             return false;         {             ( rhs > 0 && tmp > lhs ) )         if( ( lhs >= 0 && rhs < 0 && tmp < lhs ) ||          __int64 tmp = (__int64)lhs - rhs;         // lhs is any signed int32 or smaller, rhs is int64     {     static bool Subtract( const U& lhs, const T& rhs, T& result ) throw() public: { template < typename U, typename T > class SubtractionHelper< U, T, SubtractionState_IntInt642 >  };     }         E::SafeIntOnOverflow();          }             }                 }                     return;                     result = (T)tmp;                 {                 if( tmp <= IntTraits< T >::maxInt )                 // fourth case             {             else             }                 }                     return;                     result = (T)tmp;                 {                 if( tmp <= lhs && tmp >= IntTraits< T >::minInt )             {             if( rhs >= 0 )             // third case             // lhs < 0         {         else         }             }                 }                     return;                     result = (T)tmp;                 {                 if( tmp >= lhs && tmp <= IntTraits< T >::maxInt )                 // second case             {             else             }                 }                     return;                     result = (T)tmp;                 {                 if( tmp >= IntTraits< T >::minInt )             {             if( rhs >= 0 )             // first case         {         if( lhs >= 0 )          __int64 tmp = (__int64)lhs - rhs;          // lhs negative, rhs negative - addition cannot internally overflow, check against max         // lhs negative, rhs positive - check tmp <= lhs and tmp < min int         // lhs positive, rhs negative - additive case - check tmp >= lhs and tmp > max int         // lhs positive, rhs positive - rhs could be larger than lhs can represent         //         // we have essentially 4 cases:         // lhs is a 32-bit int or less, rhs __int64     {     static void SubtractThrow( const T& lhs, const U& rhs, T& result )     template < typename E >      }         return false;          }             }                 }                     return true;                     result = (T)tmp;                 {                 if( tmp <= IntTraits< T >::maxInt )                 // fourth case             {             else             }                 }                     return true;                     result = (T)tmp; ad     !     Å       ¬  ¡  ó  ñ  }  s  V  B  8  2      	    ß  •  ù  d      Í  È  ú  í  u  \  R  Q  ;  5  4    —  À  °  †  S  I  ,        Ì  Á  ‰  „  É  Å  y  /  )  Ù
+  À
+   
+  ä
+  B
+  Ë	  Á	  —	  «	  f	  X	  -	  	  	  ¯  Î  ·  •  ó  l  O  A  7  6         ˝  ∂  ∞  {  R  Q    …  o  n  X  N  Ì  ﬂ  ¥  ú  é  Ñ  w  m  1  #  ¯  ‡  “  »  «  ß  °  û  ù  <  :  2  Ë  ‚  ô  q  g  <  #        ¸  ˚  ﬂ  ò  í  I  !               if( lhs >= 0 && (T)lhs >= rhs )         // We run into upcasting problems on comparison - needs 2 checks     {     static void SubtractThrow( const U& lhs, const T& rhs, T& result )     template < typename E >      }         return false;          }             return true;             result = (T)((U)lhs - (U)rhs);         {         if( lhs >= 0 && (T)lhs >= rhs )         // We run into upcasting problems on comparison - needs 2 checks     {     static bool Subtract( const U& lhs, const T& rhs, T& result ) throw() public: { template < typename U, typename T > class SubtractionHelper< U, T, SubtractionState_IntUint642 >  };     }         E::SafeIntOnOverflow();          }             }                 return;                 result = (T)( lhs - rhs );             {             if( rhs <= AbsMinIntT + (unsigned __int64)lhs )         {         else         }             }                 return;                 result = (T)( lhs - rhs );             {             if( rhs <= AbsMinIntT - AbsValueHelper< T, GetAbsMethod< T >::method >::Abs( lhs ) )         {         if( lhs < 0 )          const unsigned __int64 AbsMinIntT = (unsigned __int64)IntTraits< T >::maxInt + 1;         // This will give it to us without extraneous compiler warnings         // We need the absolute value of IntTraits< T >::minInt          // check against available range         // lhs is any signed int, rhs unsigned int64     {     static void SubtractThrow( const T& lhs, const U& rhs, T& result )     template < typename E >      }         return false;          }             }                 return true;                 result = (T)( lhs - rhs );             {             if( rhs <= AbsMinIntT + (unsigned __int64)lhs )         {         else         }             }                 return true;                 result = (T)( lhs - rhs );             {             if( rhs <= AbsMinIntT - AbsValueHelper< T, GetAbsMethod< T >::method >::Abs( lhs ) )         {         if( lhs < 0 )          const unsigned __int64 AbsMinIntT = (unsigned __int64)IntTraits< T >::maxInt + 1;         // This will give it to us without extraneous compiler warnings         // We need the absolute value of IntTraits< T >::minInt          // check against available range         // lhs is any signed int, rhs unsigned int64     {     static bool Subtract( const T& lhs, const U& rhs, T& result ) throw() public: { template < typename T, typename U > class SubtractionHelper< T, U, SubtractionState_IntUint64 >  };     }         E::SafeIntOnOverflow();          }             return;             result = (T)tmp;         {         if( tmp <= IntTraits< T >::maxInt && tmp >= IntTraits< T >::minInt )          __int64 tmp = lhs - (__int64)rhs;     {     static void SubtractThrow( const U& lhs, const T& rhs, T& result )     template < typename E >      }         return false;          }             return true;             result = (T)tmp;         {         if( tmp <= IntTraits< T >::maxInt && tmp >= IntTraits< T >::minInt )          __int64 tmp = lhs - (__int64)rhs;     {     static bool Subtract( const U& lhs, const T& rhs, T& result ) throw()     // lhs is __int64, rhs is unsigned 32-bit or smaller public: { template < typename U, typename T > class SubtractionHelper< U, T, SubtractionState_Int64Uint2 >  };     }         E::SafeIntOnOverflow();               }             return;             result = (T)tmp;         {         if( tmp <= lhs )          __int64 tmp = lhs - (__int64)rhs;          // lhs is a 64-bit int, rhs unsigned int32 or smaller ad     M     ã       ˆ  À  ∑  ≠  ¨  å  Ü  Ö  Ç  Å        À  ≈  Ö  h  g  O  F  .      ¯  Ú  Ò  ’  é  à  H  +  *    	  Ò  ﬂ  ÷  ’  µ  Ø  Æ  ´  ™  I  G  ?  €  É  9  3      
+  ﬂ
+  ⁄
+  Ÿ
+  ƒ
+  æ
+  Ω
+  °
+  Z
+  T
+  1
+  ,
+  
+  
+   
+  ˇ	  ﬂ	  Ÿ	  ÿ	  ’	  ‘	  √	  ¡	  ≠	  ó	  Ä	  j	  g	  f	  /	  -	  %	  	  	  Í  π  Å  >    —  à  =  Ú  §  ù  ö  ô  t  \  V  4  -  ,  Â  ‰  í  ê  à  K  H  G  Û  Ò  È  »  ¬  ê  G          ∂  ¥  ¨  ã  Ö  T  
+  ◊  —  Œ  Õ  x  v  n  M  L           static T And( T lhs, U rhs ) public: { template < typename T, typename U > class BinaryAndHelper< T, U, BinaryState_Int32 >  };     }         return (T)( lhs & (unsigned __int16)rhs );         BinaryAssert( ( lhs & rhs ) == ( lhs & (unsigned __int16)rhs ) );         //cast forces sign extension to be zeros     {     static T And( T lhs, U rhs ) public: { template < typename T, typename U > class BinaryAndHelper< T, U, BinaryState_Int16 >  };     }         return (T)( lhs & (unsigned __int8)rhs );         BinaryAssert( ( lhs & rhs ) == ( lhs & (unsigned __int8)rhs ) );         // cast forces sign extension to be zeros     {     static T And( T lhs, U rhs ) public: { template < typename T, typename U > class BinaryAndHelper< T, U, BinaryState_Int8 >  };     static T And( T lhs, U rhs ){ return (T)( lhs & rhs ); } public: { template < typename T, typename U > class BinaryAndHelper< T, U, BinaryState_OK >  template < typename T, typename U, int method > class BinaryAndHelper;  #endif #define BinaryAssert(x) assert(x) #else #define BinaryAssert(x) #ifdef SAFEINT_DISABLE_BINARY_ASSERT  };     };                                                       : BinaryState_Int32                      IntTraits< U >::isInt16              ? BinaryState_Int16                   IntTraits< U >::isInt8               ? BinaryState_Int8 :                  !IntTraits< U >::isSigned )          ? BinaryState_OK :                  SafeIntCompare< T, U >::isBothUnsigned ||         method = ( sizeof( T ) <= sizeof( U ) ||          // Then binary operations won't produce unexpected results         //    return type is larger and rhs is unsigned         //    return type is smaller than rhs OR         // If both operands are unsigned OR     {     enum public: { template < typename T, typename U > class BinaryMethod  };     BinaryState_Int32     BinaryState_Int16,     BinaryState_Int8,     BinaryState_OK, { enum BinaryState  };      }         E::SafeIntOnOverflow();  		 } 			 return; 			 result = (T)lhs - rhs; 		 { 		 if( lhs >= 0 && (T)lhs >= rhs )     {     static void SubtractThrow( const U& lhs, const T& rhs, T& result )     template < typename E >      }        return false;  		 } 			 return true; 			 result = (T)lhs - rhs; 		 { 		 if( lhs >= 0 && (T)lhs >= rhs )     {     static bool Subtract( const U& lhs, const T& rhs, T& result ) throw() 	 // get smaller. If rhs > lhs, then it would also go negative, which is the other case 	 // If lhs is negative, immediate problem - return must be positive, and subtracting only makes it public: { template <typename U, typename T> class SubtractionHelper< U, T, SubtractionState_Int64Uint642 >  };      }         E::SafeIntOnOverflow();         }           return;           result = tmp;        {        if( tmp <= lhs )         T tmp = lhs - (T)rhs;        // if we subtract, and it gets larger, there's a problem     {     static void SubtractThrow( const T& lhs, const U& rhs, T& result )     template < typename E >      }         return false;        }           return true;           result = tmp;        {        if( tmp <= lhs )         T tmp = lhs - (T)rhs;        // if we subtract, and it gets larger, there's a problem     {     static bool Subtract( const T& lhs, const U& rhs, T& result ) throw() public: { template < typename T, typename U > class SubtractionHelper< T, U, SubtractionState_Int64Uint64 >  };      }         E::SafeIntOnOverflow();          }             return;             result = (T)((U)lhs - (U)rhs);         { ad     
+     w       ˙  …    L  F  C  B  ¸  ˚  ™  ®  †  d  a  `        „  ›  ¨  c  1  +  (  '  ”  —  …  ©  £  r  (  ı  Ô  Ï  Î  ó  ï  ç  m  g  6  Ï
+  π
+  ≥
+  ∞
+  Ø
+  i
+  h
+  
+  
+  
+  œ	  Ã	  À	  w	  u	  m	  L	  F	  	  À  ô  ì  ê  è  :  8  0    	  ◊  ç  Z  T  Q  P  ˚  ˘  Ò  –     ò  N          ¿  ø  m  $    ﬁ  ≤  ∞  \  Z  Y  5  ˛  ¸  ®  ¶  •  Å  G  E    Ó  Ì  …  ç  ã  1  /  .  
+  	                    template < typename T, typename U >  }     return GreaterThanTest< T, U, ValidComparison< T, U >::method >::GreaterThan( t, u ); { inline bool SafeGreaterThan( const T t, const U u ) throw() template < typename T, typename U >  }     return !EqualityTest< T, U, ValidComparison< T, U >::method >::IsEquals( t, u ); { inline bool SafeNotEquals( const T t, const U u ) throw() template < typename T, typename U >  }     return EqualityTest< T, U, ValidComparison< T, U >::method >::IsEquals( t, u ); { inline bool SafeEquals( const T t, const U u ) throw() template < typename T, typename U >  }     return SafeCastHelper< U, T, GetCastMethod< U, T >::method >::Cast( From, To ); { inline bool SafeCast( const T From, U& To ) template < typename T, typename U > // and handle errors how you like // non-class helper function so that you can check for a cast's validity // External functions that can be used where you only need to check one operation  /*****************  External functions ****************************************/  };     }         return (T)( lhs ^ (unsigned __int32)rhs );         BinaryAssert( ( lhs ^ rhs ) == ( lhs ^ (unsigned __int32)rhs ) );         // cast forces sign extension to be zeros     {     static T Xor( T lhs, U rhs ) public: { template < typename T, typename U > class BinaryXorHelper< T, U, BinaryState_Int32 >  };     }         return (T)( lhs ^ (unsigned __int16)rhs );         BinaryAssert( ( lhs ^ rhs ) == ( lhs ^ (unsigned __int16)rhs ) );         // cast forces sign extension to be zeros     {     static T Xor( T lhs, U rhs ) public: { template < typename T, typename U > class BinaryXorHelper< T, U, BinaryState_Int16 >  };     }         return (T)( lhs ^ (unsigned __int8)rhs );         BinaryAssert( ( lhs ^ rhs ) == ( lhs ^ (unsigned __int8)rhs ) );         // cast forces sign extension to be zeros     {     static T Xor( T lhs, U rhs ) public: { template < typename T, typename U > class BinaryXorHelper< T, U, BinaryState_Int8 >  };     static T Xor( T lhs, U rhs ){ return (T)( lhs ^ rhs ); } public: { template < typename T, typename U > class BinaryXorHelper< T, U, BinaryState_OK >  template <typename T, typename U, int method > class BinaryXorHelper;  };     }         return (T)( lhs | (unsigned __int32)rhs );         BinaryAssert( ( lhs | rhs ) == ( lhs | (unsigned __int32)rhs ) );         //cast forces sign extension to be zeros     {     static T Or( T lhs, U rhs ) public: { template < typename T, typename U > class BinaryOrHelper< T, U, BinaryState_Int32 >  };     }         return (T)( lhs | (unsigned __int16)rhs );         BinaryAssert( ( lhs | rhs ) == ( lhs | (unsigned __int16)rhs ) );         //cast forces sign extension to be zeros     {     static T Or( T lhs, U rhs ) public: { template < typename T, typename U > class BinaryOrHelper< T, U, BinaryState_Int16 >  };     }         return (T)( lhs | (unsigned __int8)rhs );         BinaryAssert( ( lhs | rhs ) == ( lhs | (unsigned __int8)rhs ) );         //cast forces sign extension to be zeros     {     static T Or( T lhs, U rhs ) public: { template < typename T, typename U > class BinaryOrHelper< T, U, BinaryState_Int8 >  };     static T Or( T lhs, U rhs ){ return (T)( lhs | rhs ); } public: { template < typename T, typename U > class BinaryOrHelper< T, U, BinaryState_OK >  template < typename T, typename U, int method > class BinaryOrHelper;  };     }         return (T)( lhs & (unsigned __int32)rhs );         BinaryAssert( ( lhs & rhs ) == ( lhs & (unsigned __int32)rhs ) );         //cast forces sign extension to be zeros     { ad     ı     u       æ  º  a  _  ^  :    ˇ  •  £  ¢  ~  ?  =  ‚  ‡  ﬂ  ª  v  t       ˇ  €  £  °  8  6  5    €  Ÿ  h  f  e  A      Ø
+  ≠
+  ¨
+  à
+  P
+  N
+  Î	  È	  Ë	  ó	  ñ	  Ä	  \	  		  	  ˇ  È  „  ∂  £  ù  ú  i    Ó  Ã  ∆  ô  É  p  j  i  ?  !    Ó  ”  Õ  Ã  Ø  â  É  V  -  '  &  	  Ô  È  º  y        »  ä  H  3  2  1  
+  Ô  ¨  ´  é  ^  X  0  Ô  …  £  {  e  _  ^  &       ı  Ù               return *this;         m_int = rhs;     {     SafeInt< T, E >& operator =( const T& rhs ) throw()      }         return *this;         *this = SafeInt< T, E >( rhs );         // note - do not change this          // on whether T can contain U         // constructor is optimized to do minimal checking based         // use constructor to test size     {     SafeInt< T, E >& operator =( const U& rhs )     template < typename U >       // constructors exist for all int types and will ensure safety     // assignment operator     // now start overloading operators       // ~SafeInt(){};     // inlining characteristics. It wasn't doing anything anyway.     // vs. a do-nothing destructor makes a huge difference in     // The destructor is intentionally commented out - no destructor       }         SafeCastHelper< T, U, GetCastMethod< T, U >::method >::template CastThrow< E >( i, m_int );         // SafeCast will throw exceptions if i won't fit in type T         C_ASSERT( NumericType< T >::isInt );     {     SafeInt( const U& i )     template < typename U >       }         *this = SafeInt< T, E >( (U)u );         C_ASSERT( NumericType< T >::isInt );     {     SafeInt(const SafeInt< U, E >& u)     template < typename U >       }         m_int = b ? 1 : 0;         C_ASSERT( NumericType< T >::isInt );     {     SafeInt( bool b ) throw()     // provide explicit boolean converter      }         m_int = i;         //always safe         C_ASSERT( NumericType< T >::isInt );     {     SafeInt( const T& i ) throw()     // e.g., SafeInt<char> s = 0x7fffffff;     // avoids having the compiler evade our checks when doing implicit casts -      // Having a constructor for every type of int       }         m_int = 0;         C_ASSERT( NumericType< T >::isInt );     {     SafeInt() throw() public: { template < typename T, typename E = SafeIntDefaultExceptionHandler > class SafeInt // Assumes exceptions can be thrown // Main SafeInt class  /*****************  end external functions ************************************/  }     return SubtractionHelper< T, U, SubtractionMethod< T, U >::method >::Subtract( t, u, result ); { inline bool SafeSubtract( T t, U u, T& result ) throw() template < typename T, typename U >  }     return AdditionHelper< T, U, AdditionMethod< T, U >::method >::Addition( t, u, result ); { inline bool SafeAdd( T t, U u, T& result ) throw() template < typename T, typename U >  }     return ( DivisionHelper< T, U, DivisionMethod< T, U >::method >::Divide( t, u, result ) == SafeIntNoError ); { inline bool SafeDivide( T t, U u, T& result ) throw() template < typename T, typename U >  }     return MultiplicationHelper< T, U, MultiplicationMethod< T, U >::method >::Multiply( t, u, result ); { inline bool SafeMultiply( T t, U u, T& result ) throw() template < typename T, typename U >  }     return ( ModulusHelper< T, U, ValidComparison< T, U >::method >::Modulus( t, u, result ) == SafeIntNoError ); { inline bool SafeModulus( const T& t, const U& u, T& result ) throw() template < typename T, typename U >  }     return !GreaterThanTest< T, U, ValidComparison< T, U >::method >::GreaterThan( t, u ); { inline bool SafeLessThanEquals( const T t, const U u ) throw() template < typename T, typename U >  }     return GreaterThanTest< U, T, ValidComparison< U, T >::method >::GreaterThan( u, t ); { inline bool SafeLessThan( const T t, const U u ) throw() template < typename T, typename U >  }     return !GreaterThanTest< U, T, ValidComparison< U, T >::method >::GreaterThan( u, t ); { inline bool SafeGreaterThanEquals( const T t, const U u ) throw() ad     ˛     w       ˙  ˘  ‹  û  ò  ,        …  √  ®  í  å  ã  r  q  O  I  1  +  *    
+  ¯  å  x  r  q  P  J  1  ∑  £  ù  ú  y  s  X  ⁄  ∆  ¿  ø  ¢  ú  á      ˚
+  ˙
+  ‘
+  Œ
+  ∞
+  )
+  
+  
+  
+  Ò	  Î	  ÷	  d	  P	  J	  I	  #	  	  ˇ  x  d  ^  ]  /    Ò  Î  Ÿ  m  X  R  Q  .  (    è  {  u  t  W  Q  <     ∂  ∞  Ø  â  É  e  ·  Õ  «  ∆  ¨  ^    π  ù  ó  É    ˇ  ˘  Ú  Ò  ¥  ô  ì  Ä    ˛  ˝                return val;         SafeCastHelper< float, T, GetCastMethod< float, T >::method >::template CastThrow< E >( m_int, val );         float val;     {     operator float() const     // Also provide a cast operator for floating point types  #endif     }         return val;         SafeCastHelper< size_t, T, GetCastMethod< size_t, T >::method >::template CastThrow< E >( m_int, val );         size_t val;     {     operator size_t() const     // Leave here in case we decide to backport this to an earlier compiler     // Apparently, only SOME compilers complain, and cl 14.00.50727.42 isn't one of them     // We also need an explicit cast to size_t, or the compiler will complain #ifdef SIZE_T_CAST_NEEDED      }         return val;         SafeCastHelper< unsigned __int64, T, GetCastMethod< unsigned __int64, T >::method >::template CastThrow< E >( m_int, val );         unsigned __int64 val;     {     operator unsigned __int64() const      }         return val;         SafeCastHelper< __int64, T, GetCastMethod< __int64, T >::method >::template CastThrow< E >( m_int, val );         __int64 val;     {     operator __int64() const      }         return val;         SafeCastHelper< unsigned long, T, GetCastMethod< unsigned long, T >::method >::template CastThrow< E >( m_int, val );         unsigned long val;     {     operator unsigned long() const      }         return  val;         SafeCastHelper< long, T, GetCastMethod< long, T >::method >::template CastThrow< E >( m_int, val );         long val;     {     operator long() const     // but not that long == __int32     // The compiler knows that int == __int32      }         return val;            SafeCastHelper< unsigned __int32, T, GetCastMethod< unsigned __int32, T >::method >::template CastThrow< E >( m_int, val );         unsigned __int32 val;     {     operator unsigned __int32() const      }         return val;         SafeCastHelper< __int32, T, GetCastMethod< __int32, T >::method >::template CastThrow< E >( m_int, val );         __int32 val;     {     operator __int32() const      }         return val;            SafeCastHelper< unsigned __int16, T, GetCastMethod< unsigned __int16, T >::method >::template CastThrow< E >( m_int, val );         unsigned __int16 val;     {     operator unsigned __int16() const      }         return val;         SafeCastHelper< __int16, T, GetCastMethod< __int16, T >::method >::template CastThrow< E >( m_int, val );         __int16 val;     {     operator __int16() const      }         return val;         SafeCastHelper< unsigned char, T, GetCastMethod< unsigned char, T >::method >::template CastThrow< E >( m_int, val );         unsigned char val;     {     operator unsigned char() const      }         return val;         SafeCastHelper< signed char, T, GetCastMethod< signed char, T >::method >::template CastThrow< E >( m_int, val );         signed char val;     {     operator signed char() const      }         return val;         SafeCastHelper< char, T, GetCastMethod< char, T >::method >::template CastThrow< E >( m_int, val );         char val;     {     operator char() const      }         return !!m_int;     {     operator bool() const throw()      // Casting operators      }         return *this;         m_int = rhs.m_int;     {     SafeInt< T, E >& operator =( const SafeInt< T, E >& rhs ) throw()      }         return *this;         SafeCastHelper< T, U, GetCastMethod< T, U >::method >::template CastThrow< E >( rhs.Ref(), m_int );     {     SafeInt< T, E >& operator =( const SafeInt< U, E >& rhs )     template < typename U >       } ad          y       ˙  ˘  ›  ◊  √  S  ?  9      ˘    k  e  d  ;  ˙  ±  |  T     Ì  Ï  ¶  ì  g  8    Ÿ  û  ù  Ü  >  9    –
+  ã
+  B
+  A
+  1
+  (
+  
+  ˚	  æ	  y	  	  	  	  Ï  …  √  ï  ã  v  \  R  2  ,  '    „  ›  Ø  •  ê  v  l  L  F  E      Ô  Õ  Ö    Q  G        Ô  Â  ≈  ø  æ  ú  T  N       Ï  ◊  ø  µ  ï  è  é  v  6  ˇ  ß  ¶  é  á  d  S  ;  )      ˚  º  †  ô  }  a  Z  3  )              // SafeInt<char> i2 = (int)i op c;     // OR     // SafeInt<int> i2 = i op (char)c;     //     // SafeInt<int>  i = 3;     // SafeInt<char> c = 2;     //     // use them as follows:     // For each of the arithmetic operators, you will need to      //     // - subtraction     // + addition     // / division     // * multiplication     // % modulus     // arithmetic binary operators     //     // Binary operators      SafeInt< T, E > operator ~() const throw() { return SafeInt< T, E >( (T)~m_int ); }     // cast in return improves perf and maintains type     // Note - this operator will normally change size to an int     // One's complement      }         E::SafeIntOnOverflow();         }             return tmp;             m_int--;             SafeInt< T, E > tmp( m_int );         {         if( m_int != IntTraits< T >::minInt )     {     SafeInt< T, E > operator --( int ) // dummy arg to comply with spec     // postfix decrement operator      }         E::SafeIntOnOverflow();         }             return tmp;             m_int++;              SafeInt< T, E > tmp( m_int );         {         if( m_int != IntTraits< T >::maxInt )     {     SafeInt< T, E > operator ++( int ) // dummy arg to comply with spec     // postfix increment operator      // characteristics     // note that postfix operators have inherently worse perf      }         E::SafeIntOnOverflow();         }             return *this;             --m_int;         {         if( m_int != IntTraits< T >::minInt )     {     SafeInt< T, E >& operator --()     // prefix decrement operator          }         E::SafeIntOnOverflow();         }             return *this;             ++m_int;         {         if( m_int != IntTraits< T >::maxInt )     {     SafeInt< T, E >& operator ++()     // prefix increment operator      } 		return SafeInt<T, E>(NegationHelper<T, IntTraits<T>::isSigned>::template NegativeThrow<E>(m_int)); 		// will warn at level 2 or higher if the value is 32-bit or larger 		// Note - unsigned still performs the bitwise manipulation     {     SafeInt< T, E > operator -() const              //unary  -       const SafeInt< T, E >& operator +() const throw() { return *this; };     // for T < 32 bits. This class changes behavior to preserve type     // note - normally, the '+' and '-' operators will upcast to a signed int     // operator + (unary)           bool operator !() const throw() { return (!m_int) ? true : false; }     // Unary operators      const T* operator &() const throw() { return &m_int; }     T* operator &() throw() { return &m_int; }     // pass a SafeInt into things like ReadFile     // It is meant to allow you to more easily     // This allows you to do unsafe things!     // operator &      // Or if SafeInt< T, E >::Ptr() is inconvenient, use the overload      const T& Ref() const throw() { return m_int; }     const T* Ptr() const throw() { return &m_int; }     T* Ptr() throw() { return &m_int; }     // also see overloaded address-of operator below     // instances of this class to APIs that take a pointer to an integer     // this could be dangerous, but allows you to correctly pass     // If you need a pointer to the data      }         return val;         SafeCastHelper< long double, T, GetCastMethod< long double, T >::method >::template CastThrow< E >( m_int, val );         long double val;     {     operator long double() const     }         return val;         SafeCastHelper< double, T, GetCastMethod< double, T >::method >::template CastThrow< E >( m_int, val );         double val;     {     operator double() const      } ad  !   ¡     a       ˘  £  P  ˛  ß  †  I  Ë  å  u  n  Z  S  3       æ  Ω  Æ  }  F    ƒ  Ü  j  <  6  $  ≤
+  à
+  Ç
+  Å
+  E
+  ?
+  -
+  ª	  ë	  ã	  ä	  p	  T	  *	  $	  ≥  ù  ó  ñ  z  B  <  »  ≤  ¨  ´  ï  y  K  E  1  µ  é  à  á  K  E  1  ≤  ã  Ö  Ñ  c  +  %  §  é  à  á  j  @  :  º  ¶  †  ü  Ç  J  D  ¿  ™  §  £  ì  w  I  C  /  ¡  ¿                                           DivisionHelper< T, U, DivisionMethod< T, U >::method >::template DivideThrow< E >( m_int, rhs, ret );         T ret( 0 );     {     SafeInt< T, E > operator /( U rhs ) const     template < typename U >     // Division      }         return *this;         MultiplicationHelper< T, U, MultiplicationMethod< T, U >::method >::template MultiplyThrow< E >( m_int, rhs.Ref(), m_int );     {     SafeInt< T, E >& operator *=( SafeInt< U, E > rhs )     template < typename U >       }         return *this;         MultiplicationHelper< T, U, MultiplicationMethod< T, U >::method >::template MultiplyThrow< E >( m_int, rhs, m_int );     {     SafeInt< T, E >& operator *=( U rhs )     template < typename U >       }         return *this;         MultiplicationHelper< T, T, MultiplicationMethod< T, T >::method >::template MultiplyThrow< E >( m_int, (T)rhs, m_int );     {     SafeInt< T, E >& operator *=( SafeInt< T, E > rhs )     // Multiplication assignment      }         return SafeInt< T, E >( ret );         MultiplicationHelper< T, T, MultiplicationMethod< T, T >::method >::template MultiplyThrow< E >( m_int, (T)rhs, ret );         T ret( 0 );     {     SafeInt< T, E > operator *( SafeInt< T, E > rhs ) const      }         return SafeInt< T, E >( ret );         MultiplicationHelper< T, U, MultiplicationMethod< T, U >::method >::template MultiplyThrow< E >( m_int, rhs, ret );         T ret( 0 );     {     SafeInt< T, E > operator *( U rhs ) const     template < typename U >     // Multiplication      }         return *this;         ModulusHelper< T, U, ValidComparison< T, U >::method >::template ModulusThrow< E >( m_int, (U)rhs, m_int );     {     SafeInt< T, E >& operator %=( SafeInt< U, E > rhs )     template < typename U >      }         return *this;         ModulusHelper< T, U, ValidComparison< T, U >::method >::template ModulusThrow< E >( m_int, rhs, m_int );     {     SafeInt< T, E >& operator %=( U rhs )     template < typename U >     // Modulus assignment      }         return SafeInt< T, E >( result );         ModulusHelper< T, T, ValidComparison< T, T >::method >::template ModulusThrow< E >( m_int, rhs, result );         T result;     {     SafeInt< T, E > operator %( SafeInt< T, E > rhs ) const      }         return SafeInt< T, E >( result );         ModulusHelper< T, U, ValidComparison< T, U >::method >::template ModulusThrow< E >( m_int, rhs, result );         T result;     {     SafeInt< T, E > operator %( U rhs ) const     template < typename U >     // problems as comparisons, division and other operations     // as well. It does, however, suffer from the same promotion     // larger than the lhs operand, and it must be the same sign     // first, the magnitude of the return can never be     // Modulus has some convenient properties -      // Modulus      // works just fine and no unboxing is needed because the return type is not ambiguous.     //     // i = j op k;     // SafeInt< T, E > i, j, k;     //     // The case of:     //     // is situational.     // but it is tricky, and there's a perf vs. correctness tradeoff where the right answer     // 3.0 update - I'm still thinking about this. It can be done with template metaprogramming,     // Note - as per feedback from Scott Meyers, I'm exploring how to get around this.     //     // need to be the return type by forcing the other value to the base integer type.     // should be returned. You have to let the class know which of the two inputs     // it is not possible in this implementation to determine what type of SafeInt     // The base problem is that if the lhs and rhs inputs are different SafeInt types     // ad     ‰     n       Ÿ  ”  “  ñ  ê  |    ‰  ﬁ  ›  ¬  å  Ü    ˇ  ˘  ¯  ∏  ≤  D  .  (  '  Ÿ  ”  b  L  F  E  !       ‘  Œ  ∫  G         ˝
+  œ
+  …
+  µ
+  E
+  
+  
+  
+  ˝	  ≈	  ø	  J	  4	  .	  -	  	  Á  ·  o  Y  S  R  5  ˝  ˜  Ç  l  f  e  R  6      Ó  x  Q  K  J    
+  ˆ  }  V  P  O  1  ˘  Û  x  b  \  [  >      ñ  Ä  z  y  \  $    £  ç  á  Ü  j  3  ˆ  ı  ‰  „                      // Less than      // to allow for cases where the SafeInt is the rhs value     // Additional overloads defined outside the class      // Comparison operators      }         return *this;         SubtractionHelper< T, U, SubtractionMethod< T, U >::method >::template SubtractThrow< E >( m_int, (U)rhs, m_int );     {     SafeInt< T, E >& operator -=( SafeInt< U, E > rhs )     template < typename U >       }         return *this;         SubtractionHelper< T, U, SubtractionMethod< T, U >::method >::template SubtractThrow< E >( m_int, rhs, m_int );     {     SafeInt< T, E >& operator -=( U rhs )     template < typename U >       }         return *this;         SubtractionHelper< T, T, SubtractionMethod< T, T >::method >::template SubtractThrow< E >( m_int, (T)rhs, m_int );     {     SafeInt< T, E >& operator -=( SafeInt< T, E > rhs )     // Subtraction assignment      }         return SafeInt< T, E >( ret );         SubtractionHelper< T, T, SubtractionMethod< T, T >::method >::template SubtractThrow< E >( m_int, (T)rhs, ret );         T ret( 0 );     {     SafeInt< T, E > operator -(SafeInt< T, E > rhs) const      }         return SafeInt< T, E >( ret );         SubtractionHelper< T, U, SubtractionMethod< T, U >::method >::template SubtractThrow< E >( m_int, rhs, ret );         T ret( 0 );     {     SafeInt< T, E > operator -( U rhs ) const     template < typename U >     // Subtraction      }         return *this;         AdditionHelper< T, U, AdditionMethod< T, U >::method >::template AdditionThrow< E >( m_int, (U)rhs, m_int );     {     SafeInt< T, E >& operator +=( SafeInt< U, E > rhs )     template < typename U >       }         return *this;         AdditionHelper< T, U, AdditionMethod< T, U >::method >::template AdditionThrow< E >( m_int, rhs, m_int );     {     SafeInt< T, E >& operator +=( U rhs )     template < typename U >      }         return *this;         AdditionHelper< T, T, AdditionMethod< T, T >::method >::template AdditionThrow< E >( m_int, (T)rhs, m_int );     {     SafeInt< T, E >& operator +=( SafeInt< T, E > rhs )     //addition assignment      }         return SafeInt< T, E >( ret );         AdditionHelper< T, U, AdditionMethod< T, U >::method >::template AdditionThrow< E >( m_int, rhs, ret );         T ret( 0 );     {     SafeInt< T, E > operator +( U rhs ) const     template < typename U >      }         return SafeInt< T, E >( ret );         AdditionHelper< T, T, AdditionMethod< T, T >::method >::template AdditionThrow< E >( m_int, (T)rhs, ret );         T ret( 0 );     {     SafeInt< T, E > operator +( SafeInt< T, E > rhs ) const     // Addition      // For addition and subtraction      }         return *this;         DivisionHelper< T, U, DivisionMethod< T, U >::method >::template DivideThrow< E >( m_int, (U)i, m_int );     {     template < typename U > SafeInt< T, E >& operator /=( SafeInt< U, E > i )      }         return *this;         DivisionHelper< T, U, DivisionMethod< T, U >::method >::template DivideThrow< E >( m_int, i, m_int );     {     template < typename U > SafeInt< T, E >& operator /=( U i )      }         return *this;         DivisionHelper< T, T, DivisionMethod< T, T >::method >::template DivideThrow< E >( m_int, (T)i, m_int );     {     SafeInt< T, E >& operator /=( SafeInt< T, E > i )     // Division assignment      }         return SafeInt< T, E >( ret );         DivisionHelper< T, T, DivisionMethod< T, T >::method >::template DivideThrow< E >( m_int, (T)rhs, ret );         T ret( 0 );     {     SafeInt< T, E > operator /( SafeInt< T, E > rhs ) const      }         return SafeInt< T, E >( ret ); ad  >   F     {       ‰  π  ≥  O  I  H    	  Í  ‰  „  »  ¨    y        ”  Õ  ≠  ß  ¶  í  v  K  E  ·  €  ⁄  °  õ  |  v  u  ]  A      ©  £  ¢  h  b  B  <  ;  +    ‚
+  ‹
+  ~
+  x
+  w
+  H
+  
+  
+  ﬁ	  ÿ	  ◊	  Å	  Ä	  l	  P	  #	  	  æ  ∏  ∑  ä  Ñ  Q  K  J  Ù  Û  ‹  ó  ]        …  •  ã  Ö  `  Y  X  ;    ˝  Ω  Ä    G  A  @  #  ›  ◊  ï  U  T        ı  Ù  ÿ  §  û  _  "  !  	  Û  Ì  Ï  –  é  à  F  E                                                                        ShiftAssert( IntTraits< U >::greaterEqualZero((U)bits) );     {     SafeInt< T, E >& operator <<=( SafeInt< U, E > bits ) throw()     template < typename U >      }         return *this;         m_int <<= bits;          ShiftAssert( bits < (int)IntTraits< T >::bitCount );         ShiftAssert( IntTraits< U >::greaterEqualZero(bits) );     {     SafeInt< T, E >& operator <<=( U bits ) throw()     template < typename U >      // Left shift assignment      }         return SafeInt< T, E >( (T)( m_int << (U)bits ) );          ShiftAssert( (U)bits < (int)IntTraits< T >::bitCount );         ShiftAssert( IntTraits< U >::greaterEqualZero((U)bits) );     {     SafeInt< T, E > operator <<( SafeInt< U, E > bits ) const throw()     template < typename U >       }         return SafeInt< T, E >( (T)( m_int << bits ) );          ShiftAssert( bits < (int)IntTraits< T >::bitCount );         ShiftAssert( IntTraits< U >::greaterEqualZero(bits)  );     {     SafeInt< T, E > operator <<( U bits ) const throw()     template < typename U >   #endif     #define ShiftAssert(x) assert(x) #else    #define ShiftAssert(x) #ifdef SAFEINT_DISABLE_SHIFT_ASSERT     // Also, shifting > bitcount is undefined - trap in debug     // Left shift      // code path is exactly the same as for SafeInt< U, E > as rhs     // specific version for SafeInt< T, E > not needed -      // Note - shift operators ALWAYS return the same type as the lhs     // Shift operators      bool operator !=( SafeInt< T, E > rhs ) const throw() { return m_int != (T)rhs; }      }         return ( m_int == 0 ? false : true ) != b;     {     bool operator !=( bool b ) const throw()      }         return !EqualityTest< T, U, ValidComparison< T, U >::method >::IsEquals( m_int, rhs );     {     bool operator !=( U rhs ) const throw()      template < typename U >     // != operators      bool operator ==( SafeInt< T, E > rhs ) const throw() { return m_int == (T)rhs; }      }         return ( m_int == 0 ? false : true ) == rhs;     {     bool operator ==( bool rhs ) const throw()     // Need an explicit override for type bool      }         return EqualityTest< T, U, ValidComparison< T, U >::method >::IsEquals( m_int, rhs );     {     bool operator ==( U rhs ) const throw()      template < typename U >     // Equality      }         return m_int <= (T)rhs;     {     bool operator <=( SafeInt< T, E > rhs ) const throw()      }         return !GreaterThanTest< T, U, ValidComparison< T, U >::method >::GreaterThan( m_int, rhs );     {     bool operator <=( U rhs ) const throw()      template < typename U >     // Less than or eq.      }         return m_int > (T)rhs;     {     bool operator >( SafeInt< T, E > rhs ) const throw()      }         return GreaterThanTest< T, U, ValidComparison< T, U >::method >::GreaterThan( m_int, rhs );     {     bool operator >( U rhs ) const throw()     template < typename U >     // Greater than      }         return m_int >= (T)rhs;     {     bool operator >=( SafeInt< T, E > rhs ) const throw()      }         return !GreaterThanTest< U, T, ValidComparison< U, T >::method >::GreaterThan( rhs, m_int );     {     bool operator >=( U rhs ) const throw()      template < typename U >     // Greater than or eq.      }         return m_int < (T)rhs;     {     bool operator <( SafeInt< T, E > rhs ) const throw()      }         return GreaterThanTest< U, T, ValidComparison< U, T >::method >::GreaterThan( rhs, m_int );     {     bool operator <( U rhs ) const throw()     template < typename U > ad  ;        p       ¿  ø  §  é  à  á  t  W      ⁄  ù  ú  d  ^  ]  @  ˙  Ù  ≤  u  t  ;  5  4    ˙  ∆  ¿  Å  D  C  +        Ú  ∞  ™  h  (  '    ˆ
+  
+  Ô
+  ÷
+  å
+  O
+  N
+  =
+  ˘	  Û	  ¡	  ª	  ∫	  û	  h	  b	  -	  Ô  ∂  ´  n  1  Ù  Û  ®  X      Æ  ®  ß  ã  K  E  ,        Ú  ¿  ∫  `  J  D  C  &  Ê  ‡  É  m  g  f  [      ÿ  “  —  µ    y  .  ﬁ  °  †  4  .  -                                                                     // XOR assignment      }         return SafeInt< T, E >( BinaryXorHelper< T, U, BinaryMethod< T, U >::method >::Xor( m_int, rhs ) );          // so that it works like you meant, not unexpectedly         // was causing unexpected behavior. Fix is to properly cast your inputs         // If you land in the assert, this is because the bitwise operator     {     SafeInt< T, E > operator ^( U rhs ) const throw()     template < typename U >      }         return SafeInt< T, E >( (T)( m_int ^ (T)rhs ) );     {     SafeInt< T, E > operator ^( SafeInt< T, E > rhs ) const throw()     // XOR      }         return *this;         m_int = BinaryAndHelper< T, U, BinaryMethod< T, U >::method >::And( m_int, (U)rhs );     {     SafeInt< T, E >& operator &=( SafeInt< U, E > rhs ) throw()     template < typename U >       }         return *this;         m_int = BinaryAndHelper< T, U, BinaryMethod< T, U >::method >::And( m_int, rhs );     {     SafeInt< T, E >& operator &=( U rhs ) throw()     template < typename U >       }         return *this;         m_int &= (T)rhs;     {     SafeInt< T, E >& operator &=( SafeInt< T, E > rhs ) throw()     // Bitwise & assignment      }         return SafeInt< T, E >( BinaryAndHelper< T, U, BinaryMethod< T, U >::method >::And( m_int, rhs ) );          // so that it works like you meant, not unexpectedly         // was causing unexpected behavior. Fix is to properly cast your inputs         // If you land in the assert, this is because the bitwise operator          // which then sign extends rhs, setting all the bits         // normal behavior is to upcast both sides to an int         // programmer intent is to get only the lower 8 bits         //         //                      rhs = char, value = 0xff         // consider the case of lhs = int, value = 0xffffffff         // we want to avoid setting bits by surprise     {     SafeInt< T, E > operator &( U rhs ) const throw()     template < typename U >      }         return SafeInt< T, E >( m_int & (T)rhs );     {     SafeInt< T, E > operator &( SafeInt< T, E > rhs ) const throw()     // Bitwise &      // demand a type T, or something that fits into a type T     // This only makes sense if we're dealing with the same type and size     // Bitwise operators      }         return *this;         m_int >>= (U)bits;          ShiftAssert( (U)bits < (int)IntTraits< T >::bitCount );         ShiftAssert( IntTraits< U >::greaterEqualZero((U)bits) );     {     SafeInt< T, E >& operator >>=( SafeInt< U, E > bits ) throw()     template < typename U >      }         return *this;         m_int >>= bits;          ShiftAssert( bits < (int)IntTraits< T >::bitCount );         ShiftAssert( IntTraits< U >::greaterEqualZero(bits) );     {     SafeInt< T, E >& operator >>=( U bits ) throw()     template < typename U >     // Right shift assignment      }         return SafeInt< T, E >( (T)(m_int >> (U)bits) );          ShiftAssert( bits < (int)IntTraits< T >::bitCount );         ShiftAssert( IntTraits< U >::greaterEqualZero((U)bits) );     {     SafeInt< T, E > operator >>( SafeInt< U, E > bits ) const throw()     template < typename U >       }         return SafeInt< T, E >( (T)( m_int >> bits ) );          ShiftAssert( bits < (int)IntTraits< T >::bitCount );         ShiftAssert( IntTraits< U >::greaterEqualZero(bits) );     {     SafeInt< T, E > operator >>( U bits ) const throw()     template < typename U >      // Right shift      }         return *this;         m_int <<= (U)bits;          ShiftAssert( (U)bits < (int)IntTraits< T >::bitCount ); ad          {       ¿  ∫  °  ã  Ö  Ñ  g  5  /  ’  ø  π  ∏  õ  [  U  ¯  ‚  ‹  €  …  Ö    F  @  ?  #  Ì  Á  }  w  v  Y      ˙  ‰  ﬁ  ›  ¿  é  à  0        ˆ
+  ∂
+  ∞
+  U
+  ?
+  9
+  8
+  
+  §	  û	  n	  A	  ;	  :	  Ã  ∆  ñ  i  c  b  3  -    ¯  ›  ◊  ÷  ù  ó  u  o  n  2  ,  
+        Í  ÷  ¬  Æ  ô  Ñ  o  Y  D  =  <    ˘  Û  —  ∏  û  ù  Z  ¯  †  Y  X  ˘  ò  K  J      ‡  ﬂ  ∆  ¢  ù  á  Å  Ä  ]                            const SafeInt< T, E >& Align2()  { return Align< align2 >(); }     // Commonly needed alignments:      }         return *this;                  E::SafeIntOnOverflow();         if( m_int <= 0 )          m_int = ( m_int + AlignValue ) & ~AlignValue;          const T AlignValue = ( (T)1 << bits ) - 1;                      bits >= 0 && ( !IntTraits<T>::isSigned || m_int > 0 ) );                     || ( !IntTraits<T>::isSigned && bits < (int)IntTraits< T >::bitCount ) ) &&          ShiftAssert( ( ( IntTraits<T>::isSigned && bits < (int)IntTraits< T >::bitCount - 1 )           // Also makes no sense to try to align on negative or no bits.         // or signed numbers on bitCount-1 (e.g., 7 bits = 128, signed char max = 127).         // Can't align unsigned numbers on bitCount (e.g., 8 bits = 256, unsigned char max = 255)         // We don't support aligning negative numbers at this time              return *this;         if( m_int == 0 )         // Zero is always aligned     {     const SafeInt< T, E >& Align()     template < alignBits bits >      };         align256 = 8         align128 = 7,         align64 = 6,         align32 = 5,         align16 = 4,         align8 = 3,         align4 = 2,         align2 = 1,     {     enum alignBits      }         return SafeTtoI( input );     {     static SafeInt< T, E > SafeWtoI( const wchar_t* input )      }         return SafeTtoI( input );     {     static SafeInt< T, E > SafeAtoI( const char* input )      }         with.m_int = temp;         m_int = with.m_int;         T temp( m_int );     {     void Swap( SafeInt< T, E >& with ) throw()      }         return tmp > upper ? (T)upper : tmp;         T tmp = test > m_int ? (T)test : m_int;     {     SafeInt< T, E > Max( SafeInt< T, E > test, SafeInt< T, E > upper = IntTraits< T >::maxInt ) const throw()      }         return tmp < floor ? (T)floor : tmp;         T tmp = test < m_int ? (T)test : m_int;     {     SafeInt< T, E > Min( SafeInt< T, E > test, SafeInt< T, E > floor = IntTraits< T >::minInt ) const throw()     // Miscellaneous helper functions      }         return *this;         m_int = BinaryOrHelper< T, U, BinaryMethod< T, U >::method >::Or( m_int, (U)rhs );     {     SafeInt< T, E >& operator |=( SafeInt< U, E > rhs ) throw()     template < typename U >       }         return *this;         m_int = BinaryOrHelper< T, U, BinaryMethod< T, U >::method >::Or( m_int, rhs );     {     SafeInt< T, E >& operator |=( U rhs ) throw()     template < typename U >       }         return *this;         m_int |= (T)rhs;     {     SafeInt< T, E >& operator |=( SafeInt< T, E > rhs ) throw()     // bitwise OR assignment      }         return SafeInt< T, E >( BinaryOrHelper< T, U, BinaryMethod< T, U >::method >::Or( m_int, rhs ) );     {     SafeInt< T, E > operator |( U rhs ) const throw()     template < typename U >      }         return SafeInt< T, E >( (T)( m_int | (T)rhs ) );     {     SafeInt< T, E > operator |( SafeInt< T, E > rhs ) const throw()     // bitwise OR      }         return *this;         m_int = BinaryXorHelper< T, U, BinaryMethod< T, U >::method >::Xor( m_int, (U)rhs );     {     SafeInt< T, E >& operator ^=( SafeInt< U, E > rhs ) throw()     template < typename U >       }         return *this;         m_int = BinaryXorHelper< T, U, BinaryMethod< T, U >::method >::Xor( m_int, rhs );     {     SafeInt< T, E >& operator ^=( U rhs ) throw()     template < typename U >       }         return *this;         m_int ^= (T)rhs;     {     SafeInt< T, E >& operator ^=( SafeInt< T, E > rhs ) throw() ad  _   ?     q       Ω  z  6  Ú  Æ  •  †  X    Õ  Ü  ^  B      Û  ÿ  π  ∞  ä  ]  9  8  !      Ú  ’  ¬  ∞  ù  ä  Ä    d  Z  /      Ô
+  ”
+  “
+  ∂
+  é
+  }
+  U
+  T
+  A
+  7
+  6
+  $
+  
+  
+  
+  
+  
+  ﬁ	  ¬	  ¨	  S	  Q	  
+	  	  	  ¬  í  \  Z  ˘  ˜  ˆ  ∆  Ç  Ä        	  Ÿ  £  °  @  >  =    …  «  c  a  `  G    ‡  ﬁ  |  z  y  I      ù  õ  ö  Ñ  T      π  ∑  ∂  Ü  A  ?  >                                                                                                 { bool operator <=( SafeInt< T, E > lhs, SafeInt< U, E > rhs ) throw() template < typename T, typename U, typename E >  }     return !GreaterThanTest< U, T, ValidComparison< U, T >::method >::GreaterThan( lhs, (T)rhs ); { bool operator <=( U lhs, SafeInt< T, E > rhs ) throw() template < typename T, typename U, typename E > // Less than or equal  }     return !GreaterThanTest< U, T, ValidComparison< U, T >::method >::GreaterThan( (U)rhs, (T)lhs ); { bool operator >=( SafeInt< T, E > lhs, SafeInt< U, E > rhs ) throw() template < typename T, typename U, typename E >  }     return !GreaterThanTest< T, U, ValidComparison< T, U >::method >::GreaterThan( (T)rhs, lhs ); { bool operator >=( U lhs, SafeInt< T, E > rhs ) throw() template < typename T, typename U, typename E > // Greater than or equal  }     return GreaterThanTest< T, U, ValidComparison< T, U >::method >::GreaterThan( (T)lhs, (U)rhs ); { bool operator >( SafeInt< T, E > lhs, SafeInt< U, E > rhs ) throw() template < typename T, typename U, typename E >  }     return GreaterThanTest< U, T, ValidComparison< U, T >::method >::GreaterThan( lhs, (T)rhs ); { bool operator >( U lhs, SafeInt< T, E > rhs ) throw() template < typename T, typename U, typename E > // Greater than  }     return GreaterThanTest< T, U, ValidComparison< T, U >::method >::GreaterThan( (T)rhs, (U)lhs ); { bool operator <( SafeInt< U, E > lhs, SafeInt< T, E > rhs ) throw() template < typename T, typename U, typename E >  }     return GreaterThanTest< T, U, ValidComparison< T, U >::method >::GreaterThan( (T)rhs, lhs ); { bool operator <( U lhs, SafeInt< T, E > rhs ) throw() template < typename T, typename U, typename E > // Externally defined functions for the case of U op SafeInt< T, E >  } 	return SafeInt<ptrdiff_t, SafeIntDefaultExceptionHandler>( p1 - p2 ); { SafeInt<ptrdiff_t, SafeIntDefaultExceptionHandler> SafePtrDiff(const P* p1, const P* p2) template <typename P> // Used to squelch warnings // Helper function used to subtract pointers.  };     T m_int;      }         return s;          }             tmp++;                  s -= (T)( *tmp - '0' );             else                 s += (T)( *tmp - '0' );             if( !negative )                  s *= (T)10;             if( (T)s != 0 )                              break;             if( *tmp < '0' || *tmp > '9' )         {         while( *tmp != 0 )          }             break;             tmp++;         case '+':             break;             negative = true;             tmp++;         case '-':         {         switch( *tmp )              E::SafeIntOnOverflow();         if( input == NULL || input[0] == 0 )         // Bad input, or empty string                  bool negative = false;         SafeInt< T, E > s;         U* tmp  = input;     {     static SafeInt< T, E > SafeTtoI( U* input )     template < typename U >     // can be done easily with SafeInt.     // This is here because it is useful, and it is an example of what     // and it won't allow you to overflow your integer.     // but it does not display a typical bug where it isn't possible to set MinInt     // This is almost certainly not the best optimized version of atoi,      private:     const SafeInt< T, E >& Align64() { return Align< align64 >(); }     const SafeInt< T, E >& Align32() { return Align< align32 >(); }     const SafeInt< T, E >& Align16() { return Align< align16 >(); }     const SafeInt< T, E >& Align8()  { return Align< align8 >(); }     const SafeInt< T, E >& Align4()  { return Align< align4 >(); } ad     ›     o       õ  ô  ò  å  n  J      ‹  ⁄  Ÿ  ©  r  p        ‰  ü  ù  ?  =  <  /  ˇ  »  ∆  m  k  j  F    
+  ÿ  ÷  ’  •  `  ^        ˜
+  «
+  é
+  å
+  ^
+   
+  ”	  “	  ∞	  ë	  o	  $	  	  	  ˝  ƒ  ™  ©  n  d  c  D  >  =  ˙  ¯  ˜  Â  ¥  {  y  i    œ  Õ  Ã  ¿  W  U  #  œ  …  ∞  ~  }  N  4  *  È  €  ë  i  ,      ∞  õ  m  l  1  ˆ  ı  ÷  π  £  Ö  ~  /  ›  ‹                       // template specialization in this case. For any real cases where                 // Note - this warning happens because we're not using partial #endif #pragma warning(disable:4307) #pragma warning(push) #if !defined SAFEINT_GCC_HPP                 // Corner case                      return SafeInt< T, E >( -( (T)tmp ) );                 if( IntTraits<T>::isLessEqualMaxInt(tmp) )                      tmp = lhs/(U)( -(T)rhs );                 else                     tmp = lhs/(U)(unsigned __int32)( -(T)rhs );                 if( sizeof(T) == 4 )                 U tmp;                 // any operator casts now do the right thing                 // flip rhs to positive                 // Problem case - normal casting behavior changes meaning             {             if( sizeof( U ) >= 4 && sizeof( T ) <= sizeof( U ) )         {         if( (T)rhs != 0 )         // Now rhs is either negative, or zero              return SafeInt< T, E >( lhs/(T)rhs );         if( (T)rhs > 0 )     {     if( (int)DivisionMethod< U, T >::method ==  (int)DivisionState_UnsignedSigned )     // Corner case - has to be handled seperately { template < typename T, typename U, typename E > SafeInt< T, E > operator /( U lhs, SafeInt< T, E > rhs ) // Division  }     return SafeInt< T, E >(ret);     MultiplicationHelper< T, U, MultiplicationMethod< T, U >::method >::template MultiplyThrow< E >( (T)rhs, lhs, ret );     T ret( 0 ); { SafeInt< T, E > operator *( U lhs, SafeInt< T, E > rhs ) template < typename T, typename U, typename E >  // Multiplication  }     return SafeInt< T, E >( ( SafeInt< U, E >( lhs ) % (T)rhs ) );      }         E::SafeIntOnDivZero();          }             return SafeInt< T, E >( (T)( lhs % (T)rhs ) );                  return 0;             if( IntTraits< T >::equalsMinusOne((T)rhs) )         {         if( rhs != 0 )     {         (bool)IntTraits< T >::isSigned == (bool)IntTraits< U >::isSigned )     if( sizeof(T) == sizeof(U) &&     // same size and same sign     // Fast-track the simple case      // if lhs is negative and rhs is unsigned, this will throw an exception.     // This one may not be safe - bounds check in constructor     // Value of return depends on sign of lhs { SafeInt< T, E > operator %( U lhs, SafeInt< T, E > rhs ) template < typename T, typename U, typename E > // Modulus  }     return !EqualityTest< T, U, ValidComparison< T, U >::method >::IsEquals( lhs, rhs ); { bool operator !=( SafeInt< T, E > lhs, SafeInt< U, E > rhs ) throw() template < typename T, typename U, typename E >  }     return ( (T)rhs == 0 ? false : true ) != lhs; { bool operator !=( bool lhs, SafeInt< T, E > rhs ) throw() template < typename T, typename E >  }     return !EqualityTest< T, U, ValidComparison< T, U >::method >::IsEquals( rhs, lhs ); { bool operator !=( U lhs, SafeInt< T, E > rhs ) throw() template < typename T, typename U, typename E > //not equals  }     return EqualityTest< T, U, ValidComparison< T, U >::method >::IsEquals( (T)lhs, (U)rhs ); { bool operator ==( SafeInt< T, E > lhs, SafeInt< U, E > rhs ) throw() template < typename T, typename U, typename E >  }     return EqualityTest< T, U, ValidComparison< T, U >::method >::IsEquals((T)rhs, lhs); { bool operator ==( U lhs, SafeInt< T, E > rhs ) throw() template < typename T, typename U, typename E >  }     return lhs == ( (T)rhs == 0 ? false : true ); { bool operator ==( bool lhs, SafeInt< T, E > rhs ) throw() template < typename T, typename E > // explicit overload for bool // equality  }     return !GreaterThanTest< T, U, ValidComparison< T, U >::method >::GreaterThan( (T)lhs, (U)rhs ); ad     Ì     s       Ø  ~  U  C    ⁄  »  ´  ñ  è  é  f  X  W  '      ˝  Õ  Ã  ù  ó  [  Q  	  º  å  `      √  ü  ï  è  é  5  *  ø
+  ú
+  ö
+  ô
+  ç
+  ]
+  $
+  "
+  
+  •	  Ç	  Ä	  	  p	  @	  	  	  ı  ~  }  Z  X  W    Õ  «  ó  i  g  W  Í  €  À  …  »  ò  j  h  X  Â  ÷  ∆  ƒ  √  ì  e  c  S  ⁄  À  ª  π  ∏  à  Z  X  H  ›  Œ  æ  º  ª  ã  ]  [  K  ﬂ  –  ¿  æ  Ω  ç  W  U       Ó  Ì  Ï        }     return lhs;     lhs = BinaryAndHelper< T, U, BinaryMethod< T, U >::method >::And( lhs, (U)rhs ); { T& operator &=( T& lhs, SafeInt< U, E > rhs ) throw() template < typename T, typename U, typename E >  }     return lhs;     lhs = ret;     ModulusHelper< T, U, ValidComparison< T, U >::method >::template ModulusThrow< E >( lhs, (U)rhs, ret );     T ret( 0 ); { T& operator %=( T& lhs, SafeInt< U, E > rhs ) template < typename T, typename U, typename E >  }     return lhs;     lhs = ret;     DivisionHelper< T, U, DivisionMethod< T, U >::method >::template DivideThrow< E >( lhs, (U)rhs, ret );     T ret( 0 ); { T& operator /=( T& lhs, SafeInt< U, E > rhs ) template < typename T, typename U, typename E >  }     return lhs;     lhs = ret;     MultiplicationHelper< T, U, MultiplicationMethod< T, U >::method >::template MultiplyThrow< E >( lhs, (U)rhs, ret );     T ret( 0 ); { T& operator *=( T& lhs, SafeInt< U, E > rhs ) template < typename T, typename U, typename E >  }     return lhs;     lhs = ret;     SubtractionHelper< T, U, SubtractionMethod< T, U >::method >::template SubtractThrow< E >( lhs, (U)rhs, ret );     T ret( 0 ); { T& operator -=( T& lhs, SafeInt< U, E > rhs ) template < typename T, typename U, typename E >  }     return lhs;     lhs = ret;     AdditionHelper< T, U, AdditionMethod< T, U >::method >::template AdditionThrow< E >( lhs, (U)rhs, ret );     T ret( 0 ); { T& operator +=( T& lhs, SafeInt< U, E > rhs ) template < typename T, typename U, typename E > // += // to a normal int - this at least makes the last operation safe // Overrides designed to deal with cases where a SafeInt is assigned out  }     return SafeInt< T, E >( ret );      SubtractionHelper< U, T, SubtractionMethod2< U, T >::method >::template SubtractThrow< E >( lhs, rhs.Ref(), ret );     T ret( 0 ); { SafeInt< T, E > operator -( U lhs, SafeInt< T, E > rhs ) template < typename T, typename U, typename E > // Subtraction  }     return SafeInt< T, E >( ret );     AdditionHelper< T, U, AdditionMethod< T, U >::method >::template AdditionThrow< E >( (T)rhs, lhs, ret );     T ret( 0 ); { SafeInt< T, E > operator +( U lhs, SafeInt< T, E > rhs ) template < typename T, typename U, typename E > // Addition  }     return SafeInt< T, E >( ret );     DivisionHelper< U, T, DivisionMethod< U, T >::method >::template DivideThrow< E >( lhs, (T)rhs, ret );     U ret;     // Otherwise normal logic works with addition of bounds check when casting from U->T      }         }             E::SafeIntOnOverflow();             // If rhs is smaller or the same size int, then -minInt won't work                  return SafeInt< T, E >( (T)( -(T)IntTraits< U >::minInt ) );             if( sizeof( U ) < sizeof( T ) )             // if rhs is a larger type than lhs             // but rhs is the return type, so in essence, we can return -lhs             // corner case of a corner case - lhs = min int, rhs = -1,          {         if( lhs == IntTraits< U >::equalsMinusOne((T)rhs) )     {     if( SafeIntCompare< T, U >::isBothSigned )      } // method == DivisionState_UnsignedSigned         E::SafeIntOnDivZero();          }             return SafeInt< T, E >(lhs/(T)rhs);              }                 E::SafeIntOnOverflow();  #endif #pragma warning(pop) #if !defined SAFEINT_GCC_HPP                 }                     return SafeInt< T, E >( minT );                     T minT = IntTraits< T >::minInt;                 {                 if( tmp == (U)maxT + 1 )                 T maxT = IntTraits< T >::maxInt;                 // this block isn't optimized out, the warning won't be present. ad  -        r       –  ö  ò  C  3  1  0        »  u  e  c  b  2  ˚  ˘  ∆  ∂  ¥  ≥  É  L  J          Ê  ≥  x  0     –  Œ  í  F    ø
+  n
+  (
+  Æ	  û	  ú	  õ	  k	  ;	  9	  ˝  ¥  ñ      
+  	  Ÿ  ©  ß  y  Y  @  >  =    ›  €  ≠  ç  t  r  q  A      ·  ¡  ®  ¶  •  u  E  C    ı  ‹  ⁄  Ÿ  ©  y  w  I  )        ›  ≠  ´  }  ]  D  B  A    ‡  ﬁ  ∞  ê  w  u  t  D                                                     { T*& operator >>=( T*& lhs, SafeInt< U, E > rhs ) template < typename T, typename U, typename E >  }     return (lhs = NULL);     C_ASSERT( sizeof(T) == 0 );     // This operator explicitly not supported { T*& operator <<=( T*& lhs, SafeInt< U, E > rhs ) template < typename T, typename U, typename E >  }     return (lhs = NULL);     C_ASSERT( sizeof(T) == 0 );     // This operator explicitly not supported { T*& operator |=( T*& lhs, SafeInt< U, E > rhs ) template < typename T, typename U, typename E >  }     return (lhs = NULL);     C_ASSERT( sizeof(T) == 0 );     // This operator explicitly not supported { T*& operator ^=( T*& lhs, SafeInt< U, E > rhs ) template < typename T, typename U, typename E >  }     return (lhs = NULL);     C_ASSERT( sizeof(T) == 0 );     // This operator explicitly not supported { T*& operator &=( T*& lhs, SafeInt< U, E > rhs ) template < typename T, typename U, typename E >  }     return (lhs = NULL);     C_ASSERT( sizeof(T) == 0 );     // This operator explicitly not supported { T*& operator %=( T*& lhs, SafeInt< U, E > rhs ) template < typename T, typename U, typename E >  }     return (lhs = NULL);     C_ASSERT( sizeof(T) == 0 );     // This operator explicitly not supported { T*& operator /=( T*& lhs, SafeInt< U, E > rhs ) template < typename T, typename U, typename E >  }     return (lhs = NULL);     C_ASSERT( sizeof(T) == 0 );     // This operator explicitly not supported { T*& operator *=( T*& lhs, SafeInt< U, E > rhs ) template < typename T, typename U, typename E >  }     return lhs;     lhs = reinterpret_cast< T* >( (uintptr_t)( ptr_val - (ptrdiff_t)( SafeInt< ptrdiff_t, E >( rhs ) * sizeof( T ) ) ) );     // See above for comments     SafeInt< size_t, E > ptr_val = reinterpret_cast< uintptr_t >( lhs );     // Cast the pointer to a number so we can do arithmetic { T*& operator -=( T*& lhs, SafeInt< U, E > rhs ) template < typename T, typename U, typename E >  }     return lhs;     lhs = reinterpret_cast< T* >( (uintptr_t)( ptr_val + (ptrdiff_t)( SafeInt< ptrdiff_t, E >( rhs ) * sizeof( T ) ) ) );     // Finally, cast the number back to a pointer of the correct type     // Next, we need to add 2 SafeInts of different types, so unbox the ptr_diff     // and that multiplying by sizeof( T ) doesn't overflow a ptrdiff_t     // Check first that rhs is valid for the type of ptrdiff_t     SafeInt< uintptr_t, E > ptr_val = reinterpret_cast< uintptr_t >( lhs );     // Cast the pointer to a number so we can do arithmetic { T*& operator +=( T*& lhs, SafeInt< U, E > rhs ) template < typename T, typename U, typename E > // that no int overflows happened on the way to getting the new pointer // that the resulting pointer is still in the buffer, only // Note - this function makes no attempt to ensure // Specific pointer overrides  }     return lhs;     lhs = (T)( SafeInt< T, E >( lhs ) >> (U)rhs ); { T& operator >>=( T& lhs, SafeInt< U, E > rhs ) throw() template < typename T, typename U, typename E >  }     return lhs;     lhs = (T)( SafeInt< T, E >( lhs ) << (U)rhs ); { T& operator <<=( T& lhs, SafeInt< U, E > rhs ) throw() template < typename T, typename U, typename E >  }     return lhs;     lhs = BinaryOrHelper< T, U, BinaryMethod< T, U >::method >::Or( lhs, (U)rhs ); { T& operator |=( T& lhs, SafeInt< U, E > rhs ) throw() template < typename T, typename U, typename E >  }     return lhs;     lhs = BinaryXorHelper< T, U, BinaryMethod< T, U >::method >::Xor( lhs, (U)rhs ); { T& operator ^=( T& lhs, SafeInt< U, E > rhs ) throw() template < typename T, typename U, typename E > ad     &     >       }  K  …  G  ˇ  {  I  ƒ  Ü    ¬  =  ª
+  :
+  Ê	  `	  	  	  î  ì  ê  H  ˛  ¥  ≤  g    –  ¡  Ω  Ç  Ä  3  &  $  ˜  Û  ß  ó  ï  C  ¯  Ø  â  á  T  
+    ∆  ~  O  M    ∞  Ö  É  9  Í  ô  F  (  &  %                    * *  performs most efficiently. *  unsigned integer types - certain types of problems cannot occur, and this class *  especially for signed numbers. If you do not _require_ negative numbers, use  *  build (especially with /Ox), but it does have significantly more overhead,  *  Many of the conditionals will optimize out or be inlined for a release * *  Notes below for additional information. *  integrity of the calculations is more important than performance. See Performance *  The SafeInt class should be used in any circumstances where ensuring * *         the address of the internal integer. *  Note - the '&' (address of) operator has been overloaded and returns *  SafeInt::Ptr()   - returns the address of the internal integer * *  Version 3 note - it now compiles correctly for size_t without warnings *  Casting operators for every native integer type * *  are two methods that are provided: *  an ambiguous compile-time precedence. Because of this amiguity, there *  this is that if there is an implicit cast operator, then we end up with *  One key operator that is missing is an implicit cast to type T. The reason for * *  acceptable.  *  This situation would mean that safety would depend on usage, which isn't *   *  char i = (char)64 + (char)64; //overflow! * *  you have: *  The * operators take precedence, get overloaded, return a char, and then  * *  char i = SafeInt<char>(32) * 2 + SafeInt<char>(16) * 4; *   *  can happen: *  allowed an operator to return a base integer type T, then the following  *  requires that every operation return either a SafeInt or a bool. If we  *  A usability-safety trade-off has been made to help ensure safety. This  * *  Nearly every operator has been overloaded, with a very few exceptions. *  while still ensuring that all integer operations are conducted safely. *  The SafeInt class is designed to have as low an overhead as possible /*  ************************************************************************************************************************************/                                       this option is not recommended. SAFEINT_DISABLE_SHIFT_ASSERT       - Set this option if you don't want to assert when shifting more bits than the type has. Enabling                                       This lets you not have your compiler complain. SIZE_T_CAST_NEEDED                 - some compilers complain if there is not a cast to size_t, others complain if there is one.                                       this, the default is to assert. Set this if you prefer not to assert under these conditions. SAFEINT_DISABLE_BINARY_ASSERT      - binary AND, OR or XOR operations on mixed size types can produce unexpected results. If you do                                       option is not recommended. ANSI_CONVERSIONS                   - This changes the class to use default comparison behavior, which may be unsafe. Enabling this                                       to compile, define this. SAFEINT_DISALLOW_UNSIGNED_NEGATION - Invoking the unary negation operator creates warnings, but if you'd like it to completely fail                                       define this. SafeIntDefaultExceptionHandler     - if you'd like to replace the exception handlers SafeInt provides, define your replacement and                                       how you landed in the catch block. SAFEINT_ASSERT_ON_EXCEPTION        - it is often easier to stop on an assert and figure out a problem than to try and figure out  NEEDS_INT_DEFINED                  - if your compiler does not support __int8, __int16, __int32 and __int64, you can enable this.                                      recommended. SAFEINT_WARN_64BIT_PORTABILITY     - this re-enables various warnings that happen when /Wp64 is used. Enabling this option is not  ad  3   Û     i       ¿  æ  Ç  }  Q  O  ;  9  !        Ú    ‚  ›  —  œ  Æ  ¢  ù  õ  T    È  Á  Ã     º  ∑  z  x  n  ^  R  K  *  #    ˇ  ˙  ¯  ≥  P      “  œ  ∆  Ñ    ?  :  9  ¯
+  Û
+  π
+  ¥
+  ∞
+  Æ
+  R
+  
+  
+  ‘	  û	  ò	  O	  M	  =	  ;	  Í  ë  .  Ù  Ú  õ  j    Ë  ç  5  ›  è  ç  ã  u    ¶  í  ê     ±  U  S  ?  ;  Â  õ  ó  s  M  '    ˜  Û  Ú                                                     *   *  U op SafeInt< T, E > *  SafeInt< T, E > op U *  SafeInt< T, E > op SafeInt< T, E > *  There are three possible variants: *  Arithmetic Operators (*,/,+,-,%) *   *  This is to ensure correctness. Notes on each class of operator follow: *  All of the binary operators have certain assumptions built into the class design.  *   *  Binary Operators * *  Additionally, there was a lot of work done to better optimize the 64-bit multiplication. *  and using some additional cases (e.g. signed __int64 and unsigned __int64) resulted in some simplification. *  3.0 update - not only have we maintained the specialization, there were some cases that were overly complex, * *  of debug builds. *  operator implementation needed for any given pair of types. This will dramatically improve the perf *  The current version of SafeInt uses template specialization to force the compiler to invoke only the *  Performance update * * *     actually ints. For best performance, cast literals to the type desired. *     different integer sizes and types may prove expensive. Be aware that literals are *     possible keep them all the same size. 64-bit integers are also expensive. Mixing  *  3) Some operations are more difficult than others - avoid using signed integers, and if *     exact same checks as the class uses. *  2) If that 8% hit is really a serious problem, walk through the code and inline the *     (optimize for size) does not work as well. *  1) Compile optimized code - /Ox is best, /O2 also performs well. Interestingly, /O1 * *  most of which is due to exception handling. Solutions: *  in native code, this class has been found to take approximately 8% more CPU time (this varies), *  performance in unoptimized code. In tests of optimized code vs. correct inline checks *  Due to the highly nested nature of this class, you can expect relatively poor * *  Performance: * *     #define SafeIntDefaultExceptionHandler YourSafeIntExceptionHandler *  or *     SafeInt< int, YourSafeIntExceptionHandler > si; *  2) Either explicitly declare SafeInts like so: * *  anything you like, just don't return from the call back into the code. *  Note that you don't have to throw C++ exceptions, you can throw Win32 exceptions, or do  * 	}; 		 } 			  throw YourException( YourSafeIntDivideByZeroError ); 		 { 		 static __declspec(noreturn) void __stdcall SafeIntOnDivZero()  		 } 			  throw YourException( YourSafeIntArithmeticOverflowError ); 		 { 		 static __declspec(noreturn) void __stdcall SafeIntOnOverflow() 	public: 	{    template <> class YourSafeIntExceptionHandler < YourException > *   *  1) Create a class that has the following interface: *  You can replace the exception class with any exception class you like. This is accomplished by: *  Update for 3.0 - the exception class is now a template parameter. * *  } *    } *       //handle errors here *    { *    catch(SafeIntException err) *    } *      .... *      s *= 23; *    try{ * *    SafeInt<unsigned long> s; //note that s == 0 unless set *  { *  bool foo() * *  Typical usage might be: * *  which contain an enum as a code. *  objectionable happens. The exceptions are SafeIntException classes, *  Error handling - a SafeInt class will throw exceptions if something * *  } *      .... *    for(i = 0; i < 0xffff; i++) * *    int i; *  { *  void foo() * *  Here's when it should NOT be used: * *  } * *     return malloc(s); * *     s *= HowMany; * *     SafeInt<unsigned long> s(StructSize); *  { *  void* AllocateMemForStructs(int StructSize, int HowMany) * *  Here's an example of when the class should ideally be used - ad     s     T       õ  f  b  8  4  ÿ  }     ˙  ˆ  ÿ  ¬  æ  ®  §  å  0  $       ∞  m  i  T  Ù  ô  å  à  t      ˝
+  Â
+  ·
+  —
+  »
+  ƒ
+  å
+  .
+  ≈	  X	  	  	  ˇ  ˝  £  G  Í  å  t  r    ª  í  ê  ?  ﬂ  ›  Ä  E  A  !      ˇ  Õ  …  h    ™  ü  õ  z  H  @  ˆ  Ú  û  M  K      ®  s  r         *  8, 16, and 32-bit signed int, unsigned 32-bit int *  into your source. Behavior differences occur in the following cases: *  #define ANSI_CONVERSIONS  *  If you prefer to retain the ANSI standard behavior insert  * *  changed "unsigned int" above to "unsigned short", you'd get the right answer. *  Note that combinations with smaller integers won't display the problem - if you  *   *    printf("Why doesn't the compiler upcast to 64-bits when needed?\n"); *  else *    printf("Why is -1 equal to 4 billion???\n"); *  if((__int64)c == (__int64)l)) *   *  answer: *  an __int64 exists, and the following code will yield a different (and intuitively correct) *  cast again to an unsigned int, losing the true value. This behavior is despite the fact that *  The problem here is that c gets cast to an int, now has a value of 0xffffffff, and then gets  *   *    printf("Why is -1 equal to 4 billion???\n"); *  if(c == l) *   *  char c = -1; *  unsigned int l = 0xffffffff; *   *  arguably broken. As an example, consider the following: *  The comparison operator behavior in this class varies from the ANSI definition, which is  * *  Unless you're actually assigning it to something, ++SafeInt is less expensive than SafeInt++ *  Perf note - postfix operators are slightly more costly than prefix operators. * *  not enabled at /W3 (default for VC++) *  - there are a number of warnings which pertain to integer manipulation enabled that are  *  It is strongly recommended that any code doing integer manipulation be compiled at /W4  * *  been tried recently. *  of them work with Visual C++ 6, and gcc didn't work very well, either, though this hasn't  *  If you need a version that will work with lower level compilers, try version 1.0.7. None  *  As of this writing, I believe it will also work for VC 7.1, but not for VC 7.0 or below. *  This header compiles correctly at /W4 using VC++ 8 (Version 14.00.50727.42) and later. * *  Documented issues: *   *  properly so that you are not programming with side effects. *  result than the underlying operator, it will call assert(). You should examine your code and cast things  *  cases do exist where you could get unexpected results. In any case where SafeInt returns a different  *  In the case of binary operations on integers smaller than 32-bit, or of mixed type, corner *  The "0x02" is actually an int, and it needs to work. *   *    ... *  if(c & 0x02) *   *  SafeInt<char> c = 2; *   *  enable things like: *  Mixed-type operations are discouraged, however some provision has been made in order to  *  Binary Operators *   *  operator. *  are allowed. Additionally, specific overloads exist for type bool on both sides of the  *  Like comparison operators, these overloads always return type bool, and mixed-type SafeInts  *  Boolean Operators *   *  operations are allowed because the return type is always known. *  Shift operators always return the type on the left hand side of the operator. Mixed type  *  Shift Operators *   *  allowed. *  Because each of these operators return type bool, mixing SafeInts of differing types is  *  Comparison Operators *   *  result = t * (U)u; *   *  SafeInt< U, E > u; *  SafeInt< T, E > t, result; *   *  the casting operator. For example: *  you need to do this, you need to extract the value contained within one of the two using  *  The compiler cannot know whether you'd prefer to get a type T or a type U returned. If  *  This is because the arithmetic operators are required to return a SafeInt of some type.  *   *  error C2593: 'operator *' is ambiguous *   *  this the compiler with throw the following error: *  The SafeInt< T, E > op SafeInt< U, E > variant is explicitly not supported, and if you try to do  ad  J   v     D       Ÿ  õ  ó  ì  ~  |  b  /  -  ‚  Ã  í  n  +  Ÿ  ¡  ñ  A    º  õ  d  L    π  õ  É  H  /  „
+  á
+  +
+  ‘	  à	  ?	  =	  &	  Ã  |  5  Í  ©  X  A  Ó  Õ  à  O    ¡  ™  _    ‹  ù  F        ∑  Å  R  ˚  ©  6  4  Ÿ  v  u                                                                            *  not C++ style static_cast< T >. This is because the class is nearly always dealing with integer *  Note about code style - throughout this class, casts will be written using C-style (T), * *                 Also updating some of the header internals to be the same as the upcoming Visual Studio version. *                 for determining not just the issues, but also suggesting fixes. *                 Changes needed to support gcc compiler - many thanks to Niels Dekker *  Nov 22, 2009   Forked from MS internal code *  April, 2007    Extensive revisions for version 3.0 *                 Extensive revisions to leverage template specialization. *  Apr 12, 2005 - 2.0 * *                 Added throw() decorations *                 Fixed bug in MixedSizeMultiply and MixedSizeDivision with input of 0 *                 Fixed bug in corner case of MixedSizeModulus *                 after that may be dangerous. *                 Created overloads for cases of U op= SafeInt. What you do with U  *                 Implemented specialized operators for pointer arithmetic *  Dec 1, 2004 - 1.0.7 *                 Re-implemented casting operator as a result of removing Value method *                 Removed unsafe SafeInt::Value method *                 Defined __int32 as int instead of long *                 Fixed casting operator because char != signed char *                 implicit casts *                 Implemented new logic in binary operators to resolve issues with *  Nov 5, 2004 - 1.0.6 *                 Fixed broken >= and <= operators for type U op SafeInt< T, E > *                  Corrected a couple of missing const modifiers *                 Added cast operator for type long, since long != __int32 *                 Commented out the destructor - major perf gains here *                 Made handlers for DIV0 and overflows individually overridable *                 Added support for SEH exceptions instead of C++ exceptions - Win32 only *  Oct 1, 2004 - 1.0.5 * *                 Cleaned up several const issues (more thanks to Niels) *                 Updated usage information - see important new perf notes. *                 Added casts for base integer types (as per Scott Meyers' suggestion) *                 Made internal type of SafeIntException an enum (as per Niels' suggestion) *                 Pulled error handler out into function to enable user-defined replacement *                 Tightened logic in addition check (saving 2 instructions) *  July 22, 2004 - 1.0.4 *                 Corrected bug in one case of GreaterThan *  May 10, 2004 - 1.0.3 *                 portability *                 Consistently used __int16, __int32 and __int64 to ensure *                 Minor changes to remove dependency on Windows headers *  Feb 12, 2004 - 1.0.2 *                 Thanks to Niels Dekker for the input *                 reserved names *                 Also changed name of private method to comply with standards on  *                 not compiling on some compilers *                 fixed a construct in two mixed-type assignment overloads that was  *                 changed WCHAR to wchar_t *  Jan 28, 2004 - 1.0.1 *                 added extended support for mixed-type operations where possible *                 also fixed broken __int64 multiplication section *                 thanks to vikramh *                 added support for mixed-type operations *  Dec 28, 2003 - 1.0 *  Oct 27, 2003 - fixed numerous items pointed out by michmarc and bdawson * *  Author - David LeBlanc - dleblanc@microsoft.com *  Oct 12, 2003 - Created * *  Revision history: *   *   *  Note - the signed int must be negative to show the problem *  any signed int, unsigned 64-bit int ad          T       õ  2  À  …  \  E  B  ”  †  <  —  î  "    û     £
+  °
+  k
+  2
+  ˆ	  ∏	  t	  9	  ¯  ±  w  ?  
+  –  Õ  ∆  ≈  ®  í  =    ⁄  º  ú  ~  }  Q    ß  â  k  M  F  ?  >  =  	    €  ≈  ±  ó  ê  è  o  I  ,    	    ˆ  Ù  ‹  Ω  •  ¢  °  û  Ü  B  ˜  ´  d  =  „  ‘  “    ~                     * To use your own exception class with SafeInt, first create your exception class, * * native type. * If for some reason you have to translate between the two, cast one of them back to its  * SafeInt< int, YourExceptionHander >. * because a SafeInt< int, MyExceptionHandler > isn't the same thing as * or even the same file. It isn't advisable to do this in the same function * flexibility, and we can mix different error handlers in the same project * Using classes to deal with exceptions is going to allow the most  * Error handler classes /*  };     SafeIntDivideByZero     SafeIntArithmeticOverflow,     SafeIntNoError = 0, { enum SafeIntError  */ ** EXCEPTION_INT_DIVIDE_BY_ZERO ** ERROR_ARITHMETIC_OVERFLOW ** Currently implemented code values: /* catch these to handle errors  #endif #define __int64 long long #define __int32 int #define __int16 short #define __int8  char #ifdef NEEDS_INT_DEFINED //use these if the compiler does not support _intXX   #endif #endif #pragma warning(disable:4267) #pragma warning(disable:4244) #pragma warning(disable:4242) // If actually compiled with the 64-bit compiler, it would pull in a different template specialization. // Internally to SafeInt, these should always be false positives. #if !defined SAFEINT_WARN_64BIT_PORTABILITY  #pragma warning(disable:4310) //cast truncates constant value #pragma warning(disable:4127) // conditional expression is constant - these are used intentionally #pragma warning(disable:4146) //this avoids warnings from the unary '-' operator being applied to unsigned numbers #pragma warning(push) #if !defined SAFEINT_GCC_HPP  * * */ *  * inline bool SafeSubtract( T t, U u, T& result ) throw() * inline bool SafeAdd( T t, U u, T& result ) throw() * inline bool SafeDivide( T t, U u, T& result ) throw() * inline bool SafeMultiply( T t, U u, T& result ) throw() * inline bool SafeModulus( const T& t, const U& u, T& result ) throw() * inline bool SafeLessThanEquals( const T t, const U u ) throw() * inline bool SafeLessThan( const T t, const U u ) throw() * inline bool SafeGreaterThanEquals( const T t, const U u ) throw() * inline bool SafeGreaterThan( const T t, const U u ) throw() * inline bool SafeNotEquals( const T t, const U u ) throw() * inline bool SafeEquals( const T t, const U u ) throw() * inline bool SafeCast( const T From, U& To ) throw() * * for 64-bit porting, since SafeCast compiles away for a 32-bit cast from size_t to unsigned long, but checks it for 64-bit. * All of the following can be invoked without dealing with creating a class, or managing exceptions. This is especially handy * Another major improvement is the addition of external functions - if you just want to check an operation, this can now happen: *  * 4) There is now an Align method. I noticed people use this a lot, and rarely check errors, so now you have one. *    and you can cast it out (or assign) to a float as well. * 3) There is now limited floating point support. You can initialize a SafeInt with a floating point type, * 2) The 64-bit multiplication code has had a lot of perf work done, and should be faster than 2.0. *    those using well-developed exception classes. * 1) The exception type thrown is now replacable, and you can throw your own exception types. This should help *  * Version 3.0 changes: ************************************************************************************************************ * *  be substituted, we'll use the new templatized cast to make it explicit what the operation is doing. *  the code is a little more readable this way. In the event a cast is needed where static_cast couldn't *  types, and in this case static_cast and a C cast are equivalent. Given the large number of casts, ad  G   G     y       ß  L  =  :  ˜  Û  Æ  ¶  h  `  ]      Õ  ≈  ¿  Ω  h  3      ¨  g  d  H  E  +      	  „  ﬁ  €  ±  õ  ò  D  A  5  2  
+  Ì
+  ∑
+  
+  |
+  %
+  Ë	  Â	  è	  \	  V	  	  	  ⁄  ’  ‘  Ω  ª  ≥    U  O  8  2        Ì  ∂  ∞  â  Ç  Å  g  e  +  *  Ë  „  ÿ  º  {  u  /  (    ˙  ∫  ±  ∞  î  T  N  	    ˘  ‘  ö  ë  ã  ä  t  U  P  E  ‹  ”  Æ  h  _  Y  X        ª  ≤  ç  Q  H  G  F                                                                                 }            SafeIntWin32Exception( EXCEPTION_INT_OVERFLOW );            SafeIntExceptionAssert();        {        static __declspec(noreturn) void __stdcall SafeIntOnOverflow()    public:    {    template <> class SafeIntExceptionHandler < SafeIntWin32Exception >     };        }            RaiseException( dwExceptionCode, dwExceptionFlags, 0, 0 );            SafeIntExceptionAssert();        {        SafeIntWin32Exception( DWORD dwExceptionCode, DWORD dwExceptionFlags = EXCEPTION_NONCONTINUABLE )    public:    {    class SafeIntWin32Exception #if defined _WINDOWS_     };        }            throw SafeIntException( SafeIntDivideByZero );            SafeIntExceptionAssert();        { #endif        static __declspec(noreturn) void __stdcall SafeIntOnDivZero() #else        static __attribute__((noreturn)) void SafeIntOnDivZero() #if defined SAFEINT_GCC_HPP         }            throw SafeIntException( SafeIntArithmeticOverflow );            SafeIntExceptionAssert();        { #endif        static __declspec(noreturn) void __stdcall SafeIntOnOverflow() #else        static __attribute__((noreturn)) void SafeIntOnOverflow() #if defined SAFEINT_GCC_HPP    public:    {    template <> class SafeIntExceptionHandler < SafeIntException >     template < typename E > class SafeIntExceptionHandler; { namespace SafeIntInternal  #endif inline void SafeIntExceptionAssert(){} #else inline void SafeIntExceptionAssert(){ assert(false); } #if defined SAFEINT_ASSERT_ON_EXCEPTION  };     SafeIntError m_code;     }         m_code = code;     {     SafeIntException( SafeIntError code )     SafeIntException() { m_code = SafeIntNoError; } public: { class SafeIntException  * */ *    Overall, this is probably the best approach. * *    #define SafeIntDefaultExceptionHandler YourSafeIntExceptionHandler *     *    you can override the default typedef like so: * 3) If you're going to consistently use a different class to handle your exceptions, *  * better, which is the original intent of the SafeInt class. * and so on. The second approach is probably more usable, and will just drop into code *  * typedef SafeInt< char, MyExceptionClass > MySafeChar; * typedef SafeInt< int, MyExceptionClass > MySafeInt; *  * 2) You could create a typedef for every int type you deal with: *  * i.si = 0; *  * You'd lose handy things like initialization - it would have to be initialized as: *  * MySafeInt< int > i; * You'd then declare an instance like so: *  * }; *   SafeInt< T, MyExceptionClass> si; *   public: * { * class MySafeInt * template < typename T > *  * 1) Create a holder class: *  * statements, so you have three options if you find this cumbersome: * Unfortunately, there is no such thing as partial template specialization in typedef *  * SafeInt< int, YourSafeIntExceptionHandler > * You'd then declare your SafeInt objects like this: * typedef SafeIntExceptionHandler < YourExceptionClass > YourSafeIntExceptionHandler *  * }; *     } *         throw YourExceptionClass( EXCEPTION_INT_DIVIDE_BY_ZERO ); *     { *     static __declspec(noreturn) void __stdcall SafeIntOnDivZero() *  *     } *         throw YourExceptionClass( EXCEPTION_INT_OVERFLOW ); *     { *     static __declspec(noreturn) void __stdcall SafeIntOnOverflow() * { * template <> class SafeIntExceptionHandler < YourExceptionClass > *  * For example: * create a template specialization that implements SafeIntOnOverflow and SafeIntOnDivZero. * which may look something like the SafeIntException class below. The second step is to  ad  3   ü     T       Ì     …  Ö  s      Ì  Á  ‰  „  ∏  ]  [  S       Ì  ≈  ƒ  Å  o      „  ‚  √  Ω  º  †  ^  X  E  "  !  ﬁ  Ã  q  d  >  8  5  4  ˚
+  ‚
+  ‡
+  è
+  >
+  Ó	  õ	  =	  ¸  ≤  a    ≥  l  .    ´  o  0        Í  œ  Õ  ≈  º  ∂  ê  0    é  R  Ê  Ñ  "  ˛  ü  a     ü  û                                                                      (IntRegion< T,U >::IntZone_Uint64_Int)        ? MultiplicationState_Uint64Int :                   IntRegion< T,U >::IntZone_UintLT32_Int32)    ? MultiplicationState_CastInt64 :                  (IntRegion< T,U >::IntZone_Uint32_IntLT64 ||                  (IntRegion< T,U >::IntZone_UintLT32_IntLT32)  ? MultiplicationState_CastInt :                  // unsigned-signed                  (IntRegion< T,U >::IntZone_UintLT64_Uint64)   ? MultiplicationState_UintUint64 :                  (IntRegion< T,U >::IntZone_Uint64_Uint)       ? MultiplicationState_Uint64Uint :                   IntTraits< T >::isUint64 && IntTraits< U >::isUint64 ? MultiplicationState_Uint64Uint64 :                   SafeIntCompare< T,U >::isBothUnsigned &&                    IntRegion< T,U >::IntZone_UintLT32_Uint32)   ? MultiplicationState_CastUint64 :                  (IntRegion< T,U >::IntZone_Uint32_UintLT64 ||          method = (IntRegion< T,U >::IntZone_UintLT32_UintLT32  ? MultiplicationState_CastUint :                  // unsigned-unsigned     {     enum public: { class MultiplicationMethod template < typename T, typename U >  };     MultiplicationState_Error     MultiplicationState_Int64Uint64,  // lhs int64, rhs uint64     MultiplicationState_IntInt64,     // lhs int, rhs int64     MultiplicationState_IntUint64,    // lhs int, rhs unsigned int64     MultiplicationState_Int64Int,     // lhs int64, rhs int32     MultiplicationState_Int64Int64,   // lhs int64, rhs int64     MultiplicationState_Int64Uint,    // lhs int64, rhs unsigned int32     MultiplicationState_UintInt64,    // lhs unsigned 32-bit or less, rhs int64     MultiplicationState_UintUint64,   // Both are unsigned, lhs 32-bit or smaller, rhs 64-bit     MultiplicationState_Uint64Int64,  // lhs is unsigned int64, rhs signed int64     MultiplicationState_Uint64Int,    // lhs is unsigned int64, rhs int32     MultiplicationState_Uint64Uint64, // Both are unsigned int64     MultiplicationState_Uint64Uint,   // Both are unsigned, lhs 64-bit, rhs 32-bit or smaller     MultiplicationState_CastUint64,   // Both are unsigned, both 32-bit or smaller     MultiplicationState_CastUint,     // Both are unsigned, smaller than 32-bit     MultiplicationState_CastInt64,    // One or both signed, smaller than 64-bit     MultiplicationState_CastInt = 0,  // One or both signed, smaller than 32-bit { enum MultiplicationState //core logic to determine method to check multiplication  };     }             result = (T)( (T)t % u );         else             result = -(T)( AbsValueHelper< T, GetAbsMethod< T >::method >::Abs( t ) % u );         if(t < 0)         //t could be negative - if so, need to convert to positive              E::SafeIntOnDivZero();         if(u == 0)     {     static void ModulusThrow( const T& t, const U& u, T& result )     template < typename E >      }         return SafeIntNoError;              result = (T)((T)t % u);         else             result = -(T)( AbsValueHelper< T, GetAbsMethod< T >::method >::Abs( t ) % u );         if(t < 0)         //t could be negative - if so, need to convert to positive              return SafeIntDivideByZero;         if(u == 0)     {     static SafeIntError Modulus( const T& t, const U& u, T& result ) throw() public: { template < typename T, typename U > class ModulusHelper< T, U, ComparisonMethod_UnsignedU> // U is unsigned __int64, T any signed int  };     }             result = (T)(t % u);         else             result = (T)(t % AbsValueHelper< U, GetAbsMethod< U >::method >::Abs( u ));         if(u < 0)         // u could be negative - if so, need to convert to positive              E::SafeIntOnDivZero();         if(u == 0) ad     T     ã       ö  Ü  l  k  D  '  !      ÷  å  H  G  ı  Û  Î  û  ò  Ö  ]  \  A      ¯  Í  Œ  ß  ô  è  é  q  R  L  K  /  Ì  Á  ‘  ±  ∞  ï  i  _  H  5  +  *          ¨
+  ™
+  ¢
+  U
+  O
+  <
+  
+  
+  ¯	  Ã	  ¬	  ™	  á	  }	  |	  _	  @	  :	  9	  	  €  ’  ¬  ü  û  É  S  I  2        ˜  Ò  Ó  Ì  í  ê  à  ;  5  "  ˙  ˘  …  ±  §  q  p  Q  K  J  .  Ï  Ê  ”  ∞  Ø  Å  i  \  )  #       Ò  ñ  î  å  ?  9  &  ˛  ˝  π  u  c       ﬂ  ﬁ  ø  π  ∏  ú  Z  T  S                  {     static void ModulusThrow( const T& t, const U& u, T& result )     template < typename E >      }         return SafeIntNoError;              result = (T)(t % u);         else             result = (T)(t % AbsValueHelper< U, GetAbsMethod< U >::method >::Abs(u));         if(u < 0)         // casts below are always safe due to the way modulus works         // u could be negative - if so, need to convert to positive              return SafeIntDivideByZero;         if(u == 0)     {     static SafeIntError Modulus( const T& t, const U& u, T& result ) throw() public: { template < typename T, typename U > class ModulusHelper< T, U, ComparisonMethod_UnsignedT> // T is unsigned __int64, U is any signed int  };     }             result = (T)((__int64)t % (__int64)u);         else             result = 0;         if(IntTraits< U >::equalsMinusOne(u))              E::SafeIntOnDivZero();         if(u == 0)     {     static void ModulusThrow( const T& t, const U& u, T& result )     template < typename E >      }         return SafeIntNoError;              result = (T)((__int64)t % (__int64)u);         else             result = 0;         if(IntTraits< U >::isSigned && u == -1)              return SafeIntDivideByZero;         if(u == 0)     {     static SafeIntError Modulus( const T& t, const U& u, T& result ) throw() public: { template < typename T, typename U > class ModulusHelper< T, U, ComparisonMethod_CastInt64>  };     }         result = (T)(t % u);          }            return;            result = 0;         {         if( IntTraits< U >::equalsMinusOne(u) )         //trap corner case              E::SafeIntOnDivZero();         if(u == 0)     {     static void ModulusThrow( const T& t, const U& u, T& result )     template < typename E >      }         return SafeIntNoError;         result = (T)(t % u);          }             return SafeIntNoError;             result = 0;         {         if(IntTraits<U>::equalsMinusOne(u))         //trap corner case              return SafeIntDivideByZero;         if(u == 0)     {     static SafeIntError Modulus( const T& t, const U& u, T& result ) throw() public: { template <typename T, typename U> class ModulusHelper <T, U, ComparisonMethod_CastInt>  };     }         result = (T)(t % u);          }            return;            result = 0;         {         if(IntTraits<U>::equalsMinusOne(u))         //trap corner case              E::SafeIntOnDivZero();         if(u == 0)     {     static void ModulusThrow( const T& t, const U& u, T& result )     template < typename E >      }         return SafeIntNoError;         result = (T)(t % u);          }             }                 return SafeIntNoError;                 result = 0;             {             if(u == -1)         {         if( IntTraits< U >::isSigned )         //trap corner case              return SafeIntDivideByZero;         if(u == 0)     {     static SafeIntError Modulus( const T& t, const U& u, T& result ) throw() public: { template <typename T, typename U> class ModulusHelper <T, U, ComparisonMethod_Ok>  template <typename T, typename U, int method > class ModulusHelper; // using this set of functions, it can't fail except in a div 0 situation // Modulus is simpler than comparison, but follows much the same logic  };     }         return ( (U)t > u );         // else safe to cast to type U              return false;         if( t < 0 )         // one operand is 32 or 64-bit unsigned, and the other is signed and the same size or smaller ad  d   ,     k       ‹  ∆  ƒ  º  ≥  ≠  ï  p  j  ˘  §  2  Ó  z    ë  ä  É  Ä    >  =  È  Á  ﬂ  è  å  ã  2  0  (  Œ
+  À
+   
+  o
+  m
+  e
+  
+   
+  ˇ	  §	  ¢	  ö	  a	  [	  ˆ  ‚  »  «  °  É  }  z  y        ‹  ÷  q  ]  C  B    ˛  ¯  ı  Ù  ∞  Ø  X  V  N  ¸  ˘  ¯  ú  ö  í  6  3  2  ‘  “     f  c  b      ˙  æ  ∏  R  >  %  $  ˝  ‡  ⁄  ◊  ÷  x  v  n  2  ,  +                                                                                                          {     static bool GreaterThan( const T t, const U u ) throw() public: { template < typename T, typename U > class GreaterThanTest< T, U, ComparisonMethod_UnsignedU >  };     }         return ( t > (T)u );         // else safe to cast to type T              return true;         if( u < 0 )         // one operand is 32 or 64-bit unsigned, and the other is signed and the same size or smaller     {     static bool GreaterThan( const T t, const U u ) throw() public: { template < typename T, typename U > class GreaterThanTest< T, U, ComparisonMethod_UnsignedT >  };     static bool GreaterThan( const T t, const U u ) throw() { return ( (__int64)t > (__int64)u ); } public: { template < typename T, typename U > class GreaterThanTest< T, U, ComparisonMethod_CastInt64 >  };     static bool GreaterThan( const T t, const U u ) throw() { return ( (int)t > (int)u ); } public: { template < typename T, typename U > class GreaterThanTest< T, U, ComparisonMethod_CastInt >  };     static bool GreaterThan( const T t, const U u ) throw() { return ( t > u ); } public: { template < typename T, typename U > class GreaterThanTest< T, U, ComparisonMethod_Ok >  template <typename T, typename U, int state> class GreaterThanTest;  };     }         return ( (U)t == u );         //else safe to cast to type U              return false;         if( t < 0 )         //one operand is 32 or 64-bit unsigned, and the other is signed and the same size or smaller     {     static bool IsEquals( const T t, const U u ) throw() public: { template < typename T, typename U > class EqualityTest< T, U, ComparisonMethod_UnsignedU>  };     }         return ( t == (T)u );         //else safe to cast to type T              return false;         if( u < 0 )         //one operand is 32 or 64-bit unsigned, and the other is signed and the same size or smaller     {     static bool IsEquals( const T t, const U u ) throw() public: { template < typename T, typename U > class EqualityTest< T, U, ComparisonMethod_UnsignedT >  };     static bool IsEquals( const T t, const U u ) throw() { return ( (__int64)t == (__int64)u ); } public: { template < typename T, typename U > class EqualityTest< T, U, ComparisonMethod_CastInt64 >  };     static bool IsEquals( const T t, const U u ) throw() { return ( (int)t == (int)u ); } public: { template < typename T, typename U > class EqualityTest< T, U, ComparisonMethod_CastInt >  };     static bool IsEquals( const T t, const U u ) throw() { return ( t == u ); } public: { template < typename T, typename U > class EqualityTest< T, U, ComparisonMethod_Ok >  template <typename T, typename U, int state> class EqualityTest;  };     }; #endif                                                                                        ComparisonMethod_UnsignedU )                  ( !IntTraits< T >::isSigned )                                       ? ComparisonMethod_UnsignedT :                     ( IntTraits< U >::isSigned && sizeof(T) < 8 ) )                   ? ComparisonMethod_CastInt64 :                  ( ( IntTraits< T >::isSigned && sizeof(U) < 8 ) ||                    ( IntTraits< U >::isSigned && sizeof(T) < 4 && sizeof(U) < 8 ) )  ? ComparisonMethod_CastInt :                  ( ( IntTraits< T >::isSigned && sizeof(T) < 8 && sizeof(U) < 4 ) ||         method = ( ( SafeIntCompare< T, U >::isLikeSigned )                              ? ComparisonMethod_Ok : #else         method = ComparisonMethod_Ok #ifdef ANSI_CONVERSIONS     {     enum public: { class ValidComparison template < typename T, typename U > ad     \     ç       ‚  ‹  Ÿ  ÿ  ì  ë  â  \  V  F  2  ,  +    Â  ﬂ  œ  …  ∆  ≈  r  p  h  >  8  $  
+  	  ˜  ‚  ‹  €  ø  ò  í  ~  Z  Y  G  A  >  =  Î  È  ·  ∑  ±    e  d  R  =  7  6    Û  Ì  ª  ó  ñ  Ñ  ~  {  z        Î
+  Â
+  ß
+  u
+  [
+  Z
+  H
+  3
+  -
+  ,
+  
+  È	  „	  •	  s	  O	  N	  <	  6	  3	  2	  Ÿ  ◊  œ  •  ü  Ñ  =  #  "    ˚  ı  Ù  ÿ  ±  ´  ë  J  &  %      
+  	  µ  ü  ù  Ä  b  B  "       ˇ  µ  ò  j  :     —  ≠  ¶  n    ›  Ø  u  =       ü  ]  \  [                   // Note - the signed int must be negative to show the problem     // any signed int, unsigned 64-bit int     // 8, 16, and 32-bit signed int, unsigned 32-bit int     // Behavior differences occur in the following cases:     // insert #define ANSI_CONVERSIONS into your source     // If you prefer to retain the ANSI standard behavior     // IMHO, -1 should be less than 4 billion     // then you get a different and intuitively correct answer     // a cast to an __int64, which can clearly preserve both value and signedness     // I do not think this makes sense - if you perform     //     // (unsigned int)a < b == false     // is made, and you're essentially testing     // If you then test if a < b, a value-preserving cast     //              unsigned int b = 0xffffffff     // For example, signed char a = -1 = 0xff     // conversion operations     // Note - the standard is arguably broken in the case of some integer  };     ComparisonMethod_UnsignedU     ComparisonMethod_UnsignedT,     ComparisonMethod_CastInt64,     ComparisonMethod_CastInt,     ComparisonMethod_Ok = 0, { enum ComparisonMethod //core logic to determine whether a comparison is valid, or needs special treatment  };     }         t = (T)u;              E::SafeIntOnOverflow();         if( u > IntTraits< T >::maxInt || u < IntTraits< T >::minInt )         //T, U are signed     {     static void CastThrow( U u, T& t )     template < typename E >      }         return true;         t = (T)u;              return false;         if( u > IntTraits< T >::maxInt || u < IntTraits< T >::minInt )         // T, U are signed     {     static bool Cast( U u, T& t ) throw() public: { template < typename T, typename U > class SafeCastHelper < T, U, CastCheckMinMaxSigned >  };     }         t = (T)u;              E::SafeIntOnOverflow();         if( u > IntTraits< T >::maxInt || u < 0 )         // U is signed - T could be either signed or unsigned     {     static void CastThrow( U u, T& t )     template < typename E >      }         return true;         t = (T)u;              return false;         if( u > IntTraits< T >::maxInt || u < 0 )         // U is signed - T could be either signed or unsigned     {     static bool Cast( U u, T& t ) throw() public: { template < typename T, typename U > class SafeCastHelper < T, U, CastCheckMinMaxUnsigned >  };     }         t = (T)u;              E::SafeIntOnOverflow();         if( !IntTraits<T>::isLessEqualMaxInt(u) )     {     static void CastThrow( U u, T& t )     template < typename E >      }         return true;         t = (T)u;              return false;         if( !IntTraits<T>::isLessEqualMaxInt(u) )     {     static bool Cast( U u, T& t ) throw() public: { template < typename T, typename U > class SafeCastHelper < T, U, CastCheckGTMax >  };     }         t = (T)u;              E::SafeIntOnOverflow();         if( u < 0 )     {     static void CastThrow( U u, T& t )     template < typename E >      }         return true;         t = (T)u;              return false;         if( u < 0 )     {     static bool Cast( U u, T& t ) throw() public: { template < typename T, typename U > class SafeCastHelper < T, U, CastCheckLTZero >  };     }        b = !!t;     {     static void CastThrow( bool b, T& t )     template < typename E >      }        return true;        b = !!t;     {     static bool Cast( T t, bool& b ) throw() public: { template < typename T > class SafeCastHelper < bool, T, CastToBool >  };     }         t = (T)( b ? 1 : 0 ); ad     g     å       ’  ≈  √  ≥  û  ä  m  R  A  .      
+  	    ÿ  ƒ  ¬  ∫  ±  ´  v      Á  ë  ê  >  =    …  Ñ  8  ﬁ  ›  ß  n      ∞
+  Q
+  J
+  G
+  F
+  ˇ	  ˝	  ı	  €	  ÿ	  ◊	  è	  ç	  Ö	  k	  h	  g	  	  	  	  ˆ  Û  Ú  Ø  ≠  •  Ñ  Å  Ä  <  :  2        ƒ  ¬  ∫  ô  ñ  ï  V  U    	    ◊  —  æ  ©  £  ¢  Ü  _  Y  F  @  =  <    ˚  ™  ®  †  v  p  B      Ù  €  —  ª  µ  ¥  ò  q  k  =      Ô  €  —  ±  ´  ®  ß  q  *  (     Û  Ì  œ  ∫  ¥  ≥  ó  m  g  f                                 {     static void CastThrow( bool b, T& t )     template < typename E >      }         return true;         t = (T)( b ? 1 : 0 );     {     static bool Cast( bool b, T& t ) throw() public: { template < typename T > class SafeCastHelper < T, bool, CastFromBool > // Match on any method where a bool is cast to type T  };     }         E::SafeIntOnOverflow();         }             return;             t = (T)u;          {             u >= (U)IntTraits< T >::minInt )         if( u <= (U)IntTraits< T >::maxInt &&     {     static void CastThrow( U u, T& t )     template < typename E >      }         return false;         }             return true;             t = (T)u;          {             u >= (U)IntTraits< T >::minInt )         if( u <= (U)IntTraits< T >::maxInt &&     {     static bool Cast( U u, T& t ) throw() public: { template < typename T, typename U > class SafeCastHelper < T, U, CastFromFloat > // tolerate loss of precision // special case floats and doubles  };     }         t = (T)u;      {     static void CastThrow( U u, T& t )     template < typename E >      }         return true;         t = (T)u;      {     static bool Cast( U u, T& t ) throw() public: { template < typename T, typename U > class SafeCastHelper < T, U, CastOK >  template < typename T, typename U, int > class SafeCastHelper;  }; 	enum{ method = CastFromFloat }; public: { template < typename ToType > class GetCastMethod < ToType, long double >  }; 	enum{ method = CastFromFloat }; public: { template < typename ToType > class GetCastMethod < ToType, double >  }; 	enum{ method = CastFromFloat }; public: { template < typename ToType > class GetCastMethod < ToType, float >  }; 	enum{ method = CastOK }; public: { template < typename FromType > class GetCastMethod < long double, FromType >  }; 	enum{ method = CastOK }; public: { template < typename FromType > class GetCastMethod < double, FromType >  }; 	enum{ method = CastOK }; public: { template < typename FromType > class GetCastMethod < float, FromType >  };     };                                                                        : CastCheckMinMaxSigned                  ( !IntTraits< ToType >::isSigned )                    ? CastCheckMinMaxUnsigned                        sizeof( ToType ) >= sizeof( FromType ) )          ? CastCheckLTZero :                      IntTraits< FromType >::isSigned &&                   ( !IntTraits< ToType >::isSigned &&                           sizeof( FromType ) > sizeof( ToType ) ) )      ? CastCheckGTMax :                    ( SafeIntCompare< ToType, FromType >::isBothUnsigned &&                          sizeof( FromType ) >= sizeof( ToType ) ) ||                          !IntTraits< FromType >::isSigned &&                   ( ( IntTraits< ToType >::isSigned &&                    ( SafeIntCompare< ToType, FromType >::isCastOK )      ? CastOK :                       IntTraits< ToType >::isBool )                     ? CastToBool :                  ( !IntTraits< FromType >::isBool &&                        !IntTraits< ToType >::isBool )                    ? CastFromBool :        method =  ( IntTraits< FromType >::isBool &&      {     enum public: { class GetCastMethod template < typename ToType, typename FromType >   };     CastFromBool     CastToBool,     CastFromFloat,     CastToFloat,     CastCheckMinMaxSigned,     CastCheckMinMaxUnsigned,     CastCheckGTMax,     CastCheckLTZero,     CastOK = 0, { enum CastMethod //core logic to determine casting behavior ad     S     ã       â    ∫  ≥  ∞  Ø  Æ  s  1  œ  v  u  #  Ê  Â  ‰  ô  ä  à  v  b  P  M  L  4  !          ∞  f  _  \  [  (  '  Á
+  Â
+  ›
+  Æ
+  ®
+  è
+  j
+  d
+  a
+  `
+  
+  
+  
+  ‰	  ﬁ	  ≈	  †	  ö	  ó	  ñ	  T	  R	  J	  *	  $	  Á  Œ  º  ∂  ≥  ≤  ~  }  <  :  2    ¸  ˘  ‚  ∏  Æ  g  P  F  &  #  "  ı  Ú  €  ±  ß  `  J  :  0            Œ  Ã  ƒ  ≠  Ü  É  c  _  8  ˚  ´  ö  ]  2  &    ∆  ≤  Æ    ^  W  J  G  F  !    ˛  ˙  Í  ÷  “  £  Ç  {  i  Z  W  T  S  R              }; 	} 		return true;         ret = -t; #endif 	    C_ASSERT( sizeof(T) == 0 ); #if defined SAFEINT_DISALLOW_UNSIGNED_NEGATION 		} 			assert( false ); 			// See above 		{ 		if( IntTraits<T>::isLT32Bit ) 	{ 	static bool Negative( T t, T& ret )  	} 		return -t; #endif 	    C_ASSERT( sizeof(T) == 0 ); #if defined SAFEINT_DISALLOW_UNSIGNED_NEGATION 		} 			assert( false ); 			// will then emit a signed int with the correct value and bitfield 			// -(SafeInt<int>(ss)) 			// then: 			// SafeInt<unsigned short> ss = 0xffff; 			// If you want normal operator casting behavior, do this: 			// you wanted 			// This class will retain the type, and will truncate, which may not be what 			// For example -(unsigned short)0xffff == (int)0xffff0001 			// This will normally upcast to int 		{ 		if( IntTraits<T>::isLT32Bit ) 	{ 	static T NegativeThrow( T t ) throw() 	template <typename E> public: { template < typename T > class NegationHelper <T, false> // unsigned   }; 	}         return false;         } 			return true;             ret = -t;             // cast prevents unneeded checks in the case of small ints         {         if( t != IntTraits< T >::minInt )         // corner case 	{ 	static bool Negative( T t, T& ret ) throw()  	}         E::SafeIntOnOverflow();         }             return -t;             // cast prevents unneeded checks in the case of small ints         {         if( t != IntTraits< T >::minInt )         // corner case 	{ 	static T NegativeThrow( T t ) 	template <typename E> public: { template < typename T > class NegationHelper <T, true> // Signed  template < typename T, bool > class NegationHelper;  };     }         return t;         assert( false );         // Why are you calling Abs on an unsigned number ???     {     static T Abs( T t ) throw() public: { template < typename T > class AbsValueHelper < T, AbsMethodNoop >  };     }         return (unsigned __int64)-t;         assert( t < 0 );     {     static unsigned __int64 Abs( T t ) throw() public: { template < typename T > class AbsValueHelper < T, AbsMethodInt64 >  };     }         return (unsigned __int32)-t;         assert( t < 0 );     {     static unsigned __int32 Abs( T t ) throw() public: { template < typename T > class AbsValueHelper < T, AbsMethodInt>  template < typename T, int > class AbsValueHelper;  };     };                  IntTraits< T >::isInt64 ? AbsMethodInt64 : AbsMethodNoop         method = IntTraits< T >::isLT64Bit && IntTraits< T >::isSigned ? AbsMethodInt :     {     enum public: { class GetAbsMethod template < typename T >  };     AbsMethodNoop     AbsMethodInt64,     AbsMethodInt, { enum AbsMethod // useful function to help with getting the magnitude of a negative number   // immediately next to one another will help reduce problems // There's no real alternative to duplicating logic, but keeping the two versions  // Some of the non-throwing functions are not used, but are maintained for completeness. // The non-throwing versions are for use by the helper functions that return success and failure. // One for SafeInt, which throws C++ (or possibly SEH) exceptions // In all of the following functions, we have two versions   };     };         IntZone_Int64_Uint64      = IntTraits< T >::isInt64 && IntTraits< U >::isUint64         IntZone_Int_Uint64        = IntTraits< T >::isSigned && IntTraits< U >::isUint64 && IntTraits< T >::isLT64Bit,         IntZone_Int64_UintLT64    = IntTraits< T >::isInt64 && !IntTraits< U >::isSigned && IntTraits< U >::isLT64Bit, ad  -   1     :       ‹  π  ñ  R  P  O  N  M      
+     ˙  ´  X  ˘  π  o    Ã  ≈  ¬  ¡  y  )  ’  ¬  p  o  ;  9  1  (  "    é
+  
+  à	  "	  û  É     â    õ  $  À  ≥  ?  æ  =  æ  =  º  ¢    ®  1  0                                                       IntZone_IntLT64_Uint32    = IntTraits< T >::isSigned && IntTraits< T >::isLT64Bit && IntTraits< U >::isUint32,         IntZone_Int32_UintLT32    = IntTraits< T >::isInt32 && !IntTraits< U >::isSigned && IntTraits< U >::isLT32Bit,         IntZone_IntLT32_UintLT32  = IntTraits< T >::isSigned && !IntTraits< U >::isSigned && SafeIntCompare< T,U >::isBothLT32Bit,         //signed-unsigned         IntZone_IntLT64_Int64     = SafeIntCompare< T,U >::isBothSigned && IntTraits< T >::isLT64Bit && IntTraits< U >::is64Bit,         IntZone_Int64_Int         = SafeIntCompare< T,U >::isBothSigned && IntTraits< T >::is64Bit && IntTraits< U >::isLT64Bit,         IntZone_Int64_Int64       = SafeIntCompare< T,U >::isBothSigned && IntTraits< T >::isInt64 && IntTraits< U >::isInt64,         IntZone_IntLT32_Int32     = SafeIntCompare< T,U >::isBothSigned && IntTraits< T >::isLT32Bit && IntTraits< U >::is32Bit,         IntZone_Int32_IntLT64     = SafeIntCompare< T,U >::isBothSigned && IntTraits< T >::is32Bit && IntTraits< U >::isLT64Bit,         IntZone_IntLT32_IntLT32   = SafeIntCompare< T,U >::isBothSigned && ::SafeIntCompare< T, U >::isBothLT32Bit,         //signed-signed         IntZone_Uint64_Int64      = IntTraits< T >::isUint64 && IntTraits< U >::isInt64,         IntZone_UintLT64_Int64    = !IntTraits< T >::isSigned && IntTraits< T >::isLT64Bit && IntTraits< U >::isInt64,         IntZone_Uint64_Int        = IntTraits< T >::isUint64 && IntTraits< U >::isSigned && IntTraits< U >::isLT64Bit,         IntZone_UintLT32_Int32    = !IntTraits< T >::isSigned && IntTraits< T >::isLT32Bit && IntTraits< U >::isInt32,         IntZone_Uint32_IntLT64    = IntTraits< T >::isUint32 && IntTraits< U >::isSigned && IntTraits< U >::isLT64Bit,         IntZone_UintLT32_IntLT32  = !IntTraits< T >::isSigned && IntTraits< U >::isSigned && SafeIntCompare< T,U >::isBothLT32Bit,          //unsigned-signed         IntZone_UintLT64_Uint64    = SafeIntCompare< T,U >::isBothUnsigned && IntTraits< T >::isLT64Bit && IntTraits< U >::is64Bit,         IntZone_Uint64_Uint       = SafeIntCompare< T,U >::isBothUnsigned && IntTraits< T >::is64Bit,         IntZone_UintLT32_Uint32   = SafeIntCompare< T,U >::isBothUnsigned && IntTraits< T >::isLT32Bit && IntTraits< U >::is32Bit,         IntZone_Uint32_UintLT64   = SafeIntCompare< T,U >::isBothUnsigned && IntTraits< T >::is32Bit && IntTraits< U >::isLT64Bit,         IntZone_UintLT32_UintLT32 = SafeIntCompare< T,U >::isBothUnsigned && SafeIntCompare< T,U >::isBothLT32Bit,         //unsigned-unsigned zone     {     enum public: { template < typename T, typename U > class IntRegion  //using this also helps ensure that we handle all of the possible cases correctly //as the first cut //most operators collapse the problem into less than the 22 zones, but this is used //each of these regions without resorting to compile-time constant conditionals //all of the arithmetic operators can be solved by the same code within  };     };         isBothLT64Bit = (IntTraits< T >::isLT64Bit && IntTraits< U >::isLT64Bit)         isBothLT32Bit = (IntTraits< T >::isLT32Bit && IntTraits< U >::isLT32Bit),                     (IntTraits< T >::isSigned && sizeof(T) > sizeof(U))),         isCastOK = ((isLikeSigned && sizeof(T) >= sizeof(U)) ||         isLikeSigned = ((bool)(IntTraits< T >::isSigned) == (bool)(IntTraits< U >::isSigned)),         isBothUnsigned = (!IntTraits< T >::isSigned && !IntTraits< U >::isSigned),         isBothSigned = (IntTraits< T >::isSigned && IntTraits< U >::isSigned),     {     enum  public: { template < typename T, typename U > class SafeIntCompare    }     return CompareMaxHelper<T, U, couldExceed>::LessEqualMaxInt(u);          !IntTraits<U>::isSigned);          IntTraits<T>::isSigned &&         (sizeof(U) == sizeof(T) &&  ad     ª     a       ¶  M  J  I  !        Á  ·  ƒ  §  ù  x  P  (     ÿ  ±  ä  V  !  Ì  ∏  Ñ  O    Ê  ¡  §  Ö  ~  Y  R  Q    Î
+  î
+  C
+  B
+  Ù	  §	  U	  	  	  Û  ≈  •  y  3  Ë  Â  ‰  „  ¬  è  d  b    ´  ®  |  z     «  ƒ  √  w  u  7  5  Î  È  ≠  ´  ™  g      Ω  ª  à  Ç  6    ˚  ¯  ˜  °  ü  Z  W  V  ,  Ù  Ú  ª  ∫                                 const bool couldExceed = sizeof(U) > sizeof(T) ||  { inline bool IntTraits<T>::isLessEqualMaxInt(const U& u) template<typename T> template<typename U>  };     static inline bool LessEqualMaxInt(const U &u) { return false; } { template<typename LimitType, typename U> struct CompareMaxHelper<LimitType, U, false>  };     }         return u <= U(IntTraits<LimitType>::maxInt);         // if we reach this, we know that converting T->U will not overflow     {     static inline bool LessEqualMaxInt(const U &u) { template<typename LimitType, typename U> struct CompareMaxHelper<LimitType, U, true>  template<typename LimitType, typename U, bool couldExceed> struct CompareMaxHelper; // couldExceed will be true if U's range might exceed LimitType's.  }     return CompareConstHelper<isSigned>::EqualsMinusOne(t); { template<typename T> inline bool IntTraits<T>::equalsMinusOne(const T& t) }     return CompareConstHelper<isSigned>::GreaterEqualZero(t); { template<typename T> inline bool IntTraits<T>::greaterEqualZero(const T& t)  };     template<typename T> static inline bool EqualsMinusOne(const T &a) { return false; }     template<typename T> static inline bool GreaterEqualZero(const T &a) { return true; } { template<> struct CompareConstHelper<false> };     template<typename T> static inline bool EqualsMinusOne(const T &a) { return a == -1; }     template<typename T> static inline bool GreaterEqualZero(const T &a) { return a >= 0; } { template<> struct CompareConstHelper<true> template<bool isSigned> struct CompareConstHelper; // GCC workaround implementation   };     template<typename U> static inline bool isLessEqualMaxInt(const U& u);     // Returns true if u <= T::maxInt. u's type doesn't need to be T.     static bool equalsMinusOne(const T& t);     // Returns true if t == -1.     static bool greaterEqualZero(const T& t);     // Returns true if t >= 0.      // for types where the comparison could conceivably be false.     // be disabled in v4.2. Workaround this by only performing the comparisons     // will always be true, e.g. unsigned int x; if(x >= 0). This warning can't     // GCC warnings workarounds: GCC will detect & warn for comparisons which      const static T minInt = isSigned ? ((T)((T)1 << (T)(bitCount-1)))  : ((T)0);     const static T maxInt = isSigned ? ((T)~((T)1 << (T)(bitCount-1))) : ((T)(~(T)0));     // so we'll use const statics instead!     // On version 13.10 enums cannot define __int64 values      };         isBool    = ( (T)2 == (T)1 ) #endif #pragma warning(suppress:4804) #if !defined SAFEINT_GCC_HPP         bitCount  = ( sizeof(T)*8 ),         isUint64  = ( sizeof(T) == 8 && !isSigned ),         isInt64   = ( sizeof(T) == 8 && isSigned ),         isUint32  = ( sizeof(T) == 4 && !isSigned ),         isInt32   = ( sizeof(T) == 4 && isSigned ),         isUint16  = ( sizeof(T) == 2 && !isSigned ),         isInt16   = ( sizeof(T) == 2 && isSigned ),         isUint8   = ( sizeof(T) == 1 && !isSigned ),         isInt8    = ( sizeof(T) == 1 && isSigned ),         isLT64Bit = ( sizeof(T) < 8 ),         isLT32Bit = ( sizeof(T) < 4 ),         is8Bit    = ( sizeof(T) == 1 ),         is16Bit   = ( sizeof(T) == 2 ),         is32Bit   = ( sizeof(T) == 4 ),         is64Bit   = ( sizeof(T) == 8 ),         isSigned  = ( (T)(-1) < 0 ), #endif #pragma warning(suppress:4804)  #if !defined SAFEINT_GCC_HPP     {     enum     C_ASSERT( NumericType<T>::isInt ); public: { template < typename T > class IntTraits  };     template<typename T> static inline bool EqualsMinusOne(const T &a) { return false; }     template<typename T> static inline bool GreaterEqualZero(const T &a) { return true; } ad     0     D       ª  ≤  ç  K  B  <  5      ¥  û  +  $  #  Ë  ò  l  E  (  Ë  €  ⁄  ó  é  G  =  6  5  2  Ú  ≠  d  .  ‹
+  Ã
+  …
+  »
+  ù
+  ú
+  '
+  ≥	  ?	  À  W  „  ®  4  -  π  E  —  ]  È  u     ã    Ó  y  x  E      º  a  ^  2  0          { template<> struct CompareConstHelper<false> };     template<typename T> static inline bool EqualsMinusOne(const T &a) { return a == -1; }     template<typename T> static inline bool GreaterEqualZero(const T &a) { return a >= 0; } { template<> struct CompareConstHelper<true> template<bool isSigned> struct CompareConstHelper;  template < typename T > class NumericType       { public: enum{ isBool = false, isFloat = false, isInt = false }; }; // Catch-all for anything not supported template <> class NumericType<long double>      { public: enum{ isBool = false, isFloat = true,  isInt = false }; }; template <> class NumericType<double>           { public: enum{ isBool = false, isFloat = true,  isInt = false }; }; template <> class NumericType<float>            { public: enum{ isBool = false, isFloat = true,  isInt = false }; }; template <> class NumericType<unsigned __int64> { public: enum{ isBool = false, isFloat = false, isInt = true }; }; template <> class NumericType<__int64>          { public: enum{ isBool = false, isFloat = false, isInt = true }; }; template <> class NumericType<unsigned long>    { public: enum{ isBool = false, isFloat = false, isInt = true }; }; template <> class NumericType<long>             { public: enum{ isBool = false, isFloat = false, isInt = true }; }; template <> class NumericType<unsigned int>     { public: enum{ isBool = false, isFloat = false, isInt = true }; }; template <> class NumericType<int>              { public: enum{ isBool = false, isFloat = false, isInt = true }; }; #endif template <> class NumericType<wchar_t>          { public: enum{ isBool = false, isFloat = false, isInt = true }; }; #if defined SAFEINT_USE_WCHAR_T || _NATIVE_WCHAR_T_DEFINED template <> class NumericType<unsigned short>   { public: enum{ isBool = false, isFloat = false, isInt = true }; }; template <> class NumericType<short>            { public: enum{ isBool = false, isFloat = false, isInt = true }; }; template <> class NumericType<signed char>      { public: enum{ isBool = false, isFloat = false, isInt = true }; }; template <> class NumericType<unsigned char>    { public: enum{ isBool = false, isFloat = false, isInt = true }; }; template <> class NumericType<char>             { public: enum{ isBool = false, isFloat = false, isInt = true }; }; template <> class NumericType<bool>             { public: enum{ isBool = true,  isFloat = false, isInt = false }; };  template < typename T > class NumericType;  */ * that follows. * from compiling in the case of an enum, which is the point of the specialization *              isFloat = ( (T)( (float)1.1 ) > (T)1 ) * an enum to a SafeInt of some type, it won't compile, unless we prevent * to cast a float to an enum. This means that if we happen to assign * The following template magic is because we're now not allowed /*  #endif    #endif       #define SafeIntDefaultExceptionHandler CPlusPlusExceptionHandler    #else       #define SafeIntDefaultExceptionHandler Win32ExceptionHandler        #endif       #error Include windows.h in order to use Win32 exceptions       #if !defined _WINDOWS_    #if defined SAFEINT_RAISE_EXCEPTION #if !defined SafeIntDefaultExceptionHandler // define one now, depending on whether they would like Win32 or C++ exceptions // If the user hasn't defined a default exception handler,  #endif typedef SafeIntInternal::SafeIntExceptionHandler < SafeIntInternal::SafeIntWin32Exception > Win32ExceptionHandler; #if defined _WINDOWS_ typedef SafeIntInternal::SafeIntExceptionHandler < SafeIntException > CPlusPlusExceptionHandler;  } // namespace SafeIntInternal #endif    };        }            SafeIntWin32Exception( EXCEPTION_INT_DIVIDE_BY_ZERO );            SafeIntExceptionAssert();        {        static __declspec(noreturn) void __stdcall SafeIntOnDivZero() ad     ¿     g       ü  <    ª  ~    ª  [  ˚  ◊  x  :  Ÿ  x    ¥
+  Ñ
+  }
+  z
+  y
+  0
+  /
+  Ã	   	  ¬	  ñ	  S	  M	  4	  3	  Ë  Œ  ≈  Ø  ö  î  ì  w  7  1      Ã  ®  ü  â  É  Ä          ‚  ü  ô  w  v  K  1  (    ˝  ˜  ˆ  ⁄  ö  î  r  q  F  "      ˝  ˙  ˘  î  í  ä  '  ‰  ﬁ  Ø  Æ  S  9  0      ˇ  ˙  ﬁ  û  ò  i  h    È  ‡     ƒ  ¡  ¿  ø           };     }         ret = (T)tmp;                      E::SafeIntOnOverflow();         if(tmp > (__int64)IntTraits< T >::maxInt || tmp < (__int64)IntTraits< T >::minInt)          __int64 tmp = (__int64)t * (__int64)u;     {     static void MultiplyThrow( const T& t, const U& u, T& ret )     template < typename E >          }         return true;         ret = (T)tmp;                      return false;         if(tmp > (__int64)IntTraits< T >::maxInt || tmp < (__int64)IntTraits< T >::minInt)          __int64 tmp = (__int64)t * (__int64)u;     {     static bool Multiply( const T& t, const U& u, T& ret ) throw()     //mixed signed or both signed where at least one argument is 32-bit, and both a 32-bit or less public: { template < typename T, typename U > class MultiplicationHelper< T, U, MultiplicationState_CastInt64>  };     }         ret = (T)tmp;                      E::SafeIntOnOverflow();         if( tmp > IntTraits< T >::maxInt )          unsigned int tmp = t * u;     {     static void MultiplyThrow( const T& t, const U& u, T& ret )     template < typename E >      }         return true;         ret = (T)tmp;                      return false;         if( tmp > IntTraits< T >::maxInt )          unsigned int tmp = t * u;     {     static bool Multiply( const T& t, const U& u, T& ret ) throw()     //accepts unsigned, both less than 32-bit public: { template < typename T, typename U > class MultiplicationHelper< T, U, MultiplicationState_CastUint >  };     }         ret = (T)tmp;                      E::SafeIntOnOverflow();         if( tmp > IntTraits< T >::maxInt || tmp < IntTraits< T >::minInt )          int tmp = t * u;     {     static void MultiplyThrow( const T& t, const U& u, T& ret )     template < typename E >      }         return true;         ret = (T)tmp;                      return false;         if( tmp > IntTraits< T >::maxInt || tmp < IntTraits< T >::minInt )          int tmp = t * u;     {     static bool Multiply( const T& t, const U& u, T& ret ) throw()     //accepts signed, both less than 32-bit public: { template < typename T, typename U > class MultiplicationHelper< T, U, MultiplicationState_CastInt>  template <typename T, typename U, int state> class MultiplicationHelper;  };     };                   MultiplicationState_Error ) )                  (IntRegion< T,U >::IntZone_Int64_Uint64       ? MultiplicationState_Int64Uint64 :                  (IntRegion< T,U >::IntZone_Int_Uint64)        ? MultiplicationState_IntUint64 :                  (IntRegion< T,U >::IntZone_Int64_UintLT64)    ? MultiplicationState_Int64Uint :                   IntRegion< T,U >::IntZone_IntLT64_Uint32)    ? MultiplicationState_CastInt64 :                  (IntRegion< T,U >::IntZone_Int32_UintLT32 ||                  (IntRegion< T,U >::IntZone_IntLT32_UintLT32)  ? MultiplicationState_CastInt :                  // signed-unsigned                  (IntRegion< T,U >::IntZone_IntLT64_Int64)     ? MultiplicationState_IntInt64 :                  (IntRegion< T,U >::IntZone_Int64_Int)         ? MultiplicationState_Int64Int :                  (IntRegion< T,U >::IntZone_Int64_Int64)       ? MultiplicationState_Int64Int64 :                   IntRegion< T,U >::IntZone_IntLT32_Int32)     ? MultiplicationState_CastInt64 :                  (IntRegion< T,U >::IntZone_Int32_IntLT64 ||                  (IntRegion< T,U >::IntZone_IntLT32_IntLT32)   ? MultiplicationState_CastInt :                  // signed-signed                  (IntRegion< T,U >::IntZone_Uint64_Int64)      ? MultiplicationState_Uint64Int64 :                  (IntRegion< T,U >::IntZone_UintLT64_Int64)    ? MultiplicationState_UintInt64 : ad           ~       ö  ò  ê  9  ˆ    ¶  •  j  P  G  1        ˙  ª  µ  k  j  /      Ï  Ê  „  ‚  ¬  ±  r  q  &  $    Ù  Æ  ®  u  t  @    ¢
+  V
+  U
+  (
+  
+  ÷	  ±	  ∞	  ü	  û	  á	  }	  b	  T	  	  ˛  Ù  ÿ  Œ  ≥  ù  U  G  =  0  &        Ï  ‚  ¿  ø  å  n  m  U    ˙  ˘  ﬂ  ¡  ¿  ß  ù  ú  ]  H  B  A       ƒ  ë  ê  \  #  æ  r  q  D    Ú  Õ  Ã  ª  ∫  £  ô  ~  p  (      Ù  Í  œ  π  q  c  Y  L  B                  }             E::SafeIntOnOverflow();         {         else         }             }                 ret = (unsigned __int64)aHigh * (unsigned __int64)bLow;             {                     if(aHigh != 0)         {         else if(bHigh == 0)         }             }                 ret = (unsigned __int64)aLow * (unsigned __int64)bHigh;             {             if(bHigh != 0)         {         if(aHigh == 0)          ret = 0;          bLow  = (unsigned __int32)b;         bHigh = (unsigned __int32)(b >> 32);         aLow  = (unsigned __int32)a;         aHigh = (unsigned __int32)(a >> 32);          // Note - same approach applies for 128 bit math on a 64-bit system         // => (aHigh * bHigh * 2^64) + (aLow * bHigh * 2^32) + (aHigh * bLow * 2^32) + (aLow * bLow)         // (aHigh * 2^32 + aLow) * (bHigh * 2^32 + bLow)         // Consider that a*b can be broken up into:          unsigned __int32 aHigh, aLow, bHigh, bLow;     {     static void RegMultiplyThrow( const T& a, const U& b, T& ret )     template < typename E, typename T, typename U >      }         return true;         ret = (unsigned __int64)aLow * (unsigned __int64)bLow;          }             return true;                  return false;             if(ret < tmp)              ret += tmp;             tmp = (unsigned __int64)aLow * (unsigned __int64)bLow;             ret <<= 32;                  return false;             if((unsigned __int32)(ret >> 32) != 0)              unsigned __int64 tmp;         {         if(ret != 0)          }             return false;         {         else         }             }                 ret = (unsigned __int64)aHigh * (unsigned __int64)bLow;             {                     if(aHigh != 0)         {         else if(bHigh == 0)         }             }                 ret = (unsigned __int64)aLow * (unsigned __int64)bHigh;             {             if(bHigh != 0)         {         if(aHigh == 0)          ret = 0;          bLow  = (unsigned __int32)b;         bHigh = (unsigned __int32)(b >> 32);         aLow  = (unsigned __int32)a;         aHigh = (unsigned __int32)(a >> 32);          // Note - same approach applies for 128 bit math on a 64-bit system         // => (aHigh * bHigh * 2^64) + (aLow * bHigh * 2^32) + (aHigh * bLow * 2^32) + (aLow * bLow)         // (aHigh * 2^32 + aLow) * (bHigh * 2^32 + bLow)         // Consider that a*b can be broken up into:          unsigned __int32 aHigh, aLow, bHigh, bLow;     {     static bool RegMultiply( const T& a, const U& b, T& ret ) throw()     template < typename T, typename U > public: { template<> class LargeIntRegMultiply< unsigned __int64, unsigned __int64 >  template < typename T, typename U > class LargeIntRegMultiply; // U = right arg // T = left arg and return type  };     }         ret = (T)tmp;                      E::SafeIntOnOverflow();         if(tmp > (unsigned __int64)IntTraits< T >::maxInt)          unsigned __int64 tmp = (unsigned __int64)t * (unsigned __int64)u;     {    static void MultiplyThrow( const T& t, const U& u, T& ret )    template < typename E >      }         return true;         ret = (T)tmp;                      return false;         if(tmp > (unsigned __int64)IntTraits< T >::maxInt)          unsigned __int64 tmp = (unsigned __int64)t * (unsigned __int64)u;     {     static bool Multiply( const T& t, const U& u, T& ret ) throw()     //both unsigned where at least one argument is 32-bit, and both are 32-bit or less public: { template < typename T, typename U > class MultiplicationHelper< T, U, MultiplicationState_CastUint64> ad     E     á       ˇ  Í  ‡  æ  Ω  ä  b  a  I    Ó  Ì  ”  ´  ™  ñ  å  ã  L  F  C  B  ˜  ı  Ì  ≈    y  S  R    ˘  À     ù  x  w  f  e  N  <  ˚  ˙  ÿ  ◊  §  Ü  Ö  m  -      ˙
+  ‹
+  €
+  ¬
+  ∏
+  ∑
+  {
+  f
+  `
+  _
+  +
+  Ë	  ‚	  º	  ª	  á	  b	  4	  3	  	  ·  ‡  œ  Œ  ∑  •  d  c  A  @    Â  ‰  Ã  å  t  s  Y  1  0        ’  ≈  ø  º  ª  r  p  h  @  ˙  Ù  ÷  º  ª  G  A  @    …  √  •  Å  Ä  ˛  ¯  ı  Ù  ´  ©  °  y  3  -    ı  Ù  Ä  z  y  E  D                   template < typename E, typename T, typename U >      }         return LargeIntRegMultiply< unsigned __int64, unsigned __int64 >::RegMultiply(a, (unsigned __int64)b, ret);              return false;         if( b < 0 && a != 0 )     {     static bool RegMultiply( const T& a, const U& b, T& ret ) throw()     template < typename T, typename U > public: { template<> class LargeIntRegMultiply< unsigned __int64, signed __int64 >  };     }         LargeIntRegMultiply< unsigned __int64, unsigned __int32 >::template RegMultiplyThrow< E >( a, (unsigned __int32)b, ret );              E::SafeIntOnOverflow();         if( b < 0 && a != 0 )     {     static void RegMultiplyThrow( const T& a, const U& b, T& ret )     template < typename E, typename T, typename U >      }         return LargeIntRegMultiply< unsigned __int64, unsigned __int32 >::RegMultiply(a, (unsigned __int32)b, ret);              return false;         if( b < 0 && a != 0 )     {     static bool RegMultiply( const T& a, const U& b, T& ret ) throw()     template < typename T, typename U > public: { template<> class LargeIntRegMultiply< unsigned __int64, signed __int32 >  };     }         return;         ret = (unsigned __int64)aLow * (unsigned __int64)b;          }             return;                  E::SafeIntOnOverflow();             if(ret < tmp)              ret += tmp;             tmp = (unsigned __int64)aLow * (unsigned __int64)b;             ret <<= 32;                  E::SafeIntOnOverflow();             if((unsigned __int32)(ret >> 32) != 0)              unsigned __int64 tmp;              ret = (unsigned __int64)aHigh * (unsigned __int64)b;         {                 if(aHigh != 0)          ret = 0;          aLow  = (unsigned __int32)a;         aHigh = (unsigned __int32)(a >> 32);          // => (aHigh * b * 2^32) + (aLow * b)         // (aHigh * 2^32 + aLow) * b         // Consider that a*b can be broken up into:          unsigned __int32 aHigh, aLow;     {     static void RegMultiplyThrow( const T& a, const U& b, T& ret )     template < typename E, typename T, typename U >      }         return true;         ret = (unsigned __int64)aLow * (unsigned __int64)b;          }             return true;                  return false;             if(ret < tmp)              ret += tmp;             tmp = (unsigned __int64)aLow * (unsigned __int64)b;             ret <<= 32;                  return false;             if((unsigned __int32)(ret >> 32) != 0)              unsigned __int64 tmp;              ret = (unsigned __int64)aHigh * (unsigned __int64)b;         {                 if(aHigh != 0)          ret = 0;          aLow  = (unsigned __int32)a;         aHigh = (unsigned __int32)(a >> 32);          // => (aHigh * b * 2^32) + (aLow * b)         // (aHigh * 2^32 + aLow) * b         // Consider that a*b can be broken up into:          unsigned __int32 aHigh, aLow;     {     static bool RegMultiply( const T& a, const U& b, T& ret ) throw()     template < typename T, typename U > public: { template<> class LargeIntRegMultiply< unsigned __int64, unsigned __int32 >  };     }         ret = (unsigned __int64)aLow * (unsigned __int64)bLow;          }             return;                  E::SafeIntOnOverflow();             if(ret < tmp)              ret += tmp;             tmp = (unsigned __int64)aLow * (unsigned __int64)bLow;             ret <<= 32;                  E::SafeIntOnOverflow();             if((unsigned __int32)(ret >> 32) != 0)              unsigned __int64 tmp;         {         if(ret != 0)  ad     7     Ç       Ω  ∑  ô  u  t  Ú  Ï  È  Ë  ü  ù  ï  m  '  !  ˝  €  ⁄  ¶  m      ⁄  µ  ¥  £  ¢  Å  g  f  R  H  5        æ  Ω  º  °  ó  H  :    Ú
+  ‰
+  ⁄
+  Õ
+  √
+  r
+  d
+  4
+  
+  	
+  ˇ	  ˛	  Ë	  ‚	  ·	  ≠	  q	  k	  G	  %	  $	    ∑  R  Q  &      Ò    œ  ´  ™  ñ  å  y  Z  P  O      Ê  ‹  ç    T  <  .  $      º  Æ  ~  f  X  N  M  -  '  $  #  ÿ  ÷  Œ  ¶  `  Z  &    ”  ô  d  [  "  	    –  œ  í  y  x  S  >  8  7  6                          }         return true;         ret = (unsigned __int32)tmp;             return false;         if( (unsigned __int32)(tmp >> 32) != 0 ) // overflow          unsigned __int64 tmp = b * (unsigned __int64)a;             return false;         if( (unsigned __int32)(b >> 32) != 0 && a != 0 )                  // If bHigh != 0 && a != 0, immediate error.         // In this case, the result must fit into 32-bits         // => (bHigh * a * 2^32) + (bLow * a)         // (bHigh * 2^32 + bLow) * a         // Consider that a*b can be broken up into:     {     static bool RegMultiply( const T& a, const U& b, T& ret ) throw()     template < typename T, typename U > public: { template<> class LargeIntRegMultiply< unsigned __int32, unsigned __int64 >  };     }         E::SafeIntOnOverflow();          }             }                 return;                 ret = -( (signed __int32)tmp );             {             if( tmp <= (unsigned __int64)IntTraits< signed __int32 >::maxInt+1 )         {         else         }             }                 return;                 ret = (signed __int32)tmp;             {             if( tmp <= (unsigned __int64)IntTraits< signed __int32 >::maxInt )         {         if( !fIsNegative )          unsigned __int64 tmp = (unsigned __int32)a * (unsigned __int64)bLow;          }            fIsNegative = true;            a = -a;         {         if( a < 0 )              E::SafeIntOnOverflow();         if(bHigh != 0 && a != 0)          ret = 0;          bLow  = (signed __int32)b;         bHigh = (signed __int32)(b >> 32);          // => (aHigh * bHigh * 2^64) + (aLow * bHigh * 2^32) + (aHigh * bLow * 2^32) + (aLow * bLow)         // (aHigh * 2^32 + aLow) * (bHigh * 2^32 + bLow)         // Consider that a*b can be broken up into:          bool fIsNegative = false;         signed __int32 bHigh, bLow;     {     static void RegMultiplyThrow( T a, const U& b, T& ret )     template < typename E, typename T, typename U >      }         return false;          }             }                 return true;                 ret = -( (signed __int32)tmp );             {             if( tmp <= (unsigned __int64)IntTraits< signed __int32 >::maxInt+1 )         {         else         }             }                 return true;                 ret = (signed __int32)tmp;             {             if( tmp <= (unsigned __int64)IntTraits< signed __int32 >::maxInt )         {         if( !fIsNegative )           unsigned __int64 tmp = (unsigned __int32)a * (unsigned __int64)bLow;          }            fIsNegative = true;            a = -a;         {         if( a < 0 )              return false;         if(bHigh != 0 && a != 0)          ret = 0;          bLow  = (unsigned __int32)b;         bHigh = (unsigned __int32)(b >> 32);          // => (aHigh * bHigh * 2^64) + (aLow * bHigh * 2^32) + (aHigh * bLow * 2^32) + (aLow * bLow)         // (aHigh * 2^32 + aLow) * (bHigh * 2^32 + bLow)         // Consider that a*b can be broken up into:          bool fIsNegative = false;         signed __int32 bHigh, bLow;     {     static bool RegMultiply( const T& a, const U& b, T& ret ) throw()     template < typename T, typename U > public: { template<> class LargeIntRegMultiply< signed __int32, unsigned __int64 >  };     }         LargeIntRegMultiply< unsigned __int64, unsigned __int64 >::template RegMultiplyThrow< E >( a, (unsigned __int64)b, ret );              E::SafeIntOnOverflow();         if( b < 0 && a != 0 )     {     static void RegMultiplyThrow( const T& a, const U& b, T& ret ) ad     *     |       Ã  â  É  J  '  &  Ó  Ì  ∞  ç  å  g  a  ^  ]      
+  ‚  ú  ñ  x  ^  Ë  ‚  ·  ≠  j  d  F  "  !  ü  ô  ñ  ï  N  L  D    ÷
+  –
+  ∞
+  ê
+  è
+  q
+  Y
+  A
+  @
+  +
+  !
+  
+  Ì	  „	  ‚	  Õ	  √	  •	  è	  Ö	  Ñ	  ¸  Ú  ∑  è  Å  V    Ò  ¡  †  é  Ä  o  a  6  „  —  ¢  Å  o  a  W  V  @  :  9    ¬  º  ú  |  {  ]  E  -  ,      Ô  Ÿ  œ  Œ  π  Ø  ë  {  q  h  “  —  v  R  H  !  “  ƒ  ò  Ä  r  h  [  Q  *  )                                            // Result must be positive         {         else         }             }                 return;                 ret = -(signed __int64)tmp;             {             if( tmp <= (unsigned __int64)IntTraits< signed __int64 >::minInt )             // Result must be negative         {         if( aNegative ^ bNegative )         // The unsigned multiplication didn't overflow or we'd be in the exception handler          LargeIntRegMultiply< unsigned __int64, unsigned __int64 >::template RegMultiplyThrow< E >( (unsigned __int64)a1, (unsigned __int64)b1, tmp );                  }             b1 = -b1;             bNegative = true;         {         if( b1 < 0 )          }             a1 = -a1;             aNegative = true;         {         if( a1 < 0 )          __int64 b1 = b;         __int64 a1 = a;         unsigned __int64 tmp;          bool bNegative = false;         bool aNegative = false;     {     static void RegMultiplyThrow( const T& a, const U& b, T& ret )     template < typename E, typename T, typename U >      }         return false;          }             }                 }                     return true;                     ret = (signed __int64)tmp;                 {                 if( tmp <= (unsigned __int64)IntTraits< signed __int64 >::maxInt )                 // Result must be positive             {             else             }                 }                     return true;                     ret = -(signed __int64)tmp;                 {                 if( tmp <= (unsigned __int64)IntTraits< signed __int64 >::minInt )                 // Result must be negative             {             if( aNegative ^ bNegative )             // The unsigned multiplication didn't overflow         {         if( LargeIntRegMultiply< unsigned __int64, unsigned __int64 >::RegMultiply( (unsigned __int64)a1, (unsigned __int64)b1, tmp ) )          }             b1 = -b1;             bNegative = true;         {         if( b1 < 0 )          }             a1 = -a1;             aNegative = true;         {         if( a1 < 0 )          __int64 b1 = b;         __int64 a1 = a;         unsigned __int64 tmp;          bool bNegative = false;         bool aNegative = false;     {     static bool RegMultiply( const T& a, const U& b, T& ret ) throw()     template < typename T, typename U > public: { template<> class LargeIntRegMultiply< signed __int64, signed __int64 >  };     }         LargeIntRegMultiply< unsigned __int32, unsigned __int64 >::template RegMultiplyThrow< E >( a, (unsigned __int64)b, ret );              E::SafeIntOnOverflow();         if( b < 0 && a != 0 )     {     static void RegMultiplyThrow( const T& a, const U& b, T& ret )     template < typename E, typename T, typename U >      }         return LargeIntRegMultiply< unsigned __int32, unsigned __int64 >::RegMultiply( a, (unsigned __int64)b, ret );             return false;         if( b < 0 && a != 0 )     {     static bool RegMultiply( const T& a, const U& b, T& ret ) throw()     template < typename T, typename U > public: { template<> class LargeIntRegMultiply< unsigned __int32, signed __int64 >  };     }         ret = (unsigned __int32)tmp;             E::SafeIntOnOverflow();         if( (unsigned __int32)(tmp >> 32) != 0 ) // overflow          unsigned __int64 tmp = b * (unsigned __int64)a;             E::SafeIntOnOverflow();         if( (unsigned __int32)(b >> 32) != 0 && a != 0 )     {     static void RegMultiplyThrow( const T& a, const U& b, T& ret )     template < typename E, typename T, typename U > ad  	   1     É       ±  £  x  `  R  H  G  '  !      ‘  “     ¢  \  V  6       ˇ  Í  ‡  ¬  ¨  ¢  °  ,  "  Á  À  Ω  í  ?  -  ˝  ‹     º  ´  ù  r      ﬁ
+  Ω
+  ´
+  ù
+  ì
+  í
+  |
+  v
+  u
+  A
+  ˛	  ¯	  ÿ	  ∫	  ¢	  °	  å	  Ç	  d	  N	  D	  C	  ¿  ø  à  p  f  ?    ‚  ∂  û  ê  Ü  y  o  H  ˘  Î  ¿  ®  ö  ê  è  o  i  f  e        Ï  ¶  †  Ä  `  _  A  )      ˚  Ò  ”  Ω  ≥  ≤  ù  ì  u  _  U  T  Ã  ¬  á  _  Q  &  ”  ¡  ë  p  ^  P  ?  1  0                       {             else             }                 }                     return true;                     ret = -(signed __int64)tmp;                 {                 if( tmp <= (unsigned __int64)IntTraits< signed __int64 >::minInt )                 // Result must be negative             {             if( aNegative ^ bNegative )             // The unsigned multiplication didn't overflow         {         if( LargeIntRegMultiply< unsigned __int64, unsigned __int32 >::RegMultiply( (unsigned __int64)a1, (unsigned __int32)b1, tmp ) )          }             b1 = -b1;             bNegative = true;         {         if( b1 < 0 )          }             a1 = -a1;             aNegative = true;         {         if( a1 < 0 )          __int64 b1 = b;         __int64 a1 = a;         unsigned __int64 tmp;          bool bNegative = false;         bool aNegative = false;     {     static bool RegMultiply( const T& a, const U& b, T& ret ) throw()     template < typename T, typename U > public: { template<> class LargeIntRegMultiply< signed __int64, signed __int32 >  };     }         E::SafeIntOnOverflow();          }             }                 return;                 ret = (signed __int64)tmp;             {             if( tmp <= (unsigned __int64)IntTraits< signed __int64 >::maxInt )             // Result must be positive         {         else         }             }                 return;                 ret = -(signed __int64)tmp;             {             if( tmp <= (unsigned __int64)IntTraits< signed __int64 >::minInt )             // Result must be negative         {         if( aNegative )         // The unsigned multiplication didn't overflow          LargeIntRegMultiply< unsigned __int64, unsigned __int32 >::template RegMultiplyThrow< E >( (unsigned __int64)a1, b, tmp );          }             a1 = -a1;             aNegative = true;         {         if( a1 < 0 )          __int64 a1 = a;         unsigned __int64 tmp;         bool aNegative = false;     {     static void RegMultiplyThrow( const T& a, const U& b, T& ret )     template < typename E, typename T, typename U >      }         return false;          }             }                 }                     return true;                     ret = (signed __int64)tmp;                 {                 if( tmp <= (unsigned __int64)IntTraits< signed __int64 >::maxInt )                 // Result must be positive             {             else             }                 }                     return true;                     ret = -(signed __int64)tmp;                 {                 if( tmp <= (unsigned __int64)IntTraits< signed __int64 >::minInt )                 // Result must be negative             {             if( aNegative )             // The unsigned multiplication didn't overflow         {         if( LargeIntRegMultiply< unsigned __int64, unsigned __int32 >::RegMultiply( (unsigned __int64)a1, b, tmp ) )          }             a1 = -a1;             aNegative = true;         {         if( a1 < 0 )          __int64 a1 = a;         unsigned __int64 tmp;         bool aNegative = false;     {     static bool RegMultiply( const T& a, const U& b, T& ret ) throw()     template < typename T, typename U > public: { template<> class LargeIntRegMultiply< signed __int64, unsigned __int32 >  };     }         E::SafeIntOnOverflow();          }             }                 return;                 ret = (signed __int64)tmp;             {             if( tmp <= (unsigned __int64)IntTraits< signed __int64 >::maxInt ) ad  (   `     á       ’  Ç  p  A          ˆ  ı  ﬂ  Ÿ  ÿ  §  o  i  I  )  (  
+  	  ı  Î  Õ  π  Ø  Æ  ö  ê  r  ^  T  S  ø  æ  á  c  Y  2  „  ’  ©  ë  É  y  l  b  ;  Ï
+  ﬁ
+  ≥
+  õ
+  ç
+  É
+  Ç
+  b
+  \
+  Y
+  X
+  
+  
+  
+  ﬂ	  †	  ö	  z	  Z	  Y	  ;	  #	  "	  	  	  Ê  “  »  «  ≤  ®  ä  t  j  i  ‚  ÿ  ù  u  g  <  È  ◊  ∑  ñ  Ñ  v  e  W  ,  Ÿ  «  ò  w  e  W  M  L  6  0  /  ˚  ø  π  ô  y  x  Z  ;  :  &    ˛  Í  ‡  ﬂ  À  ¡  £  ç  É  Ç  Ì  Ï  µ  ë  á  `  _                                                      // Result must be negative         {         if( aNegative ^ bNegative )         // The unsigned multiplication didn't overflow          LargeIntRegMultiply< unsigned __int32, unsigned __int64 >::template RegMultiplyThrow< E >( (unsigned __int32)a, (unsigned __int64)b2, tmp );          }             b2 = -b2;             bNegative = true;         {         if( b < 0 )          }             a = -a;             aNegative = true;         {         if( a < 0 )          signed __int64 b2 = b;         unsigned __int32 tmp;          bool bNegative = false;         bool aNegative = false;     {     static void RegMultiplyThrow( T a, const U& b, T& ret )     template < typename E, typename T, typename U >      }         return false;          }             }                 }                     return true;                     ret = (signed __int32)tmp;                 {                 if( tmp <= (unsigned __int32)IntTraits< signed __int32 >::maxInt )                 // Result must be positive             {             else             }                 }                     return true;                     ret = -tmp;                 {                 if( tmp <= (unsigned __int32)IntTraits< signed __int32 >::minInt )                 // Result must be negative             {             if( aNegative ^ bNegative )             // The unsigned multiplication didn't overflow         {         if( LargeIntRegMultiply< unsigned __int32, unsigned __int64 >::RegMultiply( (unsigned __int32)a, (unsigned __int64)b1, tmp ) )          }             b1 = -b1;             bNegative = true;         {         if( b1 < 0 )          }             a = -a;             aNegative = true;         {         if( a < 0 )          __int64 b1 = b;         unsigned __int32 tmp;          bool bNegative = false;         bool aNegative = false;     {     static bool RegMultiply( T a, const U& b, T& ret ) throw()     template < typename T, typename U > public: { template<> class LargeIntRegMultiply< signed __int32, signed __int64 >  };     }         E::SafeIntOnOverflow();          }             }                 return;                 ret = (signed __int64)tmp;             {             if( tmp <= (unsigned __int64)IntTraits< signed __int64 >::maxInt )             // Result must be positive         {         else         }             }                 return;                 ret = -(signed __int64)tmp;             {             if( tmp <= (unsigned __int64)IntTraits< signed __int64 >::minInt )             // Result must be negative         {         if( aNegative ^ bNegative )         // The unsigned multiplication didn't overflow          LargeIntRegMultiply< unsigned __int64, unsigned __int32 >::template RegMultiplyThrow< E >( (unsigned __int64)a, (unsigned __int32)b, tmp );          }             b = -b;             bNegative = true;         {         if( b < 0 )          }             a = -a;             aNegative = true;         {         if( a < 0 )          unsigned __int64 tmp;          bool bNegative = false;         bool aNegative = false;     {     static void RegMultiplyThrow( T a, U b, T& ret )     template < typename E, typename T, typename U >      }         return false;          }             }                 }                     return true;                     ret = (signed __int64)tmp;                 {                 if( tmp <= (unsigned __int64)IntTraits< signed __int64 >::maxInt )                 // Result must be positive ad     M     Ö       ‹  ∏  ñ  w  t  s  :  8  0  '  !  ø  U  &  ı  â    ≥  L  E  B  A  ¸  ˚  ®  ¶  û  R  L  7  -    Ù
+  Í
+  È
+  ‘
+  ¨
+  ´
+  é
+  o
+  i
+  h
+  L
+  
+  
+  	  Ê	  œ	  º	  ≤	  ±	  ú	  y	  x	  [	  U	  R	  Q	  Û  Ò  È  ù  ó  Ç  x  a  ?  5  4       ı  “  »  «  ≤  ä  â  '    ∑  ≠  ï  r  h  g  =  7  6    Ÿ  ”  æ  ¥  ù  ä  Ä    k  a  @  ,  "  !    È  Ë  Ü  a      Ù  ‡  ÷  ’  µ  Ø  ¨  ´  J  H  @  Ù  Ó  Ÿ  œ  ∏  ñ  å  ã  v  N  M  L                                            return SafeIntDivideByZero;         if( u == 0 )          }            return SafeIntNoError;            result = 0;         {         if( t == 0 )     {     static SafeIntError Divide( const T& t, const U& u, T& result ) throw() public: { template < typename T, typename U > class DivisionHelper< T, U, DivisionState_SignedUnsigned32 >  };     }         E::SafeIntOnOverflow();          }             return;             result = 0;         {         if( AbsValueHelper< U, GetAbsMethod< U >::method >::Abs( u ) > t )         // unless u is bigger than t         // it is always an error to try and divide an unsigned number by a negative signed number              E::SafeIntOnDivZero();         if( u == 0 )          }             return;             result = (T)( t/u );         {         if( u > 0 )          }            return;            result = 0;         {         if( t == 0 )     {     static void DivideThrow( const T& t, const U& u, T& result )     template < typename E >      }         return SafeIntArithmeticOverflow;          }             return SafeIntNoError;             result = 0;         {         if( AbsValueHelper< U, GetAbsMethod< U >::method >::Abs( u ) > t )         // unless u is bigger than t         // it is always an error to try and divide an unsigned number by a negative signed number              return SafeIntDivideByZero;         if( u == 0 )          }             return SafeIntNoError;             result = (T)( t/u );         {         if( u > 0 )          }            return SafeIntNoError;            result = 0;         {         if( t == 0 )     {     static SafeIntError Divide( const T& t, const U& u, T& result ) throw() public: { template < typename T, typename U > class DivisionHelper< T, U, DivisionState_UnsignedSigned>  };     }         result = (T)( t/u );              E::SafeIntOnDivZero();         if( u == 0 )          }            return;            result = 0;         {         if( t == 0 )     {     static void DivideThrow( const T& t, const U& u, T& result )     template < typename E >      }         return SafeIntNoError;         result = (T)( t/u );              return SafeIntDivideByZero;         if( u == 0 )          }            return SafeIntNoError;            result = 0;         {         if( t == 0 )     {     static SafeIntError Divide( const T& t, const U& u, T& result ) throw() public: { template < typename T, typename U > class DivisionHelper< T, U, DivisionState_OK >  template < typename T, typename U, int state > class DivisionHelper;  };     };                                                                            DivisionState_SignedSigned)                  (IntTraits< T >::isSigned && !IntTraits< U >::isSigned) ? DivisionState_SignedUnsigned :                  (IntTraits< T >::isSigned && IntTraits< U >::isUint64)  ? DivisionState_SignedUnsigned64 :                     IntTraits< T >::isLT64Bit)                           ? DivisionState_SignedUnsigned32 :                     IntTraits< U >::isUint32 &&                   (IntTraits< T >::isSigned &&                   (!IntTraits< T >::isSigned && IntTraits< U >::isSigned) ? DivisionState_UnsignedSigned :         method = (SafeIntCompare< T, U >::isBothUnsigned                     ? DivisionState_OK :     {     enum public: { template < typename T, typename U > class DivisionMethod  };     DivisionState_SignedSigned     DivisionState_SignedUnsigned,     DivisionState_SignedUnsigned64,     DivisionState_SignedUnsigned32, ad          r       ì  ç  å  p  0  *  ≥  ≠  ™  ©  C  A  9  ˆ    û  ò  ó  {  ;  5  Ÿ  ”  –  œ  l  j  b  C      ¶  †  ü  É  J  D  ﬂ
+  Ÿ
+  ÷
+  ’
+  q
+  o
+  g
+  H
+  
+  
+  Û	  Ú	  è	  -	  #	  
+	   	  ˇ  È  „  ‚  ∆  è  â  t  k  ˚  ã  Ö  Ç  Å        Œ  »  m  g  f  J  
+    ù  ó  î  ì  1  /  '    À  ≈  ∞  Ø  U  Û  È  –  ∆  ≈  Ø  ©  ®  å  U  O  :  1     Z  T  Q  P  =  ;  %                                         DivisionState_UnsignedSigned,     DivisionState_OK, { enum DivisionState  };     }         SafeCastHelper< T, __int32, GetCastMethod< T, __int32 >::method >::template CastThrow< E >( tmp, ret );         LargeIntRegMultiply< __int32, __int64 >::template RegMultiplyThrow< E >( (__int32)t, u, tmp );                  __int32 tmp;     {     static void MultiplyThrow(T t, const U& u, T& ret)     template < typename E >      }         return false;          }             return true;         {             SafeCastHelper< T, __int32, GetCastMethod< T, __int32 >::method >::Cast( tmp, ret ) )         if( LargeIntRegMultiply< __int32, __int64 >::RegMultiply( (__int32)t, u, tmp ) &&          __int32 tmp;     {     static bool Multiply( T t, const U& u, T& ret ) throw()     //T is signed, up to 32-bit public: { template <typename T, typename U> class MultiplicationHelper< T, U, MultiplicationState_IntInt64>  };     }         LargeIntRegMultiply< __int64, unsigned __int64 >::template RegMultiplyThrow< E >( t, u, ret );     {     static void MultiplyThrow( const T& t, const U& u, T& ret )     template < typename E >      }         return LargeIntRegMultiply< __int64, unsigned __int64 >::RegMultiply( t, u, ret );     {     static bool Multiply( const T& t, const U& u, T& ret ) throw() public: { template < typename T, typename U > class MultiplicationHelper<T, U, MultiplicationState_Int64Uint64>  };     }         SafeCastHelper< T, __int32, GetCastMethod< T, __int32 >::method >::template CastThrow< E >( tmp, ret );         LargeIntRegMultiply< __int32, unsigned __int64 >::template RegMultiplyThrow< E >( (__int32)t, u, tmp );                  __int32 tmp;     {     static void MultiplyThrow(T t, const U& u, T& ret)     template < typename E >      }         return false;          }             return true;         {             SafeCastHelper< T, __int32, GetCastMethod< T, __int32 >::method >::Cast( tmp, ret ) )         if( LargeIntRegMultiply< __int32, unsigned __int64 >::RegMultiply( (__int32)t, u, tmp ) &&          __int32 tmp;     {     static bool Multiply(T t, const U& u, T& ret) throw()     //T is signed up to 32-bit public: { template <typename T, typename U> class MultiplicationHelper< T, U, MultiplicationState_IntUint64 >  };     }         LargeIntRegMultiply< __int64, __int32 >::template RegMultiplyThrow< E >(t, (__int32)u, ret);     {     static void MultiplyThrow( const T& t, U u, T& ret )     template < typename E >      }         return LargeIntRegMultiply< __int64, __int32 >::RegMultiply( t, (__int32)u, ret );     {     static bool Multiply( const T& t, U u, T& ret ) throw()     //U is signed up to 32-bit public: { template < typename T, typename U > class MultiplicationHelper<T, U, MultiplicationState_Int64Int>  };     }         LargeIntRegMultiply< __int64, __int64 >::template RegMultiplyThrow< E >(t, u, ret);     {     static void MultiplyThrow( const T& t, const U& u, T& ret )     template < typename E >      }         return LargeIntRegMultiply< __int64, __int64 >::RegMultiply( t, u, ret );     {     static bool Multiply( const T& t, const U& u, T& ret ) throw() public: { template < typename T, typename U > class MultiplicationHelper<T, U, MultiplicationState_Int64Int64 >  };     }         LargeIntRegMultiply< __int64, unsigned __int32 >::template RegMultiplyThrow< E >(t, (unsigned __int32)u, ret);     {     static void MultiplyThrow( const T& t, const U& u, T& ret )     template < typename E >      }         return LargeIntRegMultiply< __int64, unsigned __int32 >::RegMultiply( t, (unsigned __int32)u, ret ); ad  ·              ˙  ˘  ›  ù  ó    ˝  Ë  –  ∞  Ø  ò  &         †  _  Y  ;  :  ≈  S  I  0  &  %    	    Ï  Æ  ®  ä  Å  ˇ
+  
+  y
+  v
+  u
+  
+  
+  
+  ﬁ	  ù	  ó	  '	  !	   	  	  ∆  ¿  D  >  ;  :  ”  —  …  à  Ç  )  #  "    »  ¬  ]  W  T  S  Ô  Ì  Â  ƒ  É  }  _  ^  Ú  Ä  v  ]  S  R  <  6  5    €  ’  ∑  Æ  5  µ  Ø  ¨  ´  F  D  <    ÿ  “                                {     static bool Multiply( const T& t, const U& u, T& ret ) throw()     //U is unsigned up to 32-bit public: { template < typename T, typename U > class MultiplicationHelper<T, U, MultiplicationState_Int64Uint >  };     }         SafeCastHelper< T, unsigned __int32, GetCastMethod< T, unsigned __int32 >::method >::template CastThrow< E >(tmp, ret);         LargeIntRegMultiply< unsigned __int32, __int64 >::template RegMultiplyThrow< E >( (unsigned __int32)t, u, tmp );                  unsigned __int32 tmp;     {     static void MultiplyThrow(const T& t, const U& u, T& ret)     template < typename E >      }         return false;          }             return true;         {             SafeCastHelper< T, unsigned __int32, GetCastMethod< T, unsigned __int32 >::method >::Cast(tmp, ret) )         if( LargeIntRegMultiply< unsigned __int32, __int64 >::RegMultiply( (unsigned __int32)t, u, tmp ) &&          unsigned __int32 tmp;     {     static bool Multiply(const T& t, const U& u, T& ret) throw()     //T is unsigned up to 32-bit public: { template <typename T, typename U> class MultiplicationHelper< T, U, MultiplicationState_UintInt64 >  };     }         LargeIntRegMultiply< unsigned __int64, __int64 >::template RegMultiplyThrow< E >(t, u, ret);     {     static void MultiplyThrow(const T& t, const U& u, T& ret)     template < typename E >      }         return LargeIntRegMultiply< unsigned __int64, __int64 >::RegMultiply(t, u, ret);     {     static bool Multiply(const T& t, const U& u, T& ret) throw() public: { template < typename T, typename U > class MultiplicationHelper<T, U, MultiplicationState_Uint64Int64 >  };     }         LargeIntRegMultiply< unsigned __int64, signed __int32 >::template RegMultiplyThrow< E >(t, (signed __int32)u, ret);     {     static void MultiplyThrow(const T& t, const U& u, T& ret)     template < typename E >      }         return LargeIntRegMultiply< unsigned __int64, signed __int32 >::RegMultiply(t, (signed __int32)u, ret);     {     static bool Multiply(const T& t, const U& u, T& ret) throw()     //U is any signed int, up to 64-bit public: { template < typename T, typename U > class MultiplicationHelper<T, U, MultiplicationState_Uint64Int >  };     }         SafeCastHelper< T, unsigned __int32, GetCastMethod< T, unsigned __int32 >::method >::template CastThrow< E >(tmp, ret);         LargeIntRegMultiply< unsigned __int32, unsigned __int64 >::template RegMultiplyThrow< E >( (unsigned __int32)t, u, tmp );                  unsigned __int32 tmp;     {     static void MultiplyThrow(const T& t, const U& u, T& ret)     template < typename E >      }         return false;          }             return true;         {             SafeCastHelper< T, unsigned __int32, GetCastMethod< T, unsigned __int32 >::method >::Cast(tmp, ret) )         if( LargeIntRegMultiply< unsigned __int32, unsigned __int64 >::RegMultiply( (unsigned __int32)t, u, tmp ) &&          unsigned __int32 tmp;     {     static bool Multiply(const T& t, const U& u, T& ret) throw()     // T is any unsigned int up to 32-bit public: { template <typename T, typename U> class Mul            re        ret         ret =        ret = tmp;         LargeIntRegMultiply< unsigned __int64, unsigned __int32 >::template RegMultiplyThrow< E        ret = tmp;              ret = ret64        ret =        return boolret;         ret = ret64;         LargeIntRegMulti        LargeIntRegMultiply< unsigned __int64, unsigned __int32 >::template RegMultiplyThrow< E >( t, (unsigned __int32)u, ret );     {     static void MultiplyThrow( const T& t, const U& u, T& ret )     template < typename E >      } ad  “  j     _       ˙  ˜  ˆ  —  l  j  b  8  ˜  Ò  ”  “  ]  Î  ·  »  æ  Ω  ß  °  †  Ñ  F  @  "    ó          ®  ¶  û  v  5  /  ø
+  π
+  ∏
+  ú
+  ^
+  X
+  ‹	  ÷	  ”	  “	  k	  i	  a	   	  	  ¡  ª  ∫  û  `  Z  ı  Ô  Ï  Î  á  Ö  }  \      ˜  ˆ  ä      ı  Î  Í  ‘  Œ  Õ  ±  s  m  O  F  Õ  M  G  D  C  ﬁ  ‹  ‘  ≥  p  j  S  9  0    	    Ì  œ                                                                                                                                                                                                                                                                                           {     {        {     st    {        {        {     sta    {     {         {     sta        {     st    {        {     static bool M       {     static bool M    {     static bool Multiply( const T& t, const U& u, T& ret ) throw()     //U is unsigned up to 32-bit public: { template < typename T, typename U > class MultiplicationHelper<T, U, MultiplicationState_Int64Uint >  };     }         SafeCastHelper< T, unsigned __int32, GetCastMethod< T, unsigned __int32 >::method >::template CastThrow< E >(tmp, ret);         LargeIntRegMultiply< unsigned __int32, __int64 >::template RegMultiplyThrow< E >( (unsigned __int32)t, u, tmp );                  unsigned __int32 tmp;     {     static void MultiplyThrow(const T& t, const U& u, T& ret)     template < typename E >      }         return false;          }             return true;         {             SafeCastHelper< T, unsigned __int32, GetCastMethod< T, unsigned __int32 >::method >::Cast(tmp, ret) )         if( LargeIntRegMultiply< unsigned __int32, __int64 >::RegMultiply( (unsigned __int32)t, u, tmp ) &&          unsigned __int32 tmp;     {     static bool Multiply(const T& t, const U& u, T& ret) throw()     //T is unsigned up to 32-bit public: { template <typename T, typename U> class MultiplicationHelper< T, U, MultiplicationState_UintInt64 >  };     }         LargeIntRegMultiply< unsigned __int64, __int64 >::template RegMultiplyThrow< E >(t, u, ret);     {     static void MultiplyThrow(const T& t, const U& u, T& ret)     template < typename E >      }         return LargeIntRegMultiply< unsigned __int64, __int64 >::RegMultiply(t, u, ret);     {     static bool Multiply(const T& t, const U& u, T& ret) throw() public: { template < typename T, typename U > class MultiplicationHelper<T, U, MultiplicationState_Uint64Int64 >  };     }         LargeIntRegMultiply< unsigned __int64, signed __int32 >::template RegMultiplyThrow< E >(t, (signed __int32)u, ret);     {     static void MultiplyThrow(const T& t, const U& u, T& ret)     template < typename E >      }         return LargeIntRegMultiply< unsigned __int64, signed __int32 >::RegMultiply(t, (signed __int32)u, ret);     {     static bool Multiply(const T& t, const U& u, T& ret) throw()     //U is any signed int, up to 64-bit public: { template < typename T, typename U > class MultiplicationHelper<T, U, MultiplicationState_Uint64Int >  };     }         SafeCastHelper< T, unsigned __int32, GetCastMethod< T, unsigned __int32 >::method >::template CastThrow< E >(tmp, ret);         LargeIntRegMultiply< unsigned __int32, unsigned __int64 >::template RegMultiplyThrow< E >( (unsigned __int32)t, u, tmp );                  unsigned __int32 tmp;     {     static void MultiplyThrow(const T& t, const U& u, T& ret)     template < typename E >      }         return false;          }             return true;         {             SafeCastHelper< T, unsigned __int32, GetCastMethod< T, unsigned __int32 >::method >::Cast(tmp, ret) )         if( LargeIntRegMultiply< unsigned __int32, unsigned __int64 >::RegMultiply( (unsigned __int32)t, u, tmp ) &&          unsigned __int32 tmp;     {     static bool Multiply(const T& t, const U& u, T& ret) throw()     // T is any unsigned int up to 32-bit public: { template <typename T, typename U> class MultiplicationHelper< T, U, MultiplicationState_UintUint64 > // converse of the previous function  };     } 
\ No newline at end of file
diff -Naurp safe_int.orig/SafeIntTest.cpp safe_int/SafeIntTest.cpp
--- safe_int.orig/SafeIntTest.cpp	2010-01-12 19:06:16.000000000 -0500
+++ safe_int/SafeIntTest.cpp	2010-01-12 19:06:51.000000000 -0500
@@ -22,8 +22,12 @@ void TestCasts()
 	float f = st;
 	double d = st;
 	long double ld = st;
+        (void)f;
+        (void)d;
+        (void)ld;
 #endif
 	u++;
+        (void)b;
 }
 
 template <typename T, typename U>
@@ -31,7 +35,7 @@ void TestConstructors()
 {
 	SafeInt<T> st;
 	SafeInt<U> su;
-	U u;
+	U u(0);
 	SafeInt<T> st2(u);
 	SafeInt<T> st3(su);
 	// We can also construct from a bool
@@ -45,6 +49,7 @@ void TestConstructors()
 	SafeInt<T> st6(d);
 	SafeInt<T> st7(ld);
 #endif
+        (void)b;
 }
 
 template <typename T, typename U>
@@ -141,6 +146,8 @@ void TestCompare()
   bool b4 = ((st <= su) && (st <= u) && (u <= st));
   bool b5 = ((st == su) && (st == u) && (u == st) && (b4 == st) && (st == b3));
   bool b6 = ((st != su) && (st != u) && (u != st) && (b4 != st) && (st != b3));
+  (void)(b && b2 && b3 && b4 && b5 && b6);
+  (void)t;
 }
 
 template <typename T, typename U>
@@ -171,7 +178,7 @@ void TestBitwise()
 {
    SafeInt<T> st;
    SafeInt<U> su;
-   U u;
+   U u(0);
    SafeInt<T> st2;
 
   // and
@@ -268,6 +275,7 @@ void TestCompileIntTraits()
    bool fisLT32Bit = IntTraits<T>::isLT32Bit;
    bool fisLT64Bit = IntTraits<T>::isLT64Bit;
    bool fisInt8 = IntTraits<T>::isInt8;
+   (void)(fSigned && fis64bit && fis32bit && fis16bit && fis8bit && fisLT32Bit && fisLT64Bit && fisInt8);
 }
 
 template <typename T>
@@ -288,7 +296,12 @@ void TestPtrRef()
 #if !defined SAFEINT_VS_VERSION
   const T* ptc2 = &st;
   T* pt2 = &st;
+  (void)pt2;
+  (void)ptc2;
 #endif
+  (void)pt;
+  (void)ptc;
+  (void)tref;
 }
 
 template <typename T>
@@ -358,6 +371,6 @@ void TestCompile()
 
 int main(int argc, char* argv[])
 {
-	argc;
-	argv;
+	(void)argc;
+	(void)argv;
 }
